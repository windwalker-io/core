System.register([], (function(exports, module) {
    "use strict";
    return {
        execute: (function() {
            var __vite_style__ = document.createElement("style");
            __vite_style__.textContent = "/*!\n * vue-animate.css - https://github.com/asika32764/vue-animate\n * Version: 3.0.2\n * License: MIT - see LICENSE\n * \n * This library is port of animate.css (https://github.com/animate-css/animate.css) to support Vue.js transitions.\n * The animate.css LICENSE please see: https://github.com/animate-css/animate.css/blob/main/LICENSE\n */:root{--animate-duration:.5s;--animate-delay:0;--animate-repeat:1}.animate__animated{-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-duration:var(--animate-duration);animation-duration:var(--animate-duration);-webkit-animation-fill-mode:both;animation-fill-mode:both}.animate__animated.animate__infinite{-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}.animate__animated.animate__repeat-1{-webkit-animation-iteration-count:1;animation-iteration-count:1;-webkit-animation-iteration-count:var(--animate-repeat);animation-iteration-count:var(--animate-repeat)}.animate__animated.animate__repeat-2{-webkit-animation-iteration-count:2;animation-iteration-count:2;-webkit-animation-iteration-count:calc(var(--animate-repeat)*2);animation-iteration-count:calc(var(--animate-repeat)*2)}.animate__animated.animate__repeat-3{-webkit-animation-iteration-count:3;animation-iteration-count:3;-webkit-animation-iteration-count:calc(var(--animate-repeat)*3);animation-iteration-count:calc(var(--animate-repeat)*3)}.animate__animated.animate__delay-1s{-webkit-animation-delay:1s;animation-delay:1s;-webkit-animation-delay:var(--animate-delay);animation-delay:var(--animate-delay)}.animate__animated.animate__delay-2s{-webkit-animation-delay:2s;animation-delay:2s;-webkit-animation-delay:calc(var(--animate-delay)*2);animation-delay:calc(var(--animate-delay)*2)}.animate__animated.animate__delay-3s{-webkit-animation-delay:3s;animation-delay:3s;-webkit-animation-delay:calc(var(--animate-delay)*3);animation-delay:calc(var(--animate-delay)*3)}.animate__animated.animate__delay-4s{-webkit-animation-delay:4s;animation-delay:4s;-webkit-animation-delay:calc(var(--animate-delay)*4);animation-delay:calc(var(--animate-delay)*4)}.animate__animated.animate__delay-5s{-webkit-animation-delay:5s;animation-delay:5s;-webkit-animation-delay:calc(var(--animate-delay)*5);animation-delay:calc(var(--animate-delay)*5)}.animate__animated.animate__faster{-webkit-animation-duration:.5s;animation-duration:.5s;-webkit-animation-duration:calc(var(--animate-duration)/2);animation-duration:calc(var(--animate-duration)/2)}.animate__animated.animate__fast{-webkit-animation-duration:.8s;animation-duration:.8s;-webkit-animation-duration:calc(var(--animate-duration)*.8);animation-duration:calc(var(--animate-duration)*.8)}.animate__animated.animate__slow{-webkit-animation-duration:2s;animation-duration:2s;-webkit-animation-duration:calc(var(--animate-duration)*2);animation-duration:calc(var(--animate-duration)*2)}.animate__animated.animate__slower{-webkit-animation-duration:3s;animation-duration:3s;-webkit-animation-duration:calc(var(--animate-duration)*3);animation-duration:calc(var(--animate-duration)*3)}@media (prefers-reduced-motion:reduce),print{.animate__animated{-webkit-animation-duration:1ms!important;animation-duration:1ms!important;-webkit-animation-iteration-count:1!important;animation-iteration-count:1!important;-webkit-transition-duration:1ms!important;transition-duration:1ms!important}.animate__animated[class*=Out]{opacity:0}}@-webkit-keyframes bounce{0%,20%,53%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translateZ(0);transform:translateZ(0)}40%,43%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-30px,0) scaleY(1.1);transform:translate3d(0,-30px,0) scaleY(1.1)}70%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-15px,0) scaleY(1.05);transform:translate3d(0,-15px,0) scaleY(1.05)}80%{-webkit-transform:translateZ(0) scaleY(.95);transform:translateZ(0) scaleY(.95);-webkit-transition-timing-function:cubic-bezier(.215,.61,.355,1);transition-timing-function:cubic-bezier(.215,.61,.355,1)}90%{-webkit-transform:translate3d(0,-4px,0) scaleY(1.02);transform:translate3d(0,-4px,0) scaleY(1.02)}}@keyframes bounce{0%,20%,53%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translateZ(0);transform:translateZ(0)}40%,43%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-30px,0) scaleY(1.1);transform:translate3d(0,-30px,0) scaleY(1.1)}70%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-15px,0) scaleY(1.05);transform:translate3d(0,-15px,0) scaleY(1.05)}80%{-webkit-transform:translateZ(0) scaleY(.95);transform:translateZ(0) scaleY(.95);-webkit-transition-timing-function:cubic-bezier(.215,.61,.355,1);transition-timing-function:cubic-bezier(.215,.61,.355,1)}90%{-webkit-transform:translate3d(0,-4px,0) scaleY(1.02);transform:translate3d(0,-4px,0) scaleY(1.02)}}.animate__bounce{-webkit-animation-name:bounce;animation-name:bounce;-webkit-transform-origin:center bottom;transform-origin:center bottom}@-webkit-keyframes flash{0%,50%,to{opacity:1}25%,75%{opacity:0}}@keyframes flash{0%,50%,to{opacity:1}25%,75%{opacity:0}}.animate__flash{-webkit-animation-name:flash;animation-name:flash}@-webkit-keyframes pulse{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}50%{-webkit-transform:scale3d(1.05,1.05,1.05);transform:scale3d(1.05,1.05,1.05)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes pulse{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}50%{-webkit-transform:scale3d(1.05,1.05,1.05);transform:scale3d(1.05,1.05,1.05)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}.animate__pulse{-webkit-animation-name:pulse;animation-name:pulse;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}@-webkit-keyframes rubberBand{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}30%{-webkit-transform:scale3d(1.25,.75,1);transform:scale3d(1.25,.75,1)}40%{-webkit-transform:scale3d(.75,1.25,1);transform:scale3d(.75,1.25,1)}50%{-webkit-transform:scale3d(1.15,.85,1);transform:scale3d(1.15,.85,1)}65%{-webkit-transform:scale3d(.95,1.05,1);transform:scale3d(.95,1.05,1)}75%{-webkit-transform:scale3d(1.05,.95,1);transform:scale3d(1.05,.95,1)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes rubberBand{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}30%{-webkit-transform:scale3d(1.25,.75,1);transform:scale3d(1.25,.75,1)}40%{-webkit-transform:scale3d(.75,1.25,1);transform:scale3d(.75,1.25,1)}50%{-webkit-transform:scale3d(1.15,.85,1);transform:scale3d(1.15,.85,1)}65%{-webkit-transform:scale3d(.95,1.05,1);transform:scale3d(.95,1.05,1)}75%{-webkit-transform:scale3d(1.05,.95,1);transform:scale3d(1.05,.95,1)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}.animate__rubberBand{-webkit-animation-name:rubberBand;animation-name:rubberBand}@-webkit-keyframes shakeX{0%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}10%,30%,50%,70%,90%{-webkit-transform:translate3d(-10px,0,0);transform:translate3d(-10px,0,0)}20%,40%,60%,80%{-webkit-transform:translate3d(10px,0,0);transform:translate3d(10px,0,0)}}@keyframes shakeX{0%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}10%,30%,50%,70%,90%{-webkit-transform:translate3d(-10px,0,0);transform:translate3d(-10px,0,0)}20%,40%,60%,80%{-webkit-transform:translate3d(10px,0,0);transform:translate3d(10px,0,0)}}.animate__shakeX{-webkit-animation-name:shakeX;animation-name:shakeX}@-webkit-keyframes shakeY{0%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}10%,30%,50%,70%,90%{-webkit-transform:translate3d(0,-10px,0);transform:translate3d(0,-10px,0)}20%,40%,60%,80%{-webkit-transform:translate3d(0,10px,0);transform:translate3d(0,10px,0)}}@keyframes shakeY{0%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}10%,30%,50%,70%,90%{-webkit-transform:translate3d(0,-10px,0);transform:translate3d(0,-10px,0)}20%,40%,60%,80%{-webkit-transform:translate3d(0,10px,0);transform:translate3d(0,10px,0)}}.animate__shakeY{-webkit-animation-name:shakeY;animation-name:shakeY}@-webkit-keyframes headShake{0%{-webkit-transform:translateX(0);transform:translateX(0)}6.5%{-webkit-transform:translateX(-6px) rotateY(-9deg);transform:translateX(-6px) rotateY(-9deg)}18.5%{-webkit-transform:translateX(5px) rotateY(7deg);transform:translateX(5px) rotateY(7deg)}31.5%{-webkit-transform:translateX(-3px) rotateY(-5deg);transform:translateX(-3px) rotateY(-5deg)}43.5%{-webkit-transform:translateX(2px) rotateY(3deg);transform:translateX(2px) rotateY(3deg)}50%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes headShake{0%{-webkit-transform:translateX(0);transform:translateX(0)}6.5%{-webkit-transform:translateX(-6px) rotateY(-9deg);transform:translateX(-6px) rotateY(-9deg)}18.5%{-webkit-transform:translateX(5px) rotateY(7deg);transform:translateX(5px) rotateY(7deg)}31.5%{-webkit-transform:translateX(-3px) rotateY(-5deg);transform:translateX(-3px) rotateY(-5deg)}43.5%{-webkit-transform:translateX(2px) rotateY(3deg);transform:translateX(2px) rotateY(3deg)}50%{-webkit-transform:translateX(0);transform:translateX(0)}}.animate__headShake{-webkit-animation-name:headShake;animation-name:headShake;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}@-webkit-keyframes swing{20%{-webkit-transform:rotate(15deg);transform:rotate(15deg)}40%{-webkit-transform:rotate(-10deg);transform:rotate(-10deg)}60%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}80%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}to{-webkit-transform:rotate(0deg);transform:rotate(0deg)}}@keyframes swing{20%{-webkit-transform:rotate(15deg);transform:rotate(15deg)}40%{-webkit-transform:rotate(-10deg);transform:rotate(-10deg)}60%{-webkit-transform:rotate(5deg);transform:rotate(5deg)}80%{-webkit-transform:rotate(-5deg);transform:rotate(-5deg)}to{-webkit-transform:rotate(0deg);transform:rotate(0deg)}}.animate__swing{-webkit-animation-name:swing;animation-name:swing;-webkit-transform-origin:top center;transform-origin:top center}@-webkit-keyframes tada{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}10%,20%{-webkit-transform:scale3d(.9,.9,.9) rotate(-3deg);transform:scale3d(.9,.9,.9) rotate(-3deg)}30%,50%,70%,90%{-webkit-transform:scale3d(1.1,1.1,1.1) rotate(3deg);transform:scale3d(1.1,1.1,1.1) rotate(3deg)}40%,60%,80%{-webkit-transform:scale3d(1.1,1.1,1.1) rotate(-3deg);transform:scale3d(1.1,1.1,1.1) rotate(-3deg)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes tada{0%{-webkit-transform:scaleX(1);transform:scaleX(1)}10%,20%{-webkit-transform:scale3d(.9,.9,.9) rotate(-3deg);transform:scale3d(.9,.9,.9) rotate(-3deg)}30%,50%,70%,90%{-webkit-transform:scale3d(1.1,1.1,1.1) rotate(3deg);transform:scale3d(1.1,1.1,1.1) rotate(3deg)}40%,60%,80%{-webkit-transform:scale3d(1.1,1.1,1.1) rotate(-3deg);transform:scale3d(1.1,1.1,1.1) rotate(-3deg)}to{-webkit-transform:scaleX(1);transform:scaleX(1)}}.animate__tada{-webkit-animation-name:tada;animation-name:tada}@-webkit-keyframes wobble{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-25%,0,0) rotate(-5deg);transform:translate3d(-25%,0,0) rotate(-5deg)}30%{-webkit-transform:translate3d(20%,0,0) rotate(3deg);transform:translate3d(20%,0,0) rotate(3deg)}45%{-webkit-transform:translate3d(-15%,0,0) rotate(-3deg);transform:translate3d(-15%,0,0) rotate(-3deg)}60%{-webkit-transform:translate3d(10%,0,0) rotate(2deg);transform:translate3d(10%,0,0) rotate(2deg)}75%{-webkit-transform:translate3d(-5%,0,0) rotate(-1deg);transform:translate3d(-5%,0,0) rotate(-1deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-25%,0,0) rotate(-5deg);transform:translate3d(-25%,0,0) rotate(-5deg)}30%{-webkit-transform:translate3d(20%,0,0) rotate(3deg);transform:translate3d(20%,0,0) rotate(3deg)}45%{-webkit-transform:translate3d(-15%,0,0) rotate(-3deg);transform:translate3d(-15%,0,0) rotate(-3deg)}60%{-webkit-transform:translate3d(10%,0,0) rotate(2deg);transform:translate3d(10%,0,0) rotate(2deg)}75%{-webkit-transform:translate3d(-5%,0,0) rotate(-1deg);transform:translate3d(-5%,0,0) rotate(-1deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__wobble{-webkit-animation-name:wobble;animation-name:wobble}@-webkit-keyframes jello{0%,11.1%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}22.2%{-webkit-transform:skewX(-12.5deg) skewY(-12.5deg);transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{-webkit-transform:skewX(6.25deg) skewY(6.25deg);transform:skewX(6.25deg) skewY(6.25deg)}44.4%{-webkit-transform:skewX(-3.125deg) skewY(-3.125deg);transform:skewX(-3.125deg) skewY(-3.125deg)}55.5%{-webkit-transform:skewX(1.5625deg) skewY(1.5625deg);transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{-webkit-transform:skewX(-.78125deg) skewY(-.78125deg);transform:skewX(-.78125deg) skewY(-.78125deg)}77.7%{-webkit-transform:skewX(.390625deg) skewY(.390625deg);transform:skewX(.390625deg) skewY(.390625deg)}88.8%{-webkit-transform:skewX(-.1953125deg) skewY(-.1953125deg);transform:skewX(-.1953125deg) skewY(-.1953125deg)}}@keyframes jello{0%,11.1%,to{-webkit-transform:translateZ(0);transform:translateZ(0)}22.2%{-webkit-transform:skewX(-12.5deg) skewY(-12.5deg);transform:skewX(-12.5deg) skewY(-12.5deg)}33.3%{-webkit-transform:skewX(6.25deg) skewY(6.25deg);transform:skewX(6.25deg) skewY(6.25deg)}44.4%{-webkit-transform:skewX(-3.125deg) skewY(-3.125deg);transform:skewX(-3.125deg) skewY(-3.125deg)}55.5%{-webkit-transform:skewX(1.5625deg) skewY(1.5625deg);transform:skewX(1.5625deg) skewY(1.5625deg)}66.6%{-webkit-transform:skewX(-.78125deg) skewY(-.78125deg);transform:skewX(-.78125deg) skewY(-.78125deg)}77.7%{-webkit-transform:skewX(.390625deg) skewY(.390625deg);transform:skewX(.390625deg) skewY(.390625deg)}88.8%{-webkit-transform:skewX(-.1953125deg) skewY(-.1953125deg);transform:skewX(-.1953125deg) skewY(-.1953125deg)}}.animate__jello{-webkit-animation-name:jello;animation-name:jello;-webkit-transform-origin:center;transform-origin:center}@-webkit-keyframes heartBeat{0%{-webkit-transform:scale(1);transform:scale(1)}14%{-webkit-transform:scale(1.3);transform:scale(1.3)}28%{-webkit-transform:scale(1);transform:scale(1)}42%{-webkit-transform:scale(1.3);transform:scale(1.3)}70%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes heartBeat{0%{-webkit-transform:scale(1);transform:scale(1)}14%{-webkit-transform:scale(1.3);transform:scale(1.3)}28%{-webkit-transform:scale(1);transform:scale(1)}42%{-webkit-transform:scale(1.3);transform:scale(1.3)}70%{-webkit-transform:scale(1);transform:scale(1)}}.animate__heartBeat{-webkit-animation-duration:1.3s;animation-duration:1.3s;-webkit-animation-duration:calc(var(--animate-duration)*1.3);animation-duration:calc(var(--animate-duration)*1.3);-webkit-animation-name:heartBeat;animation-name:heartBeat;-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}@-webkit-keyframes backInDown{0%{opacity:.7;-webkit-transform:translateY(-1200px) scale(.7);transform:translateY(-1200px) scale(.7)}80%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes backInDown{0%{opacity:.7;-webkit-transform:translateY(-1200px) scale(.7);transform:translateY(-1200px) scale(.7)}80%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.animate__backInDown{-webkit-animation-name:backInDown;animation-name:backInDown}@-webkit-keyframes backInLeft{0%{opacity:.7;-webkit-transform:translateX(-2000px) scale(.7);transform:translateX(-2000px) scale(.7)}80%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes backInLeft{0%{opacity:.7;-webkit-transform:translateX(-2000px) scale(.7);transform:translateX(-2000px) scale(.7)}80%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.animate__backInLeft{-webkit-animation-name:backInLeft;animation-name:backInLeft}@-webkit-keyframes backInRight{0%{opacity:.7;-webkit-transform:translateX(2000px) scale(.7);transform:translateX(2000px) scale(.7)}80%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes backInRight{0%{opacity:.7;-webkit-transform:translateX(2000px) scale(.7);transform:translateX(2000px) scale(.7)}80%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.animate__backInRight{-webkit-animation-name:backInRight;animation-name:backInRight}@-webkit-keyframes backInUp{0%{opacity:.7;-webkit-transform:translateY(1200px) scale(.7);transform:translateY(1200px) scale(.7)}80%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes backInUp{0%{opacity:.7;-webkit-transform:translateY(1200px) scale(.7);transform:translateY(1200px) scale(.7)}80%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.animate__backInUp{-webkit-animation-name:backInUp;animation-name:backInUp}@-webkit-keyframes backOutDown{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:.7;-webkit-transform:translateY(700px) scale(.7);transform:translateY(700px) scale(.7)}}@keyframes backOutDown{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:.7;-webkit-transform:translateY(700px) scale(.7);transform:translateY(700px) scale(.7)}}.animate__backOutDown{-webkit-animation-name:backOutDown;animation-name:backOutDown}@-webkit-keyframes backOutLeft{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:.7;-webkit-transform:translateX(-2000px) scale(.7);transform:translateX(-2000px) scale(.7)}}@keyframes backOutLeft{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:.7;-webkit-transform:translateX(-2000px) scale(.7);transform:translateX(-2000px) scale(.7)}}.animate__backOutLeft{-webkit-animation-name:backOutLeft;animation-name:backOutLeft}@-webkit-keyframes backOutRight{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:.7;-webkit-transform:translateX(2000px) scale(.7);transform:translateX(2000px) scale(.7)}}@keyframes backOutRight{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateX(0) scale(.7);transform:translateX(0) scale(.7)}to{opacity:.7;-webkit-transform:translateX(2000px) scale(.7);transform:translateX(2000px) scale(.7)}}.animate__backOutRight{-webkit-animation-name:backOutRight;animation-name:backOutRight}@-webkit-keyframes backOutUp{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:.7;-webkit-transform:translateY(-700px) scale(.7);transform:translateY(-700px) scale(.7)}}@keyframes backOutUp{0%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}20%{opacity:.7;-webkit-transform:translateY(0) scale(.7);transform:translateY(0) scale(.7)}to{opacity:.7;-webkit-transform:translateY(-700px) scale(.7);transform:translateY(-700px) scale(.7)}}.animate__backOutUp{-webkit-animation-name:backOutUp;animation-name:backOutUp}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}20%{-webkit-transform:scale3d(1.1,1.1,1.1);transform:scale3d(1.1,1.1,1.1)}40%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}60%{opacity:1;-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}80%{-webkit-transform:scale3d(.97,.97,.97);transform:scale3d(.97,.97,.97)}to{opacity:1;-webkit-transform:scaleX(1);transform:scaleX(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}20%{-webkit-transform:scale3d(1.1,1.1,1.1);transform:scale3d(1.1,1.1,1.1)}40%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}60%{opacity:1;-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}80%{-webkit-transform:scale3d(.97,.97,.97);transform:scale3d(.97,.97,.97)}to{opacity:1;-webkit-transform:scaleX(1);transform:scaleX(1)}}.animate__bounceIn{-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-duration:calc(var(--animate-duration)*.75);animation-duration:calc(var(--animate-duration)*.75);-webkit-animation-name:bounceIn;animation-name:bounceIn}@-webkit-keyframes bounceInDown{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(0,-3000px,0) scaleY(3);transform:translate3d(0,-3000px,0) scaleY(3)}60%{opacity:1;-webkit-transform:translate3d(0,25px,0) scaleY(.9);transform:translate3d(0,25px,0) scaleY(.9)}75%{-webkit-transform:translate3d(0,-10px,0) scaleY(.95);transform:translate3d(0,-10px,0) scaleY(.95)}90%{-webkit-transform:translate3d(0,5px,0) scaleY(.985);transform:translate3d(0,5px,0) scaleY(.985)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes bounceInDown{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(0,-3000px,0) scaleY(3);transform:translate3d(0,-3000px,0) scaleY(3)}60%{opacity:1;-webkit-transform:translate3d(0,25px,0) scaleY(.9);transform:translate3d(0,25px,0) scaleY(.9)}75%{-webkit-transform:translate3d(0,-10px,0) scaleY(.95);transform:translate3d(0,-10px,0) scaleY(.95)}90%{-webkit-transform:translate3d(0,5px,0) scaleY(.985);transform:translate3d(0,5px,0) scaleY(.985)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__bounceInDown{-webkit-animation-name:bounceInDown;animation-name:bounceInDown}@-webkit-keyframes bounceInLeft{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(-3000px,0,0) scaleX(3);transform:translate3d(-3000px,0,0) scaleX(3)}60%{opacity:1;-webkit-transform:translate3d(25px,0,0) scaleX(1);transform:translate3d(25px,0,0) scaleX(1)}75%{-webkit-transform:translate3d(-10px,0,0) scaleX(.98);transform:translate3d(-10px,0,0) scaleX(.98)}90%{-webkit-transform:translate3d(5px,0,0) scaleX(.995);transform:translate3d(5px,0,0) scaleX(.995)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes bounceInLeft{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(-3000px,0,0) scaleX(3);transform:translate3d(-3000px,0,0) scaleX(3)}60%{opacity:1;-webkit-transform:translate3d(25px,0,0) scaleX(1);transform:translate3d(25px,0,0) scaleX(1)}75%{-webkit-transform:translate3d(-10px,0,0) scaleX(.98);transform:translate3d(-10px,0,0) scaleX(.98)}90%{-webkit-transform:translate3d(5px,0,0) scaleX(.995);transform:translate3d(5px,0,0) scaleX(.995)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__bounceInLeft{-webkit-animation-name:bounceInLeft;animation-name:bounceInLeft}@-webkit-keyframes bounceInRight{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(3000px,0,0) scaleX(3);transform:translate3d(3000px,0,0) scaleX(3)}60%{opacity:1;-webkit-transform:translate3d(-25px,0,0) scaleX(1);transform:translate3d(-25px,0,0) scaleX(1)}75%{-webkit-transform:translate3d(10px,0,0) scaleX(.98);transform:translate3d(10px,0,0) scaleX(.98)}90%{-webkit-transform:translate3d(-5px,0,0) scaleX(.995);transform:translate3d(-5px,0,0) scaleX(.995)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes bounceInRight{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(3000px,0,0) scaleX(3);transform:translate3d(3000px,0,0) scaleX(3)}60%{opacity:1;-webkit-transform:translate3d(-25px,0,0) scaleX(1);transform:translate3d(-25px,0,0) scaleX(1)}75%{-webkit-transform:translate3d(10px,0,0) scaleX(.98);transform:translate3d(10px,0,0) scaleX(.98)}90%{-webkit-transform:translate3d(-5px,0,0) scaleX(.995);transform:translate3d(-5px,0,0) scaleX(.995)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__bounceInRight{-webkit-animation-name:bounceInRight;animation-name:bounceInRight}@-webkit-keyframes bounceInUp{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(0,3000px,0) scaleY(5);transform:translate3d(0,3000px,0) scaleY(5)}60%{opacity:1;-webkit-transform:translate3d(0,-20px,0) scaleY(.9);transform:translate3d(0,-20px,0) scaleY(.9)}75%{-webkit-transform:translate3d(0,10px,0) scaleY(.95);transform:translate3d(0,10px,0) scaleY(.95)}90%{-webkit-transform:translate3d(0,-5px,0) scaleY(.985);transform:translate3d(0,-5px,0) scaleY(.985)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes bounceInUp{0%,60%,75%,90%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;-webkit-transform:translate3d(0,3000px,0) scaleY(5);transform:translate3d(0,3000px,0) scaleY(5)}60%{opacity:1;-webkit-transform:translate3d(0,-20px,0) scaleY(.9);transform:translate3d(0,-20px,0) scaleY(.9)}75%{-webkit-transform:translate3d(0,10px,0) scaleY(.95);transform:translate3d(0,10px,0) scaleY(.95)}90%{-webkit-transform:translate3d(0,-5px,0) scaleY(.985);transform:translate3d(0,-5px,0) scaleY(.985)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__bounceInUp{-webkit-animation-name:bounceInUp;animation-name:bounceInUp}@-webkit-keyframes bounceOut{20%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}50%,55%{opacity:1;-webkit-transform:scale3d(1.1,1.1,1.1);transform:scale3d(1.1,1.1,1.1)}to{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}}@keyframes bounceOut{20%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}50%,55%{opacity:1;-webkit-transform:scale3d(1.1,1.1,1.1);transform:scale3d(1.1,1.1,1.1)}to{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}}.animate__bounceOut{-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-duration:calc(var(--animate-duration)*.75);animation-duration:calc(var(--animate-duration)*.75);-webkit-animation-name:bounceOut;animation-name:bounceOut}@-webkit-keyframes bounceOutDown{20%{-webkit-transform:translate3d(0,10px,0) scaleY(.985);transform:translate3d(0,10px,0) scaleY(.985)}40%,45%{opacity:1;-webkit-transform:translate3d(0,-20px,0) scaleY(.9);transform:translate3d(0,-20px,0) scaleY(.9)}to{opacity:0;-webkit-transform:translate3d(0,2000px,0) scaleY(3);transform:translate3d(0,2000px,0) scaleY(3)}}@keyframes bounceOutDown{20%{-webkit-transform:translate3d(0,10px,0) scaleY(.985);transform:translate3d(0,10px,0) scaleY(.985)}40%,45%{opacity:1;-webkit-transform:translate3d(0,-20px,0) scaleY(.9);transform:translate3d(0,-20px,0) scaleY(.9)}to{opacity:0;-webkit-transform:translate3d(0,2000px,0) scaleY(3);transform:translate3d(0,2000px,0) scaleY(3)}}.animate__bounceOutDown{-webkit-animation-name:bounceOutDown;animation-name:bounceOutDown}@-webkit-keyframes bounceOutLeft{20%{opacity:1;-webkit-transform:translate3d(20px,0,0) scaleX(.9);transform:translate3d(20px,0,0) scaleX(.9)}to{opacity:0;-webkit-transform:translate3d(-2000px,0,0) scaleX(2);transform:translate3d(-2000px,0,0) scaleX(2)}}@keyframes bounceOutLeft{20%{opacity:1;-webkit-transform:translate3d(20px,0,0) scaleX(.9);transform:translate3d(20px,0,0) scaleX(.9)}to{opacity:0;-webkit-transform:translate3d(-2000px,0,0) scaleX(2);transform:translate3d(-2000px,0,0) scaleX(2)}}.animate__bounceOutLeft{-webkit-animation-name:bounceOutLeft;animation-name:bounceOutLeft}@-webkit-keyframes bounceOutRight{20%{opacity:1;-webkit-transform:translate3d(-20px,0,0) scaleX(.9);transform:translate3d(-20px,0,0) scaleX(.9)}to{opacity:0;-webkit-transform:translate3d(2000px,0,0) scaleX(2);transform:translate3d(2000px,0,0) scaleX(2)}}@keyframes bounceOutRight{20%{opacity:1;-webkit-transform:translate3d(-20px,0,0) scaleX(.9);transform:translate3d(-20px,0,0) scaleX(.9)}to{opacity:0;-webkit-transform:translate3d(2000px,0,0) scaleX(2);transform:translate3d(2000px,0,0) scaleX(2)}}.animate__bounceOutRight{-webkit-animation-name:bounceOutRight;animation-name:bounceOutRight}@-webkit-keyframes bounceOutUp{20%{-webkit-transform:translate3d(0,-10px,0) scaleY(.985);transform:translate3d(0,-10px,0) scaleY(.985)}40%,45%{opacity:1;-webkit-transform:translate3d(0,20px,0) scaleY(.9);transform:translate3d(0,20px,0) scaleY(.9)}to{opacity:0;-webkit-transform:translate3d(0,-2000px,0) scaleY(3);transform:translate3d(0,-2000px,0) scaleY(3)}}@keyframes bounceOutUp{20%{-webkit-transform:translate3d(0,-10px,0) scaleY(.985);transform:translate3d(0,-10px,0) scaleY(.985)}40%,45%{opacity:1;-webkit-transform:translate3d(0,20px,0) scaleY(.9);transform:translate3d(0,20px,0) scaleY(.9)}to{opacity:0;-webkit-transform:translate3d(0,-2000px,0) scaleY(3);transform:translate3d(0,-2000px,0) scaleY(3)}}.animate__bounceOutUp{-webkit-animation-name:bounceOutUp;animation-name:bounceOutUp}@-webkit-keyframes fadeIn{0%{opacity:0}to{opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.animate__fadeIn{-webkit-animation-name:fadeIn;animation-name:fadeIn}@-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInDown{-webkit-animation-name:fadeInDown;animation-name:fadeInDown}@-webkit-keyframes fadeInDownBig{0%{opacity:0;-webkit-transform:translate3d(0,-2000px,0);transform:translate3d(0,-2000px,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInDownBig{0%{opacity:0;-webkit-transform:translate3d(0,-2000px,0);transform:translate3d(0,-2000px,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInDownBig{-webkit-animation-name:fadeInDownBig;animation-name:fadeInDownBig}@-webkit-keyframes fadeInLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInLeft{-webkit-animation-name:fadeInLeft;animation-name:fadeInLeft}@-webkit-keyframes fadeInLeftBig{0%{opacity:0;-webkit-transform:translate3d(-2000px,0,0);transform:translate3d(-2000px,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInLeftBig{0%{opacity:0;-webkit-transform:translate3d(-2000px,0,0);transform:translate3d(-2000px,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInLeftBig{-webkit-animation-name:fadeInLeftBig;animation-name:fadeInLeftBig}@-webkit-keyframes fadeInRight{0%{opacity:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInRight{0%{opacity:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInRight{-webkit-animation-name:fadeInRight;animation-name:fadeInRight}@-webkit-keyframes fadeInRightBig{0%{opacity:0;-webkit-transform:translate3d(2000px,0,0);transform:translate3d(2000px,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInRightBig{0%{opacity:0;-webkit-transform:translate3d(2000px,0,0);transform:translate3d(2000px,0,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInRightBig{-webkit-animation-name:fadeInRightBig;animation-name:fadeInRightBig}@-webkit-keyframes fadeInUp{0%{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInUp{0%{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInUp{-webkit-animation-name:fadeInUp;animation-name:fadeInUp}@-webkit-keyframes fadeInUpBig{0%{opacity:0;-webkit-transform:translate3d(0,2000px,0);transform:translate3d(0,2000px,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInUpBig{0%{opacity:0;-webkit-transform:translate3d(0,2000px,0);transform:translate3d(0,2000px,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInUpBig{-webkit-animation-name:fadeInUpBig;animation-name:fadeInUpBig}@-webkit-keyframes fadeInTopLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,-100%,0);transform:translate3d(-100%,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInTopLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,-100%,0);transform:translate3d(-100%,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInTopLeft{-webkit-animation-name:fadeInTopLeft;animation-name:fadeInTopLeft}@-webkit-keyframes fadeInTopRight{0%{opacity:0;-webkit-transform:translate3d(100%,-100%,0);transform:translate3d(100%,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInTopRight{0%{opacity:0;-webkit-transform:translate3d(100%,-100%,0);transform:translate3d(100%,-100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInTopRight{-webkit-animation-name:fadeInTopRight;animation-name:fadeInTopRight}@-webkit-keyframes fadeInBottomLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,100%,0);transform:translate3d(-100%,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInBottomLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,100%,0);transform:translate3d(-100%,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInBottomLeft{-webkit-animation-name:fadeInBottomLeft;animation-name:fadeInBottomLeft}@-webkit-keyframes fadeInBottomRight{0%{opacity:0;-webkit-transform:translate3d(100%,100%,0);transform:translate3d(100%,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes fadeInBottomRight{0%{opacity:0;-webkit-transform:translate3d(100%,100%,0);transform:translate3d(100%,100%,0)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__fadeInBottomRight{-webkit-animation-name:fadeInBottomRight;animation-name:fadeInBottomRight}@-webkit-keyframes fadeOut{0%{opacity:1}to{opacity:0}}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}.animate__fadeOut{-webkit-animation-name:fadeOut;animation-name:fadeOut}@-webkit-keyframes fadeOutDown{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}}@keyframes fadeOutDown{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0)}}.animate__fadeOutDown{-webkit-animation-name:fadeOutDown;animation-name:fadeOutDown}@-webkit-keyframes fadeOutDownBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,2000px,0);transform:translate3d(0,2000px,0)}}@keyframes fadeOutDownBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,2000px,0);transform:translate3d(0,2000px,0)}}.animate__fadeOutDownBig{-webkit-animation-name:fadeOutDownBig;animation-name:fadeOutDownBig}@-webkit-keyframes fadeOutLeft{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}}@keyframes fadeOutLeft{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}}.animate__fadeOutLeft{-webkit-animation-name:fadeOutLeft;animation-name:fadeOutLeft}@-webkit-keyframes fadeOutLeftBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-2000px,0,0);transform:translate3d(-2000px,0,0)}}@keyframes fadeOutLeftBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-2000px,0,0);transform:translate3d(-2000px,0,0)}}.animate__fadeOutLeftBig{-webkit-animation-name:fadeOutLeftBig;animation-name:fadeOutLeftBig}@-webkit-keyframes fadeOutRight{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}}@keyframes fadeOutRight{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}}.animate__fadeOutRight{-webkit-animation-name:fadeOutRight;animation-name:fadeOutRight}@-webkit-keyframes fadeOutRightBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(2000px,0,0);transform:translate3d(2000px,0,0)}}@keyframes fadeOutRightBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(2000px,0,0);transform:translate3d(2000px,0,0)}}.animate__fadeOutRightBig{-webkit-animation-name:fadeOutRightBig;animation-name:fadeOutRightBig}@-webkit-keyframes fadeOutUp{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}}@keyframes fadeOutUp{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}}.animate__fadeOutUp{-webkit-animation-name:fadeOutUp;animation-name:fadeOutUp}@-webkit-keyframes fadeOutUpBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,-2000px,0);transform:translate3d(0,-2000px,0)}}@keyframes fadeOutUpBig{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(0,-2000px,0);transform:translate3d(0,-2000px,0)}}.animate__fadeOutUpBig{-webkit-animation-name:fadeOutUpBig;animation-name:fadeOutUpBig}@-webkit-keyframes fadeOutTopLeft{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(-100%,-100%,0);transform:translate3d(-100%,-100%,0)}}@keyframes fadeOutTopLeft{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(-100%,-100%,0);transform:translate3d(-100%,-100%,0)}}.animate__fadeOutTopLeft{-webkit-animation-name:fadeOutTopLeft;animation-name:fadeOutTopLeft}@-webkit-keyframes fadeOutTopRight{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(100%,-100%,0);transform:translate3d(100%,-100%,0)}}@keyframes fadeOutTopRight{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(100%,-100%,0);transform:translate3d(100%,-100%,0)}}.animate__fadeOutTopRight{-webkit-animation-name:fadeOutTopRight;animation-name:fadeOutTopRight}@-webkit-keyframes fadeOutBottomRight{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(100%,100%,0);transform:translate3d(100%,100%,0)}}@keyframes fadeOutBottomRight{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(100%,100%,0);transform:translate3d(100%,100%,0)}}.animate__fadeOutBottomRight{-webkit-animation-name:fadeOutBottomRight;animation-name:fadeOutBottomRight}@-webkit-keyframes fadeOutBottomLeft{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(-100%,100%,0);transform:translate3d(-100%,100%,0)}}@keyframes fadeOutBottomLeft{0%{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}to{opacity:0;-webkit-transform:translate3d(-100%,100%,0);transform:translate3d(-100%,100%,0)}}.animate__fadeOutBottomLeft{-webkit-animation-name:fadeOutBottomLeft;animation-name:fadeOutBottomLeft}@-webkit-keyframes flip{0%{-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out;-webkit-transform:perspective(400px) scaleX(1) translateZ(0) rotateY(-1turn);transform:perspective(400px) scaleX(1) translateZ(0) rotateY(-1turn)}40%{-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out;-webkit-transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-190deg);transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-190deg)}50%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-170deg);transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-170deg)}80%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scale3d(.95,.95,.95) translateZ(0) rotateY(0deg);transform:perspective(400px) scale3d(.95,.95,.95) translateZ(0) rotateY(0deg)}to{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scaleX(1) translateZ(0) rotateY(0deg);transform:perspective(400px) scaleX(1) translateZ(0) rotateY(0deg)}}@keyframes flip{0%{-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out;-webkit-transform:perspective(400px) scaleX(1) translateZ(0) rotateY(-1turn);transform:perspective(400px) scaleX(1) translateZ(0) rotateY(-1turn)}40%{-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out;-webkit-transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-190deg);transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-190deg)}50%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-170deg);transform:perspective(400px) scaleX(1) translateZ(150px) rotateY(-170deg)}80%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scale3d(.95,.95,.95) translateZ(0) rotateY(0deg);transform:perspective(400px) scale3d(.95,.95,.95) translateZ(0) rotateY(0deg)}to{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) scaleX(1) translateZ(0) rotateY(0deg);transform:perspective(400px) scaleX(1) translateZ(0) rotateY(0deg)}}.animate__animated.animate__flip{-webkit-animation-name:flip;animation-name:flip;-webkit-backface-visibility:visible;backface-visibility:visible}@-webkit-keyframes flipInX{0%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;opacity:0;-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg)}40%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) rotateX(-20deg);transform:perspective(400px) rotateX(-20deg)}60%{opacity:1;-webkit-transform:perspective(400px) rotateX(10deg);transform:perspective(400px) rotateX(10deg)}80%{-webkit-transform:perspective(400px) rotateX(-5deg);transform:perspective(400px) rotateX(-5deg)}to{-webkit-transform:perspective(400px);transform:perspective(400px)}}@keyframes flipInX{0%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;opacity:0;-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg)}40%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) rotateX(-20deg);transform:perspective(400px) rotateX(-20deg)}60%{opacity:1;-webkit-transform:perspective(400px) rotateX(10deg);transform:perspective(400px) rotateX(10deg)}80%{-webkit-transform:perspective(400px) rotateX(-5deg);transform:perspective(400px) rotateX(-5deg)}to{-webkit-transform:perspective(400px);transform:perspective(400px)}}.animate__flipInX{-webkit-animation-name:flipInX;animation-name:flipInX;-webkit-backface-visibility:visible!important;backface-visibility:visible!important}@-webkit-keyframes flipInY{0%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;opacity:0;-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg)}40%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) rotateY(-20deg);transform:perspective(400px) rotateY(-20deg)}60%{opacity:1;-webkit-transform:perspective(400px) rotateY(10deg);transform:perspective(400px) rotateY(10deg)}80%{-webkit-transform:perspective(400px) rotateY(-5deg);transform:perspective(400px) rotateY(-5deg)}to{-webkit-transform:perspective(400px);transform:perspective(400px)}}@keyframes flipInY{0%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;opacity:0;-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg)}40%{-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in;-webkit-transform:perspective(400px) rotateY(-20deg);transform:perspective(400px) rotateY(-20deg)}60%{opacity:1;-webkit-transform:perspective(400px) rotateY(10deg);transform:perspective(400px) rotateY(10deg)}80%{-webkit-transform:perspective(400px) rotateY(-5deg);transform:perspective(400px) rotateY(-5deg)}to{-webkit-transform:perspective(400px);transform:perspective(400px)}}.animate__flipInY{-webkit-animation-name:flipInY;animation-name:flipInY;-webkit-backface-visibility:visible!important;backface-visibility:visible!important}@-webkit-keyframes flipOutX{0%{-webkit-transform:perspective(400px);transform:perspective(400px)}30%{opacity:1;-webkit-transform:perspective(400px) rotateX(-20deg);transform:perspective(400px) rotateX(-20deg)}to{opacity:0;-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg)}}@keyframes flipOutX{0%{-webkit-transform:perspective(400px);transform:perspective(400px)}30%{opacity:1;-webkit-transform:perspective(400px) rotateX(-20deg);transform:perspective(400px) rotateX(-20deg)}to{opacity:0;-webkit-transform:perspective(400px) rotateX(90deg);transform:perspective(400px) rotateX(90deg)}}.animate__flipOutX{-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-duration:calc(var(--animate-duration)*.75);animation-duration:calc(var(--animate-duration)*.75);-webkit-animation-name:flipOutX;animation-name:flipOutX;-webkit-backface-visibility:visible!important;backface-visibility:visible!important}@-webkit-keyframes flipOutY{0%{-webkit-transform:perspective(400px);transform:perspective(400px)}30%{opacity:1;-webkit-transform:perspective(400px) rotateY(-15deg);transform:perspective(400px) rotateY(-15deg)}to{opacity:0;-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg)}}@keyframes flipOutY{0%{-webkit-transform:perspective(400px);transform:perspective(400px)}30%{opacity:1;-webkit-transform:perspective(400px) rotateY(-15deg);transform:perspective(400px) rotateY(-15deg)}to{opacity:0;-webkit-transform:perspective(400px) rotateY(90deg);transform:perspective(400px) rotateY(90deg)}}.animate__flipOutY{-webkit-animation-duration:.75s;animation-duration:.75s;-webkit-animation-duration:calc(var(--animate-duration)*.75);animation-duration:calc(var(--animate-duration)*.75);-webkit-animation-name:flipOutY;animation-name:flipOutY;-webkit-backface-visibility:visible!important;backface-visibility:visible!important}@-webkit-keyframes lightSpeedInRight{0%{opacity:0;-webkit-transform:translate3d(100%,0,0) skewX(-30deg);transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;-webkit-transform:skewX(20deg);transform:skewX(20deg)}80%{-webkit-transform:skewX(-5deg);transform:skewX(-5deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes lightSpeedInRight{0%{opacity:0;-webkit-transform:translate3d(100%,0,0) skewX(-30deg);transform:translate3d(100%,0,0) skewX(-30deg)}60%{opacity:1;-webkit-transform:skewX(20deg);transform:skewX(20deg)}80%{-webkit-transform:skewX(-5deg);transform:skewX(-5deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__lightSpeedInRight{-webkit-animation-name:lightSpeedInRight;animation-name:lightSpeedInRight;-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}@-webkit-keyframes lightSpeedInLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0) skewX(30deg);transform:translate3d(-100%,0,0) skewX(30deg)}60%{opacity:1;-webkit-transform:skewX(-20deg);transform:skewX(-20deg)}80%{-webkit-transform:skewX(5deg);transform:skewX(5deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes lightSpeedInLeft{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0) skewX(30deg);transform:translate3d(-100%,0,0) skewX(30deg)}60%{opacity:1;-webkit-transform:skewX(-20deg);transform:skewX(-20deg)}80%{-webkit-transform:skewX(5deg);transform:skewX(5deg)}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__lightSpeedInLeft{-webkit-animation-name:lightSpeedInLeft;animation-name:lightSpeedInLeft;-webkit-animation-timing-function:ease-out;animation-timing-function:ease-out}@-webkit-keyframes lightSpeedOutRight{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0) skewX(30deg);transform:translate3d(100%,0,0) skewX(30deg)}}@keyframes lightSpeedOutRight{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0) skewX(30deg);transform:translate3d(100%,0,0) skewX(30deg)}}.animate__lightSpeedOutRight{-webkit-animation-name:lightSpeedOutRight;animation-name:lightSpeedOutRight;-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}@-webkit-keyframes lightSpeedOutLeft{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-100%,0,0) skewX(-30deg);transform:translate3d(-100%,0,0) skewX(-30deg)}}@keyframes lightSpeedOutLeft{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(-100%,0,0) skewX(-30deg);transform:translate3d(-100%,0,0) skewX(-30deg)}}.animate__lightSpeedOutLeft{-webkit-animation-name:lightSpeedOutLeft;animation-name:lightSpeedOutLeft;-webkit-animation-timing-function:ease-in;animation-timing-function:ease-in}@-webkit-keyframes rotateIn{0%{opacity:0;-webkit-transform:rotate(-200deg);transform:rotate(-200deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rotateIn{0%{opacity:0;-webkit-transform:rotate(-200deg);transform:rotate(-200deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rotateIn{-webkit-animation-name:rotateIn;animation-name:rotateIn;-webkit-transform-origin:center;transform-origin:center}@-webkit-keyframes rotateInDownLeft{0%{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rotateInDownLeft{0%{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rotateInDownLeft{-webkit-animation-name:rotateInDownLeft;animation-name:rotateInDownLeft;-webkit-transform-origin:left bottom;transform-origin:left bottom}@-webkit-keyframes rotateInDownRight{0%{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rotateInDownRight{0%{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rotateInDownRight{-webkit-animation-name:rotateInDownRight;animation-name:rotateInDownRight;-webkit-transform-origin:right bottom;transform-origin:right bottom}@-webkit-keyframes rotateInUpLeft{0%{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rotateInUpLeft{0%{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rotateInUpLeft{-webkit-animation-name:rotateInUpLeft;animation-name:rotateInUpLeft;-webkit-transform-origin:left bottom;transform-origin:left bottom}@-webkit-keyframes rotateInUpRight{0%{opacity:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rotateInUpRight{0%{opacity:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rotateInUpRight{-webkit-animation-name:rotateInUpRight;animation-name:rotateInUpRight;-webkit-transform-origin:right bottom;transform-origin:right bottom}@-webkit-keyframes rotateOut{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(200deg);transform:rotate(200deg)}}@keyframes rotateOut{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(200deg);transform:rotate(200deg)}}.animate__rotateOut{-webkit-animation-name:rotateOut;animation-name:rotateOut;-webkit-transform-origin:center;transform-origin:center}@-webkit-keyframes rotateOutDownLeft{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}}@keyframes rotateOutDownLeft{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(45deg);transform:rotate(45deg)}}.animate__rotateOutDownLeft{-webkit-animation-name:rotateOutDownLeft;animation-name:rotateOutDownLeft;-webkit-transform-origin:left bottom;transform-origin:left bottom}@-webkit-keyframes rotateOutDownRight{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}}@keyframes rotateOutDownRight{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}}.animate__rotateOutDownRight{-webkit-animation-name:rotateOutDownRight;animation-name:rotateOutDownRight;-webkit-transform-origin:right bottom;transform-origin:right bottom}@-webkit-keyframes rotateOutUpLeft{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}}@keyframes rotateOutUpLeft{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}}.animate__rotateOutUpLeft{-webkit-animation-name:rotateOutUpLeft;animation-name:rotateOutUpLeft;-webkit-transform-origin:left bottom;transform-origin:left bottom}@-webkit-keyframes rotateOutUpRight{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}}@keyframes rotateOutUpRight{0%{opacity:1}to{opacity:0;-webkit-transform:rotate(90deg);transform:rotate(90deg)}}.animate__rotateOutUpRight{-webkit-animation-name:rotateOutUpRight;animation-name:rotateOutUpRight;-webkit-transform-origin:right bottom;transform-origin:right bottom}@-webkit-keyframes hinge{0%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}20%,60%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-transform:rotate(80deg);transform:rotate(80deg)}40%,80%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;opacity:1;-webkit-transform:rotate(60deg);transform:rotate(60deg)}to{opacity:0;-webkit-transform:translate3d(0,700px,0);transform:translate3d(0,700px,0)}}@keyframes hinge{0%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out}20%,60%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;-webkit-transform:rotate(80deg);transform:rotate(80deg)}40%,80%{-webkit-animation-timing-function:ease-in-out;animation-timing-function:ease-in-out;opacity:1;-webkit-transform:rotate(60deg);transform:rotate(60deg)}to{opacity:0;-webkit-transform:translate3d(0,700px,0);transform:translate3d(0,700px,0)}}.animate__hinge{-webkit-animation-duration:2s;animation-duration:2s;-webkit-animation-duration:calc(var(--animate-duration)*2);animation-duration:calc(var(--animate-duration)*2);-webkit-animation-name:hinge;animation-name:hinge;-webkit-transform-origin:top left;transform-origin:top left}@-webkit-keyframes jackInTheBox{0%{opacity:0;-webkit-transform:scale(.1) rotate(30deg);transform:scale(.1) rotate(30deg);-webkit-transform-origin:center bottom;transform-origin:center bottom}50%{-webkit-transform:rotate(-10deg);transform:rotate(-10deg)}70%{-webkit-transform:rotate(3deg);transform:rotate(3deg)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes jackInTheBox{0%{opacity:0;-webkit-transform:scale(.1) rotate(30deg);transform:scale(.1) rotate(30deg);-webkit-transform-origin:center bottom;transform-origin:center bottom}50%{-webkit-transform:rotate(-10deg);transform:rotate(-10deg)}70%{-webkit-transform:rotate(3deg);transform:rotate(3deg)}to{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.animate__jackInTheBox{-webkit-animation-name:jackInTheBox;animation-name:jackInTheBox}@-webkit-keyframes rollIn{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0) rotate(-120deg);transform:translate3d(-100%,0,0) rotate(-120deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes rollIn{0%{opacity:0;-webkit-transform:translate3d(-100%,0,0) rotate(-120deg);transform:translate3d(-100%,0,0) rotate(-120deg)}to{opacity:1;-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__rollIn{-webkit-animation-name:rollIn;animation-name:rollIn}@-webkit-keyframes rollOut{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0) rotate(120deg);transform:translate3d(100%,0,0) rotate(120deg)}}@keyframes rollOut{0%{opacity:1}to{opacity:0;-webkit-transform:translate3d(100%,0,0) rotate(120deg);transform:translate3d(100%,0,0) rotate(120deg)}}.animate__rollOut{-webkit-animation-name:rollOut;animation-name:rollOut}@-webkit-keyframes zoomIn{0%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}50%{opacity:1}}@keyframes zoomIn{0%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}50%{opacity:1}}.animate__zoomIn{-webkit-animation-name:zoomIn;animation-name:zoomIn}@-webkit-keyframes zoomInDown{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,-1000px,0);transform:scale3d(.1,.1,.1) translate3d(0,-1000px,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,60px,0);transform:scale3d(.475,.475,.475) translate3d(0,60px,0)}}@keyframes zoomInDown{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,-1000px,0);transform:scale3d(.1,.1,.1) translate3d(0,-1000px,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,60px,0);transform:scale3d(.475,.475,.475) translate3d(0,60px,0)}}.animate__zoomInDown{-webkit-animation-name:zoomInDown;animation-name:zoomInDown}@-webkit-keyframes zoomInLeft{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(-1000px,0,0);transform:scale3d(.1,.1,.1) translate3d(-1000px,0,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(10px,0,0);transform:scale3d(.475,.475,.475) translate3d(10px,0,0)}}@keyframes zoomInLeft{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(-1000px,0,0);transform:scale3d(.1,.1,.1) translate3d(-1000px,0,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(10px,0,0);transform:scale3d(.475,.475,.475) translate3d(10px,0,0)}}.animate__zoomInLeft{-webkit-animation-name:zoomInLeft;animation-name:zoomInLeft}@-webkit-keyframes zoomInRight{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(1000px,0,0);transform:scale3d(.1,.1,.1) translate3d(1000px,0,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(-10px,0,0);transform:scale3d(.475,.475,.475) translate3d(-10px,0,0)}}@keyframes zoomInRight{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(1000px,0,0);transform:scale3d(.1,.1,.1) translate3d(1000px,0,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(-10px,0,0);transform:scale3d(.475,.475,.475) translate3d(-10px,0,0)}}.animate__zoomInRight{-webkit-animation-name:zoomInRight;animation-name:zoomInRight}@-webkit-keyframes zoomInUp{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,1000px,0);transform:scale3d(.1,.1,.1) translate3d(0,1000px,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,-60px,0);transform:scale3d(.475,.475,.475) translate3d(0,-60px,0)}}@keyframes zoomInUp{0%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,1000px,0);transform:scale3d(.1,.1,.1) translate3d(0,1000px,0)}60%{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,-60px,0);transform:scale3d(.475,.475,.475) translate3d(0,-60px,0)}}.animate__zoomInUp{-webkit-animation-name:zoomInUp;animation-name:zoomInUp}@-webkit-keyframes zoomOut{0%{opacity:1}50%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}to{opacity:0}}@keyframes zoomOut{0%{opacity:1}50%{opacity:0;-webkit-transform:scale3d(.3,.3,.3);transform:scale3d(.3,.3,.3)}to{opacity:0}}.animate__zoomOut{-webkit-animation-name:zoomOut;animation-name:zoomOut}@-webkit-keyframes zoomOutDown{40%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,-60px,0);transform:scale3d(.475,.475,.475) translate3d(0,-60px,0)}to{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,2000px,0);transform:scale3d(.1,.1,.1) translate3d(0,2000px,0)}}@keyframes zoomOutDown{40%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,-60px,0);transform:scale3d(.475,.475,.475) translate3d(0,-60px,0)}to{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,2000px,0);transform:scale3d(.1,.1,.1) translate3d(0,2000px,0)}}.animate__zoomOutDown{-webkit-animation-name:zoomOutDown;animation-name:zoomOutDown;-webkit-transform-origin:center bottom;transform-origin:center bottom}@-webkit-keyframes zoomOutLeft{40%{opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(42px,0,0);transform:scale3d(.475,.475,.475) translate3d(42px,0,0)}to{opacity:0;-webkit-transform:scale(.1) translate3d(-2000px,0,0);transform:scale(.1) translate3d(-2000px,0,0)}}@keyframes zoomOutLeft{40%{opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(42px,0,0);transform:scale3d(.475,.475,.475) translate3d(42px,0,0)}to{opacity:0;-webkit-transform:scale(.1) translate3d(-2000px,0,0);transform:scale(.1) translate3d(-2000px,0,0)}}.animate__zoomOutLeft{-webkit-animation-name:zoomOutLeft;animation-name:zoomOutLeft;-webkit-transform-origin:left center;transform-origin:left center}@-webkit-keyframes zoomOutRight{40%{opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(-42px,0,0);transform:scale3d(.475,.475,.475) translate3d(-42px,0,0)}to{opacity:0;-webkit-transform:scale(.1) translate3d(2000px,0,0);transform:scale(.1) translate3d(2000px,0,0)}}@keyframes zoomOutRight{40%{opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(-42px,0,0);transform:scale3d(.475,.475,.475) translate3d(-42px,0,0)}to{opacity:0;-webkit-transform:scale(.1) translate3d(2000px,0,0);transform:scale(.1) translate3d(2000px,0,0)}}.animate__zoomOutRight{-webkit-animation-name:zoomOutRight;animation-name:zoomOutRight;-webkit-transform-origin:right center;transform-origin:right center}@-webkit-keyframes zoomOutUp{40%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,60px,0);transform:scale3d(.475,.475,.475) translate3d(0,60px,0)}to{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,-2000px,0);transform:scale3d(.1,.1,.1) translate3d(0,-2000px,0)}}@keyframes zoomOutUp{40%{-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19);opacity:1;-webkit-transform:scale3d(.475,.475,.475) translate3d(0,60px,0);transform:scale3d(.475,.475,.475) translate3d(0,60px,0)}to{-webkit-animation-timing-function:cubic-bezier(.175,.885,.32,1);animation-timing-function:cubic-bezier(.175,.885,.32,1);opacity:0;-webkit-transform:scale3d(.1,.1,.1) translate3d(0,-2000px,0);transform:scale3d(.1,.1,.1) translate3d(0,-2000px,0)}}.animate__zoomOutUp{-webkit-animation-name:zoomOutUp;animation-name:zoomOutUp;-webkit-transform-origin:center bottom;transform-origin:center bottom}@-webkit-keyframes slideInDown{0%{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes slideInDown{0%{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__slideInDown{-webkit-animation-name:slideInDown;animation-name:slideInDown}@-webkit-keyframes slideInLeft{0%{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes slideInLeft{0%{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__slideInLeft{-webkit-animation-name:slideInLeft;animation-name:slideInLeft}@-webkit-keyframes slideInRight{0%{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes slideInRight{0%{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__slideInRight{-webkit-animation-name:slideInRight;animation-name:slideInRight}@-webkit-keyframes slideInUp{0%{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}@keyframes slideInUp{0%{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);visibility:visible}to{-webkit-transform:translateZ(0);transform:translateZ(0)}}.animate__slideInUp{-webkit-animation-name:slideInUp;animation-name:slideInUp}@-webkit-keyframes slideOutDown{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);visibility:hidden}}@keyframes slideOutDown{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(0,100%,0);transform:translate3d(0,100%,0);visibility:hidden}}.animate__slideOutDown{-webkit-animation-name:slideOutDown;animation-name:slideOutDown}@-webkit-keyframes slideOutLeft{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);visibility:hidden}}@keyframes slideOutLeft{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0);visibility:hidden}}.animate__slideOutLeft{-webkit-animation-name:slideOutLeft;animation-name:slideOutLeft}@-webkit-keyframes slideOutRight{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0);visibility:hidden}}@keyframes slideOutRight{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0);visibility:hidden}}.animate__slideOutRight{-webkit-animation-name:slideOutRight;animation-name:slideOutRight}@-webkit-keyframes slideOutUp{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0);visibility:hidden}}@keyframes slideOutUp{0%{-webkit-transform:translateZ(0);transform:translateZ(0)}to{-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0);visibility:hidden}}.animate__slideOutUp{-webkit-animation-name:slideOutUp;animation-name:slideOutUp}.backDown-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backInDown}.backDown-enter-active,.backDown-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.backDown-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backOutDown}.backLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backInLeft}.backLeft-enter-active,.backLeft-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.backLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backOutLeft}.backRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backInRight}.backRight-enter-active,.backRight-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.backRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backOutRight}.backUp-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backInUp}.backUp-enter-active,.backUp-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.backUp-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:backOutUp}.bounce-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceIn}.bounce-enter-active,.bounce-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.bounce-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceOut}.bounceDown-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceInDown}.bounceDown-enter-active,.bounceDown-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.bounceDown-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceOutDown}.bounceLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceInLeft}.bounceLeft-enter-active,.bounceLeft-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.bounceLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceOutLeft}.bounceRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceInRight}.bounceRight-enter-active,.bounceRight-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.bounceRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceOutRight}.bounceUp-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceInUp}.bounceUp-enter-active,.bounceUp-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.bounceUp-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:bounceOutUp}.fade-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeIn}.fade-enter-active,.fade-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fade-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOut}.fadeBottomLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInBottomLeft}.fadeBottomLeft-enter-active,.fadeBottomLeft-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeBottomLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutBottomLeft}.fadeBottomRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInBottomRight}.fadeBottomRight-enter-active,.fadeBottomRight-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeBottomRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutBottomRight}.fadeDown-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInDown}.fadeDown-enter-active,.fadeDown-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeDown-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutDown}.fadeDownBig-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInDownBig}.fadeDownBig-enter-active,.fadeDownBig-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeDownBig-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutDownBig}.fadeLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInLeft}.fadeLeft-enter-active,.fadeLeft-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutLeft}.fadeLeftBig-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInLeftBig}.fadeLeftBig-enter-active,.fadeLeftBig-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeLeftBig-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutLeftBig}.fadeRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInRight}.fadeRight-enter-active,.fadeRight-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutRight}.fadeRightBig-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInRightBig}.fadeRightBig-enter-active,.fadeRightBig-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeRightBig-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutRightBig}.fadeTopLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInTopLeft}.fadeTopLeft-enter-active,.fadeTopLeft-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeTopLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutTopLeft}.fadeTopRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInTopRight}.fadeTopRight-enter-active,.fadeTopRight-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeTopRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutTopRight}.fadeUp-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInUp}.fadeUp-enter-active,.fadeUp-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeUp-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutUp}.fadeUpBig-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeInUpBig}.fadeUpBig-enter-active,.fadeUpBig-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.fadeUpBig-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:fadeOutUpBig}.flip-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:flip}.flip-leave-active,.flipX-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.flipX-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:flipInX}.flipX-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:flipOutX}.flipX-leave-active,.flipY-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.flipY-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:flipInY}.flipY-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:flipOutY}.flipY-leave-active,.lightSpeedLeft-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.lightSpeedLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:lightSpeedInLeft}.lightSpeedLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:lightSpeedOutLeft}.lightSpeedLeft-leave-active,.lightSpeedRight-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.lightSpeedRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:lightSpeedInRight}.lightSpeedRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:lightSpeedOutRight}.lightSpeedRight-leave-active,.rotate-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.rotate-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateIn}.rotate-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateOut}.rotate-leave-active,.rotateDownLeft-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.rotateDownLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateInDownLeft}.rotateDownLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateOutDownLeft}.rotateDownLeft-leave-active,.rotateDownRight-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.rotateDownRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateInDownRight}.rotateDownRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateOutDownRight}.rotateDownRight-leave-active,.rotateUpLeft-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.rotateUpLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateInUpLeft}.rotateUpLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateOutUpLeft}.rotateUpLeft-leave-active,.rotateUpRight-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.rotateUpRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateInUpRight}.rotateUpRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rotateOutUpRight}.rotateUpRight-leave-active,.slideDown-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.slideDown-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideInDown}.slideDown-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideOutDown}.slideDown-leave-active,.slideLeft-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.slideLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideInLeft}.slideLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideOutLeft}.slideLeft-leave-active,.slideRight-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.slideRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideInRight}.slideRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideOutRight}.slideRight-leave-active,.slideUp-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.slideUp-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideInUp}.slideUp-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:slideOutUp}.roll-enter-active,.slideUp-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.roll-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rollIn}.roll-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:rollOut}.roll-leave-active,.zoom-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.zoom-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomIn}.zoom-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomOut}.zoom-leave-active,.zoomDown-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.zoomDown-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomInDown}.zoomDown-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomOutDown}.zoomDown-leave-active,.zoomLeft-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.zoomLeft-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomInLeft}.zoomLeft-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomOutLeft}.zoomLeft-leave-active,.zoomRight-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.zoomRight-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomInRight}.zoomRight-leave-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomOutRight}.zoomRight-leave-active,.zoomUp-enter-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration)}.zoomUp-enter-active{animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomInUp}.zoomUp-leave-active{animation-delay:var(--animate-delay);animation-duration:var(--animate-duration);animation-fill-mode:both;animation-iteration-count:var(--animate-repeat);animation-name:zoomOutUp}/*$vite$:1*/";
            document.head.appendChild(__vite_style__);
            exports({
                a: ref,
                b: openBlock,
                c: createElementBlock,
                d: createBaseVNode,
                e: renderList,
                f: resolveComponent,
                h: createCommentVNode,
                i: createTextVNode,
                k: createBlock,
                l: withCtx,
                n: normalizeClass,
                p: withAsyncContext,
                q: renderSlot,
                r: reactive,
                s: mergeProps,
                u: unref,
                v: watch,
                x: toRefs,
                z: useRoute
            });
            const scriptRel = "modulepreload";
            const assetsURL = function(dep) {
                return window.externalPublicPath + dep;
            };
            const seen = {};
            const __vitePreload = function preload(baseModule, deps, importerUrl) {
                let promise = Promise.resolve();
                if (false) {
                    let allSettled = function(promises$2) {
                        return Promise.all(promises$2.map((p2)=>Promise.resolve(p2).then((value$1)=>({
                                    status: "fulfilled",
                                    value: value$1
                                }), (reason)=>({
                                    status: "rejected",
                                    reason
                                }))));
                    };
                    document.getElementsByTagName("link");
                    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
                    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
                    promise = allSettled(deps.map((dep)=>{
                        dep = assetsURL(dep);
                        if (dep in seen) return;
                        seen[dep] = true;
                        const isCss = dep.endsWith(".css");
                        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
                        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
                        const link = document.createElement("link");
                        link.rel = isCss ? "stylesheet" : scriptRel;
                        if (!isCss) link.as = "script";
                        link.crossOrigin = "";
                        link.href = dep;
                        if (cspNonce) link.setAttribute("nonce", cspNonce);
                        document.head.appendChild(link);
                        if (isCss) return new Promise((res, rej)=>{
                            link.addEventListener("load", res);
                            link.addEventListener("error", ()=>rej(new Error(`Unable to preload CSS for ${dep}`)));
                        });
                    }));
                }
                function handlePreloadError(err$2) {
                    const e$1 = new Event("vite:preloadError", {
                        cancelable: true
                    });
                    e$1.payload = err$2;
                    window.dispatchEvent(e$1);
                    if (!e$1.defaultPrevented) throw err$2;
                }
                return promise.then((res)=>{
                    for (const item of res || []){
                        if (item.status !== "rejected") continue;
                        handlePreloadError(item.reason);
                    }
                    return baseModule().catch(handlePreloadError);
                });
            };
            function makeMap(str) {
                const map = Object.create(null);
                for (const key of str.split(","))map[key] = 1;
                return (val)=>val in map;
            }
            const EMPTY_OBJ = {};
            const EMPTY_ARR = [];
            const NOOP = ()=>{};
            const NO = ()=>false;
            const isOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
            const isModelListener = (key)=>key.startsWith("onUpdate:");
            const extend$1 = Object.assign;
            const remove = (arr, el)=>{
                const i = arr.indexOf(el);
                if (i > -1) {
                    arr.splice(i, 1);
                }
            };
            const hasOwnProperty$2 = Object.prototype.hasOwnProperty;
            const hasOwn = (val, key)=>hasOwnProperty$2.call(val, key);
            const isArray$2 = Array.isArray;
            const isMap = (val)=>toTypeString(val) === "[object Map]";
            const isSet = (val)=>toTypeString(val) === "[object Set]";
            const isFunction$2 = (val)=>typeof val === "function";
            const isString$1 = (val)=>typeof val === "string";
            const isSymbol = (val)=>typeof val === "symbol";
            const isObject$1 = (val)=>val !== null && typeof val === "object";
            const isPromise = (val)=>{
                return (isObject$1(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
            };
            const objectToString = Object.prototype.toString;
            const toTypeString = (value)=>objectToString.call(value);
            const toRawType = (value)=>{
                return toTypeString(value).slice(8, -1);
            };
            const isPlainObject$1 = (val)=>toTypeString(val) === "[object Object]";
            const isIntegerKey = (key)=>isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
            const isReservedProp = makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
            const cacheStringFunction = (fn)=>{
                const cache = Object.create(null);
                return ((str)=>{
                    const hit = cache[str];
                    return hit || (cache[str] = fn(str));
                });
            };
            const camelizeRE = /-\w/g;
            const camelize = cacheStringFunction((str)=>{
                return str.replace(camelizeRE, (c)=>c.slice(1).toUpperCase());
            });
            const hyphenateRE = /\B([A-Z])/g;
            const hyphenate = cacheStringFunction((str)=>str.replace(hyphenateRE, "-$1").toLowerCase());
            const capitalize = cacheStringFunction((str)=>{
                return str.charAt(0).toUpperCase() + str.slice(1);
            });
            const toHandlerKey = cacheStringFunction((str)=>{
                const s2 = str ? `on${capitalize(str)}` : ``;
                return s2;
            });
            const hasChanged = (value, oldValue)=>!Object.is(value, oldValue);
            const invokeArrayFns = (fns, ...arg)=>{
                for(let i = 0; i < fns.length; i++){
                    fns[i](...arg);
                }
            };
            const def = (obj, key, value, writable = false)=>{
                Object.defineProperty(obj, key, {
                    configurable: true,
                    enumerable: false,
                    writable,
                    value
                });
            };
            const looseToNumber = (val)=>{
                const n = parseFloat(val);
                return isNaN(n) ? val : n;
            };
            const toNumber = (val)=>{
                const n = isString$1(val) ? Number(val) : NaN;
                return isNaN(n) ? val : n;
            };
            let _globalThis;
            const getGlobalThis = ()=>{
                return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
            };
            function normalizeStyle(value) {
                if (isArray$2(value)) {
                    const res = {};
                    for(let i = 0; i < value.length; i++){
                        const item = value[i];
                        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
                        if (normalized) {
                            for(const key in normalized){
                                res[key] = normalized[key];
                            }
                        }
                    }
                    return res;
                } else if (isString$1(value) || isObject$1(value)) {
                    return value;
                }
            }
            const listDelimiterRE = /;(?![^(]*\))/g;
            const propertyDelimiterRE = /:([^]+)/;
            const styleCommentRE = /\/\*[^]*?\*\//g;
            function parseStringStyle(cssText) {
                const ret = {};
                cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item)=>{
                    if (item) {
                        const tmp = item.split(propertyDelimiterRE);
                        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
                    }
                });
                return ret;
            }
            function normalizeClass(value) {
                let res = "";
                if (isString$1(value)) {
                    res = value;
                } else if (isArray$2(value)) {
                    for(let i = 0; i < value.length; i++){
                        const normalized = normalizeClass(value[i]);
                        if (normalized) {
                            res += normalized + " ";
                        }
                    }
                } else if (isObject$1(value)) {
                    for(const name in value){
                        if (value[name]) {
                            res += name + " ";
                        }
                    }
                }
                return res.trim();
            }
            const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
            const isSpecialBooleanAttr = makeMap(specialBooleanAttrs);
            function includeBooleanAttr(value) {
                return !!value || value === "";
            }
            const isRef$1 = (val)=>{
                return !!(val && val["__v_isRef"] === true);
            };
            const toDisplayString = exports("t", (val)=>{
                return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
            });
            const replacer = (_key, val)=>{
                if (isRef$1(val)) {
                    return replacer(_key, val.value);
                } else if (isMap(val)) {
                    return {
                        [`Map(${val.size})`]: [
                            ...val.entries()
                        ].reduce((entries, [key, val2], i)=>{
                            entries[stringifySymbol(key, i) + " =>"] = val2;
                            return entries;
                        }, {})
                    };
                } else if (isSet(val)) {
                    return {
                        [`Set(${val.size})`]: [
                            ...val.values()
                        ].map((v)=>stringifySymbol(v))
                    };
                } else if (isSymbol(val)) {
                    return stringifySymbol(val);
                } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$1(val)) {
                    return String(val);
                }
                return val;
            };
            const stringifySymbol = (v, i = "")=>{
                var _a;
                return (isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v);
            };
            let activeEffectScope;
            class EffectScope {
                constructor(detached = false){
                    this.detached = detached;
                    this._active = true;
                    this._on = 0;
                    this.effects = [];
                    this.cleanups = [];
                    this._isPaused = false;
                    this.parent = activeEffectScope;
                    if (!detached && activeEffectScope) {
                        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
                    }
                }
                get active() {
                    return this._active;
                }
                pause() {
                    if (this._active) {
                        this._isPaused = true;
                        let i, l;
                        if (this.scopes) {
                            for(i = 0, l = this.scopes.length; i < l; i++){
                                this.scopes[i].pause();
                            }
                        }
                        for(i = 0, l = this.effects.length; i < l; i++){
                            this.effects[i].pause();
                        }
                    }
                }
                resume() {
                    if (this._active) {
                        if (this._isPaused) {
                            this._isPaused = false;
                            let i, l;
                            if (this.scopes) {
                                for(i = 0, l = this.scopes.length; i < l; i++){
                                    this.scopes[i].resume();
                                }
                            }
                            for(i = 0, l = this.effects.length; i < l; i++){
                                this.effects[i].resume();
                            }
                        }
                    }
                }
                run(fn) {
                    if (this._active) {
                        const currentEffectScope = activeEffectScope;
                        try {
                            activeEffectScope = this;
                            return fn();
                        } finally{
                            activeEffectScope = currentEffectScope;
                        }
                    }
                }
                on() {
                    if (++this._on === 1) {
                        this.prevScope = activeEffectScope;
                        activeEffectScope = this;
                    }
                }
                off() {
                    if (this._on > 0 && --this._on === 0) {
                        activeEffectScope = this.prevScope;
                        this.prevScope = void 0;
                    }
                }
                stop(fromParent) {
                    if (this._active) {
                        this._active = false;
                        let i, l;
                        for(i = 0, l = this.effects.length; i < l; i++){
                            this.effects[i].stop();
                        }
                        this.effects.length = 0;
                        for(i = 0, l = this.cleanups.length; i < l; i++){
                            this.cleanups[i]();
                        }
                        this.cleanups.length = 0;
                        if (this.scopes) {
                            for(i = 0, l = this.scopes.length; i < l; i++){
                                this.scopes[i].stop(true);
                            }
                            this.scopes.length = 0;
                        }
                        if (!this.detached && this.parent && !fromParent) {
                            const last = this.parent.scopes.pop();
                            if (last && last !== this) {
                                this.parent.scopes[this.index] = last;
                                last.index = this.index;
                            }
                        }
                        this.parent = void 0;
                    }
                }
            }
            function getCurrentScope() {
                return activeEffectScope;
            }
            let activeSub;
            const pausedQueueEffects = new WeakSet();
            class ReactiveEffect {
                constructor(fn){
                    this.fn = fn;
                    this.deps = void 0;
                    this.depsTail = void 0;
                    this.flags = 1 | 4;
                    this.next = void 0;
                    this.cleanup = void 0;
                    this.scheduler = void 0;
                    if (activeEffectScope && activeEffectScope.active) {
                        activeEffectScope.effects.push(this);
                    }
                }
                pause() {
                    this.flags |= 64;
                }
                resume() {
                    if (this.flags & 64) {
                        this.flags &= -65;
                        if (pausedQueueEffects.has(this)) {
                            pausedQueueEffects.delete(this);
                            this.trigger();
                        }
                    }
                }
                notify() {
                    if (this.flags & 2 && !(this.flags & 32)) {
                        return;
                    }
                    if (!(this.flags & 8)) {
                        batch(this);
                    }
                }
                run() {
                    if (!(this.flags & 1)) {
                        return this.fn();
                    }
                    this.flags |= 2;
                    cleanupEffect(this);
                    prepareDeps(this);
                    const prevEffect = activeSub;
                    const prevShouldTrack = shouldTrack;
                    activeSub = this;
                    shouldTrack = true;
                    try {
                        return this.fn();
                    } finally{
                        cleanupDeps(this);
                        activeSub = prevEffect;
                        shouldTrack = prevShouldTrack;
                        this.flags &= -3;
                    }
                }
                stop() {
                    if (this.flags & 1) {
                        for(let link = this.deps; link; link = link.nextDep){
                            removeSub(link);
                        }
                        this.deps = this.depsTail = void 0;
                        cleanupEffect(this);
                        this.onStop && this.onStop();
                        this.flags &= -2;
                    }
                }
                trigger() {
                    if (this.flags & 64) {
                        pausedQueueEffects.add(this);
                    } else if (this.scheduler) {
                        this.scheduler();
                    } else {
                        this.runIfDirty();
                    }
                }
                runIfDirty() {
                    if (isDirty(this)) {
                        this.run();
                    }
                }
                get dirty() {
                    return isDirty(this);
                }
            }
            let batchDepth = 0;
            let batchedSub;
            let batchedComputed;
            function batch(sub, isComputed = false) {
                sub.flags |= 8;
                if (isComputed) {
                    sub.next = batchedComputed;
                    batchedComputed = sub;
                    return;
                }
                sub.next = batchedSub;
                batchedSub = sub;
            }
            function startBatch() {
                batchDepth++;
            }
            function endBatch() {
                if (--batchDepth > 0) {
                    return;
                }
                if (batchedComputed) {
                    let e = batchedComputed;
                    batchedComputed = void 0;
                    while(e){
                        const next = e.next;
                        e.next = void 0;
                        e.flags &= -9;
                        e = next;
                    }
                }
                let error;
                while(batchedSub){
                    let e = batchedSub;
                    batchedSub = void 0;
                    while(e){
                        const next = e.next;
                        e.next = void 0;
                        e.flags &= -9;
                        if (e.flags & 1) {
                            try {
                                ;
                                e.trigger();
                            } catch (err) {
                                if (!error) error = err;
                            }
                        }
                        e = next;
                    }
                }
                if (error) throw error;
            }
            function prepareDeps(sub) {
                for(let link = sub.deps; link; link = link.nextDep){
                    link.version = -1;
                    link.prevActiveLink = link.dep.activeLink;
                    link.dep.activeLink = link;
                }
            }
            function cleanupDeps(sub) {
                let head;
                let tail = sub.depsTail;
                let link = tail;
                while(link){
                    const prev = link.prevDep;
                    if (link.version === -1) {
                        if (link === tail) tail = prev;
                        removeSub(link);
                        removeDep(link);
                    } else {
                        head = link;
                    }
                    link.dep.activeLink = link.prevActiveLink;
                    link.prevActiveLink = void 0;
                    link = prev;
                }
                sub.deps = head;
                sub.depsTail = tail;
            }
            function isDirty(sub) {
                for(let link = sub.deps; link; link = link.nextDep){
                    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
                        return true;
                    }
                }
                if (sub._dirty) {
                    return true;
                }
                return false;
            }
            function refreshComputed(computed2) {
                if (computed2.flags & 4 && !(computed2.flags & 16)) {
                    return;
                }
                computed2.flags &= -17;
                if (computed2.globalVersion === globalVersion) {
                    return;
                }
                computed2.globalVersion = globalVersion;
                if (!computed2.isSSR && computed2.flags & 128 && (!computed2.deps && !computed2._dirty || !isDirty(computed2))) {
                    return;
                }
                computed2.flags |= 2;
                const dep = computed2.dep;
                const prevSub = activeSub;
                const prevShouldTrack = shouldTrack;
                activeSub = computed2;
                shouldTrack = true;
                try {
                    prepareDeps(computed2);
                    const value = computed2.fn(computed2._value);
                    if (dep.version === 0 || hasChanged(value, computed2._value)) {
                        computed2.flags |= 128;
                        computed2._value = value;
                        dep.version++;
                    }
                } catch (err) {
                    dep.version++;
                    throw err;
                } finally{
                    activeSub = prevSub;
                    shouldTrack = prevShouldTrack;
                    cleanupDeps(computed2);
                    computed2.flags &= -3;
                }
            }
            function removeSub(link, soft = false) {
                const { dep, prevSub, nextSub } = link;
                if (prevSub) {
                    prevSub.nextSub = nextSub;
                    link.prevSub = void 0;
                }
                if (nextSub) {
                    nextSub.prevSub = prevSub;
                    link.nextSub = void 0;
                }
                if (dep.subs === link) {
                    dep.subs = prevSub;
                    if (!prevSub && dep.computed) {
                        dep.computed.flags &= -5;
                        for(let l = dep.computed.deps; l; l = l.nextDep){
                            removeSub(l, true);
                        }
                    }
                }
                if (!soft && !--dep.sc && dep.map) {
                    dep.map.delete(dep.key);
                }
            }
            function removeDep(link) {
                const { prevDep, nextDep } = link;
                if (prevDep) {
                    prevDep.nextDep = nextDep;
                    link.prevDep = void 0;
                }
                if (nextDep) {
                    nextDep.prevDep = prevDep;
                    link.nextDep = void 0;
                }
            }
            let shouldTrack = true;
            const trackStack = [];
            function pauseTracking() {
                trackStack.push(shouldTrack);
                shouldTrack = false;
            }
            function resetTracking() {
                const last = trackStack.pop();
                shouldTrack = last === void 0 ? true : last;
            }
            function cleanupEffect(e) {
                const { cleanup } = e;
                e.cleanup = void 0;
                if (cleanup) {
                    const prevSub = activeSub;
                    activeSub = void 0;
                    try {
                        cleanup();
                    } finally{
                        activeSub = prevSub;
                    }
                }
            }
            let globalVersion = 0;
            class Link {
                constructor(sub, dep){
                    this.sub = sub;
                    this.dep = dep;
                    this.version = dep.version;
                    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
                }
            }
            class Dep {
                constructor(computed2){
                    this.computed = computed2;
                    this.version = 0;
                    this.activeLink = void 0;
                    this.subs = void 0;
                    this.map = void 0;
                    this.key = void 0;
                    this.sc = 0;
                    this.__v_skip = true;
                }
                track(debugInfo) {
                    if (!activeSub || !shouldTrack || activeSub === this.computed) {
                        return;
                    }
                    let link = this.activeLink;
                    if (link === void 0 || link.sub !== activeSub) {
                        link = this.activeLink = new Link(activeSub, this);
                        if (!activeSub.deps) {
                            activeSub.deps = activeSub.depsTail = link;
                        } else {
                            link.prevDep = activeSub.depsTail;
                            activeSub.depsTail.nextDep = link;
                            activeSub.depsTail = link;
                        }
                        addSub(link);
                    } else if (link.version === -1) {
                        link.version = this.version;
                        if (link.nextDep) {
                            const next = link.nextDep;
                            next.prevDep = link.prevDep;
                            if (link.prevDep) {
                                link.prevDep.nextDep = next;
                            }
                            link.prevDep = activeSub.depsTail;
                            link.nextDep = void 0;
                            activeSub.depsTail.nextDep = link;
                            activeSub.depsTail = link;
                            if (activeSub.deps === link) {
                                activeSub.deps = next;
                            }
                        }
                    }
                    return link;
                }
                trigger(debugInfo) {
                    this.version++;
                    globalVersion++;
                    this.notify(debugInfo);
                }
                notify(debugInfo) {
                    startBatch();
                    try {
                        if (false) ;
                        for(let link = this.subs; link; link = link.prevSub){
                            if (link.sub.notify()) {
                                ;
                                link.sub.dep.notify();
                            }
                        }
                    } finally{
                        endBatch();
                    }
                }
            }
            function addSub(link) {
                link.dep.sc++;
                if (link.sub.flags & 4) {
                    const computed2 = link.dep.computed;
                    if (computed2 && !link.dep.subs) {
                        computed2.flags |= 4 | 16;
                        for(let l = computed2.deps; l; l = l.nextDep){
                            addSub(l);
                        }
                    }
                    const currentTail = link.dep.subs;
                    if (currentTail !== link) {
                        link.prevSub = currentTail;
                        if (currentTail) currentTail.nextSub = link;
                    }
                    link.dep.subs = link;
                }
            }
            const targetMap = new WeakMap();
            const ITERATE_KEY = Symbol("");
            const MAP_KEY_ITERATE_KEY = Symbol("");
            const ARRAY_ITERATE_KEY = Symbol("");
            function track(target, type, key) {
                if (shouldTrack && activeSub) {
                    let depsMap = targetMap.get(target);
                    if (!depsMap) {
                        targetMap.set(target, depsMap = new Map());
                    }
                    let dep = depsMap.get(key);
                    if (!dep) {
                        depsMap.set(key, dep = new Dep());
                        dep.map = depsMap;
                        dep.key = key;
                    }
                    {
                        dep.track();
                    }
                }
            }
            function trigger(target, type, key, newValue, oldValue, oldTarget) {
                const depsMap = targetMap.get(target);
                if (!depsMap) {
                    globalVersion++;
                    return;
                }
                const run = (dep)=>{
                    if (dep) {
                        {
                            dep.trigger();
                        }
                    }
                };
                startBatch();
                if (type === "clear") {
                    depsMap.forEach(run);
                } else {
                    const targetIsArray = isArray$2(target);
                    const isArrayIndex = targetIsArray && isIntegerKey(key);
                    if (targetIsArray && key === "length") {
                        const newLength = Number(newValue);
                        depsMap.forEach((dep, key2)=>{
                            if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
                                run(dep);
                            }
                        });
                    } else {
                        if (key !== void 0 || depsMap.has(void 0)) {
                            run(depsMap.get(key));
                        }
                        if (isArrayIndex) {
                            run(depsMap.get(ARRAY_ITERATE_KEY));
                        }
                        switch(type){
                            case "add":
                                if (!targetIsArray) {
                                    run(depsMap.get(ITERATE_KEY));
                                    if (isMap(target)) {
                                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                                    }
                                } else if (isArrayIndex) {
                                    run(depsMap.get("length"));
                                }
                                break;
                            case "delete":
                                if (!targetIsArray) {
                                    run(depsMap.get(ITERATE_KEY));
                                    if (isMap(target)) {
                                        run(depsMap.get(MAP_KEY_ITERATE_KEY));
                                    }
                                }
                                break;
                            case "set":
                                if (isMap(target)) {
                                    run(depsMap.get(ITERATE_KEY));
                                }
                                break;
                        }
                    }
                }
                endBatch();
            }
            function getDepFromReactive(object, key) {
                const depMap = targetMap.get(object);
                return depMap && depMap.get(key);
            }
            function reactiveReadArray(array) {
                const raw = toRaw(array);
                if (raw === array) return raw;
                track(raw, "iterate", ARRAY_ITERATE_KEY);
                return isShallow(array) ? raw : raw.map(toReactive);
            }
            function shallowReadArray(arr) {
                track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
                return arr;
            }
            const arrayInstrumentations = {
                __proto__: null,
                [Symbol.iterator] () {
                    return iterator$1(this, Symbol.iterator, toReactive);
                },
                concat (...args) {
                    return reactiveReadArray(this).concat(...args.map((x2)=>isArray$2(x2) ? reactiveReadArray(x2) : x2));
                },
                entries () {
                    return iterator$1(this, "entries", (value)=>{
                        value[1] = toReactive(value[1]);
                        return value;
                    });
                },
                every (fn, thisArg) {
                    return apply(this, "every", fn, thisArg, void 0, arguments);
                },
                filter (fn, thisArg) {
                    return apply(this, "filter", fn, thisArg, (v)=>v.map(toReactive), arguments);
                },
                find (fn, thisArg) {
                    return apply(this, "find", fn, thisArg, toReactive, arguments);
                },
                findIndex (fn, thisArg) {
                    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
                },
                findLast (fn, thisArg) {
                    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
                },
                findLastIndex (fn, thisArg) {
                    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
                },
                forEach (fn, thisArg) {
                    return apply(this, "forEach", fn, thisArg, void 0, arguments);
                },
                includes (...args) {
                    return searchProxy(this, "includes", args);
                },
                indexOf (...args) {
                    return searchProxy(this, "indexOf", args);
                },
                join (separator) {
                    return reactiveReadArray(this).join(separator);
                },
                lastIndexOf (...args) {
                    return searchProxy(this, "lastIndexOf", args);
                },
                map (fn, thisArg) {
                    return apply(this, "map", fn, thisArg, void 0, arguments);
                },
                pop () {
                    return noTracking(this, "pop");
                },
                push (...args) {
                    return noTracking(this, "push", args);
                },
                reduce (fn, ...args) {
                    return reduce$1(this, "reduce", fn, args);
                },
                reduceRight (fn, ...args) {
                    return reduce$1(this, "reduceRight", fn, args);
                },
                shift () {
                    return noTracking(this, "shift");
                },
                some (fn, thisArg) {
                    return apply(this, "some", fn, thisArg, void 0, arguments);
                },
                splice (...args) {
                    return noTracking(this, "splice", args);
                },
                toReversed () {
                    return reactiveReadArray(this).toReversed();
                },
                toSorted (comparer) {
                    return reactiveReadArray(this).toSorted(comparer);
                },
                toSpliced (...args) {
                    return reactiveReadArray(this).toSpliced(...args);
                },
                unshift (...args) {
                    return noTracking(this, "unshift", args);
                },
                values () {
                    return iterator$1(this, "values", toReactive);
                }
            };
            function iterator$1(self2, method, wrapValue) {
                const arr = shallowReadArray(self2);
                const iter = arr[method]();
                if (arr !== self2 && !isShallow(self2)) {
                    iter._next = iter.next;
                    iter.next = ()=>{
                        const result = iter._next();
                        if (result.value) {
                            result.value = wrapValue(result.value);
                        }
                        return result;
                    };
                }
                return iter;
            }
            const arrayProto = Array.prototype;
            function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
                const arr = shallowReadArray(self2);
                const needsWrap = arr !== self2 && !isShallow(self2);
                const methodFn = arr[method];
                if (methodFn !== arrayProto[method]) {
                    const result2 = methodFn.apply(self2, args);
                    return needsWrap ? toReactive(result2) : result2;
                }
                let wrappedFn = fn;
                if (arr !== self2) {
                    if (needsWrap) {
                        wrappedFn = function(item, index) {
                            return fn.call(this, toReactive(item), index, self2);
                        };
                    } else if (fn.length > 2) {
                        wrappedFn = function(item, index) {
                            return fn.call(this, item, index, self2);
                        };
                    }
                }
                const result = methodFn.call(arr, wrappedFn, thisArg);
                return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
            }
            function reduce$1(self2, method, fn, args) {
                const arr = shallowReadArray(self2);
                let wrappedFn = fn;
                if (arr !== self2) {
                    if (!isShallow(self2)) {
                        wrappedFn = function(acc, item, index) {
                            return fn.call(this, acc, toReactive(item), index, self2);
                        };
                    } else if (fn.length > 3) {
                        wrappedFn = function(acc, item, index) {
                            return fn.call(this, acc, item, index, self2);
                        };
                    }
                }
                return arr[method](wrappedFn, ...args);
            }
            function searchProxy(self2, method, args) {
                const arr = toRaw(self2);
                track(arr, "iterate", ARRAY_ITERATE_KEY);
                const res = arr[method](...args);
                if ((res === -1 || res === false) && isProxy(args[0])) {
                    args[0] = toRaw(args[0]);
                    return arr[method](...args);
                }
                return res;
            }
            function noTracking(self2, method, args = []) {
                pauseTracking();
                startBatch();
                const res = toRaw(self2)[method].apply(self2, args);
                endBatch();
                resetTracking();
                return res;
            }
            const isNonTrackableKeys = makeMap(`__proto__,__v_isRef,__isVue`);
            const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).filter((key)=>key !== "arguments" && key !== "caller").map((key)=>Symbol[key]).filter(isSymbol));
            function hasOwnProperty$1(key) {
                if (!isSymbol(key)) key = String(key);
                const obj = toRaw(this);
                track(obj, "has", key);
                return obj.hasOwnProperty(key);
            }
            class BaseReactiveHandler {
                constructor(_isReadonly = false, _isShallow = false){
                    this._isReadonly = _isReadonly;
                    this._isShallow = _isShallow;
                }
                get(target, key, receiver) {
                    if (key === "__v_skip") return target["__v_skip"];
                    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
                    if (key === "__v_isReactive") {
                        return !isReadonly2;
                    } else if (key === "__v_isReadonly") {
                        return isReadonly2;
                    } else if (key === "__v_isShallow") {
                        return isShallow2;
                    } else if (key === "__v_raw") {
                        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
                            return target;
                        }
                        return;
                    }
                    const targetIsArray = isArray$2(target);
                    if (!isReadonly2) {
                        let fn;
                        if (targetIsArray && (fn = arrayInstrumentations[key])) {
                            return fn;
                        }
                        if (key === "hasOwnProperty") {
                            return hasOwnProperty$1;
                        }
                    }
                    const res = Reflect.get(target, key, isRef(target) ? target : receiver);
                    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
                        return res;
                    }
                    if (!isReadonly2) {
                        track(target, "get", key);
                    }
                    if (isShallow2) {
                        return res;
                    }
                    if (isRef(res)) {
                        return targetIsArray && isIntegerKey(key) ? res : res.value;
                    }
                    if (isObject$1(res)) {
                        return isReadonly2 ? readonly(res) : reactive(res);
                    }
                    return res;
                }
            }
            class MutableReactiveHandler extends BaseReactiveHandler {
                constructor(isShallow2 = false){
                    super(false, isShallow2);
                }
                set(target, key, value, receiver) {
                    let oldValue = target[key];
                    if (!this._isShallow) {
                        const isOldValueReadonly = isReadonly(oldValue);
                        if (!isShallow(value) && !isReadonly(value)) {
                            oldValue = toRaw(oldValue);
                            value = toRaw(value);
                        }
                        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
                            if (isOldValueReadonly) {
                                return true;
                            } else {
                                oldValue.value = value;
                                return true;
                            }
                        }
                    }
                    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
                    const result = Reflect.set(target, key, value, isRef(target) ? target : receiver);
                    if (target === toRaw(receiver)) {
                        if (!hadKey) {
                            trigger(target, "add", key, value);
                        } else if (hasChanged(value, oldValue)) {
                            trigger(target, "set", key, value);
                        }
                    }
                    return result;
                }
                deleteProperty(target, key) {
                    const hadKey = hasOwn(target, key);
                    target[key];
                    const result = Reflect.deleteProperty(target, key);
                    if (result && hadKey) {
                        trigger(target, "delete", key, void 0);
                    }
                    return result;
                }
                has(target, key) {
                    const result = Reflect.has(target, key);
                    if (!isSymbol(key) || !builtInSymbols.has(key)) {
                        track(target, "has", key);
                    }
                    return result;
                }
                ownKeys(target) {
                    track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
                    return Reflect.ownKeys(target);
                }
            }
            class ReadonlyReactiveHandler extends BaseReactiveHandler {
                constructor(isShallow2 = false){
                    super(true, isShallow2);
                }
                set(target, key) {
                    return true;
                }
                deleteProperty(target, key) {
                    return true;
                }
            }
            const mutableHandlers = new MutableReactiveHandler();
            const readonlyHandlers = new ReadonlyReactiveHandler();
            const shallowReactiveHandlers = new MutableReactiveHandler(true);
            const shallowReadonlyHandlers = new ReadonlyReactiveHandler(true);
            const toShallow = (value)=>value;
            const getProto = (v)=>Reflect.getPrototypeOf(v);
            function createIterableMethod(method, isReadonly2, isShallow2) {
                return function(...args) {
                    const target = this["__v_raw"];
                    const rawTarget = toRaw(target);
                    const targetIsMap = isMap(rawTarget);
                    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
                    const isKeyOnly = method === "keys" && targetIsMap;
                    const innerIterator = target[method](...args);
                    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
                    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
                    return {
                        next () {
                            const { value, done } = innerIterator.next();
                            return done ? {
                                value,
                                done
                            } : {
                                value: isPair ? [
                                    wrap(value[0]),
                                    wrap(value[1])
                                ] : wrap(value),
                                done
                            };
                        },
                        [Symbol.iterator] () {
                            return this;
                        }
                    };
                };
            }
            function createReadonlyMethod(type) {
                return function(...args) {
                    return type === "delete" ? false : type === "clear" ? void 0 : this;
                };
            }
            function createInstrumentations(readonly2, shallow) {
                const instrumentations = {
                    get (key) {
                        const target = this["__v_raw"];
                        const rawTarget = toRaw(target);
                        const rawKey = toRaw(key);
                        if (!readonly2) {
                            if (hasChanged(key, rawKey)) {
                                track(rawTarget, "get", key);
                            }
                            track(rawTarget, "get", rawKey);
                        }
                        const { has } = getProto(rawTarget);
                        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                        if (has.call(rawTarget, key)) {
                            return wrap(target.get(key));
                        } else if (has.call(rawTarget, rawKey)) {
                            return wrap(target.get(rawKey));
                        } else if (target !== rawTarget) {
                            target.get(key);
                        }
                    },
                    get size () {
                        const target = this["__v_raw"];
                        !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
                        return target.size;
                    },
                    has (key) {
                        const target = this["__v_raw"];
                        const rawTarget = toRaw(target);
                        const rawKey = toRaw(key);
                        if (!readonly2) {
                            if (hasChanged(key, rawKey)) {
                                track(rawTarget, "has", key);
                            }
                            track(rawTarget, "has", rawKey);
                        }
                        return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
                    },
                    forEach (callback, thisArg) {
                        const observed = this;
                        const target = observed["__v_raw"];
                        const rawTarget = toRaw(target);
                        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
                        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
                        return target.forEach((value, key)=>{
                            return callback.call(thisArg, wrap(value), wrap(key), observed);
                        });
                    }
                };
                extend$1(instrumentations, readonly2 ? {
                    add: createReadonlyMethod("add"),
                    set: createReadonlyMethod("set"),
                    delete: createReadonlyMethod("delete"),
                    clear: createReadonlyMethod("clear")
                } : {
                    add (value) {
                        if (!shallow && !isShallow(value) && !isReadonly(value)) {
                            value = toRaw(value);
                        }
                        const target = toRaw(this);
                        const proto = getProto(target);
                        const hadKey = proto.has.call(target, value);
                        if (!hadKey) {
                            target.add(value);
                            trigger(target, "add", value, value);
                        }
                        return this;
                    },
                    set (key, value) {
                        if (!shallow && !isShallow(value) && !isReadonly(value)) {
                            value = toRaw(value);
                        }
                        const target = toRaw(this);
                        const { has, get } = getProto(target);
                        let hadKey = has.call(target, key);
                        if (!hadKey) {
                            key = toRaw(key);
                            hadKey = has.call(target, key);
                        }
                        const oldValue = get.call(target, key);
                        target.set(key, value);
                        if (!hadKey) {
                            trigger(target, "add", key, value);
                        } else if (hasChanged(value, oldValue)) {
                            trigger(target, "set", key, value);
                        }
                        return this;
                    },
                    delete (key) {
                        const target = toRaw(this);
                        const { has, get } = getProto(target);
                        let hadKey = has.call(target, key);
                        if (!hadKey) {
                            key = toRaw(key);
                            hadKey = has.call(target, key);
                        }
                        get ? get.call(target, key) : void 0;
                        const result = target.delete(key);
                        if (hadKey) {
                            trigger(target, "delete", key, void 0);
                        }
                        return result;
                    },
                    clear () {
                        const target = toRaw(this);
                        const hadItems = target.size !== 0;
                        const result = target.clear();
                        if (hadItems) {
                            trigger(target, "clear", void 0, void 0);
                        }
                        return result;
                    }
                });
                const iteratorMethods = [
                    "keys",
                    "values",
                    "entries",
                    Symbol.iterator
                ];
                iteratorMethods.forEach((method)=>{
                    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
                });
                return instrumentations;
            }
            function createInstrumentationGetter(isReadonly2, shallow) {
                const instrumentations = createInstrumentations(isReadonly2, shallow);
                return (target, key, receiver)=>{
                    if (key === "__v_isReactive") {
                        return !isReadonly2;
                    } else if (key === "__v_isReadonly") {
                        return isReadonly2;
                    } else if (key === "__v_raw") {
                        return target;
                    }
                    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
                };
            }
            const mutableCollectionHandlers = {
                get: createInstrumentationGetter(false, false)
            };
            const shallowCollectionHandlers = {
                get: createInstrumentationGetter(false, true)
            };
            const readonlyCollectionHandlers = {
                get: createInstrumentationGetter(true, false)
            };
            const shallowReadonlyCollectionHandlers = {
                get: createInstrumentationGetter(true, true)
            };
            const reactiveMap = new WeakMap();
            const shallowReactiveMap = new WeakMap();
            const readonlyMap = new WeakMap();
            const shallowReadonlyMap = new WeakMap();
            function targetTypeMap(rawType) {
                switch(rawType){
                    case "Object":
                    case "Array":
                        return 1;
                    case "Map":
                    case "Set":
                    case "WeakMap":
                    case "WeakSet":
                        return 2;
                    default:
                        return 0;
                }
            }
            function getTargetType(value) {
                return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
            }
            function reactive(target) {
                if (isReadonly(target)) {
                    return target;
                }
                return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
            }
            function shallowReactive(target) {
                return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
            }
            function readonly(target) {
                return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
            }
            function shallowReadonly(target) {
                return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
            }
            function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
                if (!isObject$1(target)) {
                    return target;
                }
                if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
                    return target;
                }
                const targetType = getTargetType(target);
                if (targetType === 0) {
                    return target;
                }
                const existingProxy = proxyMap.get(target);
                if (existingProxy) {
                    return existingProxy;
                }
                const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
                proxyMap.set(target, proxy);
                return proxy;
            }
            function isReactive(value) {
                if (isReadonly(value)) {
                    return isReactive(value["__v_raw"]);
                }
                return !!(value && value["__v_isReactive"]);
            }
            function isReadonly(value) {
                return !!(value && value["__v_isReadonly"]);
            }
            function isShallow(value) {
                return !!(value && value["__v_isShallow"]);
            }
            function isProxy(value) {
                return value ? !!value["__v_raw"] : false;
            }
            function toRaw(observed) {
                const raw = observed && observed["__v_raw"];
                return raw ? toRaw(raw) : observed;
            }
            function markRaw(value) {
                if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
                    def(value, "__v_skip", true);
                }
                return value;
            }
            const toReactive = (value)=>isObject$1(value) ? reactive(value) : value;
            const toReadonly = (value)=>isObject$1(value) ? readonly(value) : value;
            function isRef(r2) {
                return r2 ? r2["__v_isRef"] === true : false;
            }
            function ref(value) {
                return createRef(value, false);
            }
            function shallowRef(value) {
                return createRef(value, true);
            }
            function createRef(rawValue, shallow) {
                if (isRef(rawValue)) {
                    return rawValue;
                }
                return new RefImpl(rawValue, shallow);
            }
            class RefImpl {
                constructor(value, isShallow2){
                    this.dep = new Dep();
                    this["__v_isRef"] = true;
                    this["__v_isShallow"] = false;
                    this._rawValue = isShallow2 ? value : toRaw(value);
                    this._value = isShallow2 ? value : toReactive(value);
                    this["__v_isShallow"] = isShallow2;
                }
                get value() {
                    {
                        this.dep.track();
                    }
                    return this._value;
                }
                set value(newValue) {
                    const oldValue = this._rawValue;
                    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
                    newValue = useDirectValue ? newValue : toRaw(newValue);
                    if (hasChanged(newValue, oldValue)) {
                        this._rawValue = newValue;
                        this._value = useDirectValue ? newValue : toReactive(newValue);
                        {
                            this.dep.trigger();
                        }
                    }
                }
            }
            function unref(ref2) {
                return isRef(ref2) ? ref2.value : ref2;
            }
            const shallowUnwrapHandlers = {
                get: (target, key, receiver)=>key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
                set: (target, key, value, receiver)=>{
                    const oldValue = target[key];
                    if (isRef(oldValue) && !isRef(value)) {
                        oldValue.value = value;
                        return true;
                    } else {
                        return Reflect.set(target, key, value, receiver);
                    }
                }
            };
            function proxyRefs(objectWithRefs) {
                return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
            }
            function toRefs(object) {
                const ret = isArray$2(object) ? new Array(object.length) : {};
                for(const key in object){
                    ret[key] = propertyToRef(object, key);
                }
                return ret;
            }
            class ObjectRefImpl {
                constructor(_object, _key, _defaultValue){
                    this._object = _object;
                    this._key = _key;
                    this._defaultValue = _defaultValue;
                    this["__v_isRef"] = true;
                    this._value = void 0;
                }
                get value() {
                    const val = this._object[this._key];
                    return this._value = val === void 0 ? this._defaultValue : val;
                }
                set value(newVal) {
                    this._object[this._key] = newVal;
                }
                get dep() {
                    return getDepFromReactive(toRaw(this._object), this._key);
                }
            }
            function propertyToRef(source, key, defaultValue) {
                const val = source[key];
                return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
            }
            class ComputedRefImpl {
                constructor(fn, setter, isSSR){
                    this.fn = fn;
                    this.setter = setter;
                    this._value = void 0;
                    this.dep = new Dep(this);
                    this.__v_isRef = true;
                    this.deps = void 0;
                    this.depsTail = void 0;
                    this.flags = 16;
                    this.globalVersion = globalVersion - 1;
                    this.next = void 0;
                    this.effect = this;
                    this["__v_isReadonly"] = !setter;
                    this.isSSR = isSSR;
                }
                notify() {
                    this.flags |= 16;
                    if (!(this.flags & 8) && activeSub !== this) {
                        batch(this, true);
                        return true;
                    }
                }
                get value() {
                    const link = this.dep.track();
                    refreshComputed(this);
                    if (link) {
                        link.version = this.dep.version;
                    }
                    return this._value;
                }
                set value(newValue) {
                    if (this.setter) {
                        this.setter(newValue);
                    }
                }
            }
            function computed$1(getterOrOptions, debugOptions, isSSR = false) {
                let getter;
                let setter;
                if (isFunction$2(getterOrOptions)) {
                    getter = getterOrOptions;
                } else {
                    getter = getterOrOptions.get;
                    setter = getterOrOptions.set;
                }
                const cRef = new ComputedRefImpl(getter, setter, isSSR);
                return cRef;
            }
            const INITIAL_WATCHER_VALUE = {};
            const cleanupMap = new WeakMap();
            let activeWatcher = void 0;
            function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
                if (owner) {
                    let cleanups = cleanupMap.get(owner);
                    if (!cleanups) cleanupMap.set(owner, cleanups = []);
                    cleanups.push(cleanupFn);
                }
            }
            function watch$1(source, cb, options = EMPTY_OBJ) {
                const { immediate, deep, once, scheduler, augmentJob, call } = options;
                const reactiveGetter = (source2)=>{
                    if (deep) return source2;
                    if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);
                    return traverse(source2);
                };
                let effect2;
                let getter;
                let cleanup;
                let boundCleanup;
                let forceTrigger = false;
                let isMultiSource = false;
                if (isRef(source)) {
                    getter = ()=>source.value;
                    forceTrigger = isShallow(source);
                } else if (isReactive(source)) {
                    getter = ()=>reactiveGetter(source);
                    forceTrigger = true;
                } else if (isArray$2(source)) {
                    isMultiSource = true;
                    forceTrigger = source.some((s2)=>isReactive(s2) || isShallow(s2));
                    getter = ()=>source.map((s2)=>{
                            if (isRef(s2)) {
                                return s2.value;
                            } else if (isReactive(s2)) {
                                return reactiveGetter(s2);
                            } else if (isFunction$2(s2)) {
                                return call ? call(s2, 2) : s2();
                            } else ;
                        });
                } else if (isFunction$2(source)) {
                    if (cb) {
                        getter = call ? ()=>call(source, 2) : source;
                    } else {
                        getter = ()=>{
                            if (cleanup) {
                                pauseTracking();
                                try {
                                    cleanup();
                                } finally{
                                    resetTracking();
                                }
                            }
                            const currentEffect = activeWatcher;
                            activeWatcher = effect2;
                            try {
                                return call ? call(source, 3, [
                                    boundCleanup
                                ]) : source(boundCleanup);
                            } finally{
                                activeWatcher = currentEffect;
                            }
                        };
                    }
                } else {
                    getter = NOOP;
                }
                if (cb && deep) {
                    const baseGetter = getter;
                    const depth = deep === true ? Infinity : deep;
                    getter = ()=>traverse(baseGetter(), depth);
                }
                const scope = getCurrentScope();
                const watchHandle = ()=>{
                    effect2.stop();
                    if (scope && scope.active) {
                        remove(scope.effects, effect2);
                    }
                };
                if (once && cb) {
                    const _cb = cb;
                    cb = (...args)=>{
                        _cb(...args);
                        watchHandle();
                    };
                }
                let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
                const job = (immediateFirstRun)=>{
                    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
                        return;
                    }
                    if (cb) {
                        const newValue = effect2.run();
                        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i)=>hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {
                            if (cleanup) {
                                cleanup();
                            }
                            const currentWatcher = activeWatcher;
                            activeWatcher = effect2;
                            try {
                                const args = [
                                    newValue,
                                    oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
                                    boundCleanup
                                ];
                                oldValue = newValue;
                                call ? call(cb, 3, args) : (cb(...args));
                            } finally{
                                activeWatcher = currentWatcher;
                            }
                        }
                    } else {
                        effect2.run();
                    }
                };
                if (augmentJob) {
                    augmentJob(job);
                }
                effect2 = new ReactiveEffect(getter);
                effect2.scheduler = scheduler ? ()=>scheduler(job, false) : job;
                boundCleanup = (fn)=>onWatcherCleanup(fn, false, effect2);
                cleanup = effect2.onStop = ()=>{
                    const cleanups = cleanupMap.get(effect2);
                    if (cleanups) {
                        if (call) {
                            call(cleanups, 4);
                        } else {
                            for (const cleanup2 of cleanups)cleanup2();
                        }
                        cleanupMap.delete(effect2);
                    }
                };
                if (cb) {
                    if (immediate) {
                        job(true);
                    } else {
                        oldValue = effect2.run();
                    }
                } else if (scheduler) {
                    scheduler(job.bind(null, true), true);
                } else {
                    effect2.run();
                }
                watchHandle.pause = effect2.pause.bind(effect2);
                watchHandle.resume = effect2.resume.bind(effect2);
                watchHandle.stop = watchHandle;
                return watchHandle;
            }
            function traverse(value, depth = Infinity, seen2) {
                if (depth <= 0 || !isObject$1(value) || value["__v_skip"]) {
                    return value;
                }
                seen2 = seen2 || new Map();
                if ((seen2.get(value) || 0) >= depth) {
                    return value;
                }
                seen2.set(value, depth);
                depth--;
                if (isRef(value)) {
                    traverse(value.value, depth, seen2);
                } else if (isArray$2(value)) {
                    for(let i = 0; i < value.length; i++){
                        traverse(value[i], depth, seen2);
                    }
                } else if (isSet(value) || isMap(value)) {
                    value.forEach((v)=>{
                        traverse(v, depth, seen2);
                    });
                } else if (isPlainObject$1(value)) {
                    for(const key in value){
                        traverse(value[key], depth, seen2);
                    }
                    for (const key of Object.getOwnPropertySymbols(value)){
                        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
                            traverse(value[key], depth, seen2);
                        }
                    }
                }
                return value;
            }
            const stack = [];
            let isWarning = false;
            function warn$1(msg, ...args) {
                if (isWarning) return;
                isWarning = true;
                pauseTracking();
                const instance = stack.length ? stack[stack.length - 1].component : null;
                const appWarnHandler = instance && instance.appContext.config.warnHandler;
                const trace = getComponentTrace();
                if (appWarnHandler) {
                    callWithErrorHandling(appWarnHandler, instance, 11, [
                        msg + args.map((a)=>{
                            var _a, _b;
                            return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);
                        }).join(""),
                        instance && instance.proxy,
                        trace.map(({ vnode })=>`at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
                        trace
                    ]);
                } else {
                    const warnArgs = [
                        `[Vue warn]: ${msg}`,
                        ...args
                    ];
                    if (trace.length && true) {
                        warnArgs.push(`
`, ...formatTrace(trace));
                    }
                    console.warn(...warnArgs);
                }
                resetTracking();
                isWarning = false;
            }
            function getComponentTrace() {
                let currentVNode = stack[stack.length - 1];
                if (!currentVNode) {
                    return [];
                }
                const normalizedStack = [];
                while(currentVNode){
                    const last = normalizedStack[0];
                    if (last && last.vnode === currentVNode) {
                        last.recurseCount++;
                    } else {
                        normalizedStack.push({
                            vnode: currentVNode,
                            recurseCount: 0
                        });
                    }
                    const parentInstance = currentVNode.component && currentVNode.component.parent;
                    currentVNode = parentInstance && parentInstance.vnode;
                }
                return normalizedStack;
            }
            function formatTrace(trace) {
                const logs = [];
                trace.forEach((entry, i)=>{
                    logs.push(...i === 0 ? [] : [
                        `
`
                    ], ...formatTraceEntry(entry));
                });
                return logs;
            }
            function formatTraceEntry({ vnode, recurseCount }) {
                const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
                const isRoot = vnode.component ? vnode.component.parent == null : false;
                const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
                const close = `>` + postfix;
                return vnode.props ? [
                    open,
                    ...formatProps(vnode.props),
                    close
                ] : [
                    open + close
                ];
            }
            function formatProps(props) {
                const res = [];
                const keys = Object.keys(props);
                keys.slice(0, 3).forEach((key)=>{
                    res.push(...formatProp(key, props[key]));
                });
                if (keys.length > 3) {
                    res.push(` ...`);
                }
                return res;
            }
            function formatProp(key, value, raw) {
                if (isString$1(value)) {
                    value = JSON.stringify(value);
                    return raw ? value : [
                        `${key}=${value}`
                    ];
                } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
                    return raw ? value : [
                        `${key}=${value}`
                    ];
                } else if (isRef(value)) {
                    value = formatProp(key, toRaw(value.value), true);
                    return raw ? value : [
                        `${key}=Ref<`,
                        value,
                        `>`
                    ];
                } else if (isFunction$2(value)) {
                    return [
                        `${key}=fn${value.name ? `<${value.name}>` : ``}`
                    ];
                } else {
                    value = toRaw(value);
                    return raw ? value : [
                        `${key}=`,
                        value
                    ];
                }
            }
            function callWithErrorHandling(fn, instance, type, args) {
                try {
                    return args ? fn(...args) : fn();
                } catch (err) {
                    handleError(err, instance, type);
                }
            }
            function callWithAsyncErrorHandling(fn, instance, type, args) {
                if (isFunction$2(fn)) {
                    const res = callWithErrorHandling(fn, instance, type, args);
                    if (res && isPromise(res)) {
                        res.catch((err)=>{
                            handleError(err, instance, type);
                        });
                    }
                    return res;
                }
                if (isArray$2(fn)) {
                    const values = [];
                    for(let i = 0; i < fn.length; i++){
                        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
                    }
                    return values;
                }
            }
            function handleError(err, instance, type, throwInDev = true) {
                const contextVNode = instance ? instance.vnode : null;
                const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
                if (instance) {
                    let cur = instance.parent;
                    const exposedInstance = instance.proxy;
                    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
                    while(cur){
                        const errorCapturedHooks = cur.ec;
                        if (errorCapturedHooks) {
                            for(let i = 0; i < errorCapturedHooks.length; i++){
                                if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                                    return;
                                }
                            }
                        }
                        cur = cur.parent;
                    }
                    if (errorHandler) {
                        pauseTracking();
                        callWithErrorHandling(errorHandler, null, 10, [
                            err,
                            exposedInstance,
                            errorInfo
                        ]);
                        resetTracking();
                        return;
                    }
                }
                logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
            }
            function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
                if (throwInProd) {
                    throw err;
                } else {
                    console.error(err);
                }
            }
            const queue = [];
            let flushIndex = -1;
            const pendingPostFlushCbs = [];
            let activePostFlushCbs = null;
            let postFlushIndex = 0;
            const resolvedPromise = Promise.resolve();
            let currentFlushPromise = null;
            function nextTick(fn) {
                const p2 = currentFlushPromise || resolvedPromise;
                return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
            }
            function findInsertionIndex$1(id) {
                let start2 = flushIndex + 1;
                let end2 = queue.length;
                while(start2 < end2){
                    const middle = start2 + end2 >>> 1;
                    const middleJob = queue[middle];
                    const middleJobId = getId(middleJob);
                    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
                        start2 = middle + 1;
                    } else {
                        end2 = middle;
                    }
                }
                return start2;
            }
            function queueJob(job) {
                if (!(job.flags & 1)) {
                    const jobId = getId(job);
                    const lastJob = queue[queue.length - 1];
                    if (!lastJob || !(job.flags & 2) && jobId >= getId(lastJob)) {
                        queue.push(job);
                    } else {
                        queue.splice(findInsertionIndex$1(jobId), 0, job);
                    }
                    job.flags |= 1;
                    queueFlush();
                }
            }
            function queueFlush() {
                if (!currentFlushPromise) {
                    currentFlushPromise = resolvedPromise.then(flushJobs);
                }
            }
            function queuePostFlushCb(cb) {
                if (!isArray$2(cb)) {
                    if (activePostFlushCbs && cb.id === -1) {
                        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
                    } else if (!(cb.flags & 1)) {
                        pendingPostFlushCbs.push(cb);
                        cb.flags |= 1;
                    }
                } else {
                    pendingPostFlushCbs.push(...cb);
                }
                queueFlush();
            }
            function flushPreFlushCbs(instance, seen2, i = flushIndex + 1) {
                for(; i < queue.length; i++){
                    const cb = queue[i];
                    if (cb && cb.flags & 2) {
                        if (instance && cb.id !== instance.uid) {
                            continue;
                        }
                        queue.splice(i, 1);
                        i--;
                        if (cb.flags & 4) {
                            cb.flags &= -2;
                        }
                        cb();
                        if (!(cb.flags & 4)) {
                            cb.flags &= -2;
                        }
                    }
                }
            }
            function flushPostFlushCbs(seen2) {
                if (pendingPostFlushCbs.length) {
                    const deduped = [
                        ...new Set(pendingPostFlushCbs)
                    ].sort((a, b)=>getId(a) - getId(b));
                    pendingPostFlushCbs.length = 0;
                    if (activePostFlushCbs) {
                        activePostFlushCbs.push(...deduped);
                        return;
                    }
                    activePostFlushCbs = deduped;
                    for(postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++){
                        const cb = activePostFlushCbs[postFlushIndex];
                        if (cb.flags & 4) {
                            cb.flags &= -2;
                        }
                        if (!(cb.flags & 8)) cb();
                        cb.flags &= -2;
                    }
                    activePostFlushCbs = null;
                    postFlushIndex = 0;
                }
            }
            const getId = (job)=>job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
            function flushJobs(seen2) {
                try {
                    for(flushIndex = 0; flushIndex < queue.length; flushIndex++){
                        const job = queue[flushIndex];
                        if (job && !(job.flags & 8)) {
                            if (false) ;
                            if (job.flags & 4) {
                                job.flags &= ~1;
                            }
                            callWithErrorHandling(job, job.i, job.i ? 15 : 14);
                            if (!(job.flags & 4)) {
                                job.flags &= ~1;
                            }
                        }
                    }
                } finally{
                    for(; flushIndex < queue.length; flushIndex++){
                        const job = queue[flushIndex];
                        if (job) {
                            job.flags &= -2;
                        }
                    }
                    flushIndex = -1;
                    queue.length = 0;
                    flushPostFlushCbs();
                    currentFlushPromise = null;
                    if (queue.length || pendingPostFlushCbs.length) {
                        flushJobs();
                    }
                }
            }
            let currentRenderingInstance = null;
            let currentScopeId = null;
            function setCurrentRenderingInstance(instance) {
                const prev = currentRenderingInstance;
                currentRenderingInstance = instance;
                currentScopeId = instance && instance.type.__scopeId || null;
                return prev;
            }
            function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
                if (!ctx) return fn;
                if (fn._n) {
                    return fn;
                }
                const renderFnWithContext = (...args)=>{
                    if (renderFnWithContext._d) {
                        setBlockTracking(-1);
                    }
                    const prevInstance = setCurrentRenderingInstance(ctx);
                    let res;
                    try {
                        res = fn(...args);
                    } finally{
                        setCurrentRenderingInstance(prevInstance);
                        if (renderFnWithContext._d) {
                            setBlockTracking(1);
                        }
                    }
                    return res;
                };
                renderFnWithContext._n = true;
                renderFnWithContext._c = true;
                renderFnWithContext._d = true;
                return renderFnWithContext;
            }
            function invokeDirectiveHook(vnode, prevVNode, instance, name) {
                const bindings = vnode.dirs;
                const oldBindings = prevVNode && prevVNode.dirs;
                for(let i = 0; i < bindings.length; i++){
                    const binding = bindings[i];
                    if (oldBindings) {
                        binding.oldValue = oldBindings[i].value;
                    }
                    let hook = binding.dir[name];
                    if (hook) {
                        pauseTracking();
                        callWithAsyncErrorHandling(hook, instance, 8, [
                            vnode.el,
                            binding,
                            vnode,
                            prevVNode
                        ]);
                        resetTracking();
                    }
                }
            }
            const TeleportEndKey = Symbol("_vte");
            const isTeleport = (type)=>type.__isTeleport;
            const isTeleportDisabled = (props)=>props && (props.disabled || props.disabled === "");
            const isTeleportDeferred = (props)=>props && (props.defer || props.defer === "");
            const isTargetSVG = (target)=>typeof SVGElement !== "undefined" && target instanceof SVGElement;
            const isTargetMathML = (target)=>typeof MathMLElement === "function" && target instanceof MathMLElement;
            const resolveTarget = (props, select)=>{
                const targetSelector = props && props.to;
                if (isString$1(targetSelector)) {
                    if (!select) {
                        return null;
                    } else {
                        const target = select(targetSelector);
                        return target;
                    }
                } else {
                    return targetSelector;
                }
            };
            const TeleportImpl = {
                name: "Teleport",
                __isTeleport: true,
                process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
                    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
                    const disabled2 = isTeleportDisabled(n2.props);
                    let { shapeFlag, children, dynamicChildren } = n2;
                    if (n1 == null) {
                        const placeholder = n2.el = createText("");
                        const mainAnchor = n2.anchor = createText("");
                        insert(placeholder, container, anchor);
                        insert(mainAnchor, container, anchor);
                        const mount = (container2, anchor2)=>{
                            if (shapeFlag & 16) {
                                if (parentComponent && parentComponent.isCE) {
                                    parentComponent.ce._teleportTarget = container2;
                                }
                                mountChildren(children, container2, anchor2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            }
                        };
                        const mountToTarget = ()=>{
                            const target = n2.target = resolveTarget(n2.props, querySelector);
                            const targetAnchor = prepareAnchor(target, n2, createText, insert);
                            if (target) {
                                if (namespace2 !== "svg" && isTargetSVG(target)) {
                                    namespace2 = "svg";
                                } else if (namespace2 !== "mathml" && isTargetMathML(target)) {
                                    namespace2 = "mathml";
                                }
                                if (!disabled2) {
                                    mount(target, targetAnchor);
                                    updateCssVars(n2, false);
                                }
                            }
                        };
                        if (disabled2) {
                            mount(container, mainAnchor);
                            updateCssVars(n2, true);
                        }
                        if (isTeleportDeferred(n2.props)) {
                            n2.el.__isMounted = false;
                            queuePostRenderEffect(()=>{
                                mountToTarget();
                                delete n2.el.__isMounted;
                            }, parentSuspense);
                        } else {
                            mountToTarget();
                        }
                    } else {
                        if (isTeleportDeferred(n2.props) && n1.el.__isMounted === false) {
                            queuePostRenderEffect(()=>{
                                TeleportImpl.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals);
                            }, parentSuspense);
                            return;
                        }
                        n2.el = n1.el;
                        n2.targetStart = n1.targetStart;
                        const mainAnchor = n2.anchor = n1.anchor;
                        const target = n2.target = n1.target;
                        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
                        const wasDisabled = isTeleportDisabled(n1.props);
                        const currentContainer = wasDisabled ? container : target;
                        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
                        if (namespace2 === "svg" || isTargetSVG(target)) {
                            namespace2 = "svg";
                        } else if (namespace2 === "mathml" || isTargetMathML(target)) {
                            namespace2 = "mathml";
                        }
                        if (dynamicChildren) {
                            patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, namespace2, slotScopeIds);
                            traverseStaticChildren(n1, n2, true);
                        } else if (!optimized) {
                            patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, false);
                        }
                        if (disabled2) {
                            if (!wasDisabled) {
                                moveTeleport(n2, container, mainAnchor, internals, 1);
                            } else {
                                if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                                    n2.props.to = n1.props.to;
                                }
                            }
                        } else {
                            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                                const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                                if (nextTarget) {
                                    moveTeleport(n2, nextTarget, null, internals, 0);
                                }
                            } else if (wasDisabled) {
                                moveTeleport(n2, target, targetAnchor, internals, 1);
                            }
                        }
                        updateCssVars(n2, disabled2);
                    }
                },
                remove (vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
                    const { shapeFlag, children, anchor, targetStart, targetAnchor, target, props } = vnode;
                    if (target) {
                        hostRemove(targetStart);
                        hostRemove(targetAnchor);
                    }
                    doRemove && hostRemove(anchor);
                    if (shapeFlag & 16) {
                        const shouldRemove = doRemove || !isTeleportDisabled(props);
                        for(let i = 0; i < children.length; i++){
                            const child = children[i];
                            unmount(child, parentComponent, parentSuspense, shouldRemove, !!child.dynamicChildren);
                        }
                    }
                },
                move: moveTeleport,
                hydrate: hydrateTeleport
            };
            function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
                if (moveType === 0) {
                    insert(vnode.targetAnchor, container, parentAnchor);
                }
                const { el, anchor, shapeFlag, children, props } = vnode;
                const isReorder = moveType === 2;
                if (isReorder) {
                    insert(el, container, parentAnchor);
                }
                if (!isReorder || isTeleportDisabled(props)) {
                    if (shapeFlag & 16) {
                        for(let i = 0; i < children.length; i++){
                            move(children[i], container, parentAnchor, 2);
                        }
                    }
                }
                if (isReorder) {
                    insert(anchor, container, parentAnchor);
                }
            }
            function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector, insert, createText } }, hydrateChildren) {
                function hydrateDisabledTeleport(node2, vnode2, targetStart, targetAnchor) {
                    vnode2.anchor = hydrateChildren(nextSibling(node2), vnode2, parentNode(node2), parentComponent, parentSuspense, slotScopeIds, optimized);
                    vnode2.targetStart = targetStart;
                    vnode2.targetAnchor = targetAnchor;
                }
                const target = vnode.target = resolveTarget(vnode.props, querySelector);
                const disabled2 = isTeleportDisabled(vnode.props);
                if (target) {
                    const targetNode = target._lpa || target.firstChild;
                    if (vnode.shapeFlag & 16) {
                        if (disabled2) {
                            hydrateDisabledTeleport(node, vnode, targetNode, targetNode && nextSibling(targetNode));
                        } else {
                            vnode.anchor = nextSibling(node);
                            let targetAnchor = targetNode;
                            while(targetAnchor){
                                if (targetAnchor && targetAnchor.nodeType === 8) {
                                    if (targetAnchor.data === "teleport start anchor") {
                                        vnode.targetStart = targetAnchor;
                                    } else if (targetAnchor.data === "teleport anchor") {
                                        vnode.targetAnchor = targetAnchor;
                                        target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                                        break;
                                    }
                                }
                                targetAnchor = nextSibling(targetAnchor);
                            }
                            if (!vnode.targetAnchor) {
                                prepareAnchor(target, vnode, createText, insert);
                            }
                            hydrateChildren(targetNode && nextSibling(targetNode), vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
                        }
                    }
                    updateCssVars(vnode, disabled2);
                } else if (disabled2) {
                    if (vnode.shapeFlag & 16) {
                        hydrateDisabledTeleport(node, vnode, node, nextSibling(node));
                    }
                }
                return vnode.anchor && nextSibling(vnode.anchor);
            }
            const Teleport = exports("T", TeleportImpl);
            function updateCssVars(vnode, isDisabled) {
                const ctx = vnode.ctx;
                if (ctx && ctx.ut) {
                    let node, anchor;
                    if (isDisabled) {
                        node = vnode.el;
                        anchor = vnode.anchor;
                    } else {
                        node = vnode.targetStart;
                        anchor = vnode.targetAnchor;
                    }
                    while(node && node !== anchor){
                        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
                        node = node.nextSibling;
                    }
                    ctx.ut();
                }
            }
            function prepareAnchor(target, vnode, createText, insert) {
                const targetStart = vnode.targetStart = createText("");
                const targetAnchor = vnode.targetAnchor = createText("");
                targetStart[TeleportEndKey] = targetAnchor;
                if (target) {
                    insert(targetStart, target);
                    insert(targetAnchor, target);
                }
                return targetAnchor;
            }
            const leaveCbKey = Symbol("_leaveCb");
            const enterCbKey = Symbol("_enterCb");
            function useTransitionState() {
                const state = {
                    isMounted: false,
                    isLeaving: false,
                    isUnmounting: false,
                    leavingVNodes: new Map()
                };
                onMounted(()=>{
                    state.isMounted = true;
                });
                onBeforeUnmount(()=>{
                    state.isUnmounting = true;
                });
                return state;
            }
            const TransitionHookValidator = [
                Function,
                Array
            ];
            const BaseTransitionPropsValidators = {
                mode: String,
                appear: Boolean,
                persisted: Boolean,
                onBeforeEnter: TransitionHookValidator,
                onEnter: TransitionHookValidator,
                onAfterEnter: TransitionHookValidator,
                onEnterCancelled: TransitionHookValidator,
                onBeforeLeave: TransitionHookValidator,
                onLeave: TransitionHookValidator,
                onAfterLeave: TransitionHookValidator,
                onLeaveCancelled: TransitionHookValidator,
                onBeforeAppear: TransitionHookValidator,
                onAppear: TransitionHookValidator,
                onAfterAppear: TransitionHookValidator,
                onAppearCancelled: TransitionHookValidator
            };
            const recursiveGetSubtree = (instance)=>{
                const subTree = instance.subTree;
                return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
            };
            const BaseTransitionImpl = {
                name: `BaseTransition`,
                props: BaseTransitionPropsValidators,
                setup (props, { slots }) {
                    const instance = getCurrentInstance();
                    const state = useTransitionState();
                    return ()=>{
                        const children = slots.default && getTransitionRawChildren(slots.default(), true);
                        if (!children || !children.length) {
                            return;
                        }
                        const child = findNonCommentChild(children);
                        const rawProps = toRaw(props);
                        const { mode } = rawProps;
                        if (state.isLeaving) {
                            return emptyPlaceholder(child);
                        }
                        const innerChild = getInnerChild$1(child);
                        if (!innerChild) {
                            return emptyPlaceholder(child);
                        }
                        let enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance, (hooks)=>enterHooks = hooks);
                        if (innerChild.type !== Comment) {
                            setTransitionHooks(innerChild, enterHooks);
                        }
                        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
                        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(oldInnerChild, innerChild) && recursiveGetSubtree(instance).type !== Comment) {
                            let leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
                            setTransitionHooks(oldInnerChild, leavingHooks);
                            if (mode === "out-in" && innerChild.type !== Comment) {
                                state.isLeaving = true;
                                leavingHooks.afterLeave = ()=>{
                                    state.isLeaving = false;
                                    if (!(instance.job.flags & 8)) {
                                        instance.update();
                                    }
                                    delete leavingHooks.afterLeave;
                                    oldInnerChild = void 0;
                                };
                                return emptyPlaceholder(child);
                            } else if (mode === "in-out" && innerChild.type !== Comment) {
                                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave)=>{
                                    const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                                    leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                                    el[leaveCbKey] = ()=>{
                                        earlyRemove();
                                        el[leaveCbKey] = void 0;
                                        delete enterHooks.delayedLeave;
                                        oldInnerChild = void 0;
                                    };
                                    enterHooks.delayedLeave = ()=>{
                                        delayedLeave();
                                        delete enterHooks.delayedLeave;
                                        oldInnerChild = void 0;
                                    };
                                };
                            } else {
                                oldInnerChild = void 0;
                            }
                        } else if (oldInnerChild) {
                            oldInnerChild = void 0;
                        }
                        return child;
                    };
                }
            };
            function findNonCommentChild(children) {
                let child = children[0];
                if (children.length > 1) {
                    for (const c of children){
                        if (c.type !== Comment) {
                            child = c;
                            break;
                        }
                    }
                }
                return child;
            }
            const BaseTransition = BaseTransitionImpl;
            function getLeavingNodesForType(state, vnode) {
                const { leavingVNodes } = state;
                let leavingVNodesCache = leavingVNodes.get(vnode.type);
                if (!leavingVNodesCache) {
                    leavingVNodesCache = Object.create(null);
                    leavingVNodes.set(vnode.type, leavingVNodesCache);
                }
                return leavingVNodesCache;
            }
            function resolveTransitionHooks(vnode, props, state, instance, postClone) {
                const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
                const key = String(vnode.key);
                const leavingVNodesCache = getLeavingNodesForType(state, vnode);
                const callHook2 = (hook, args)=>{
                    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
                };
                const callAsyncHook = (hook, args)=>{
                    const done = args[1];
                    callHook2(hook, args);
                    if (isArray$2(hook)) {
                        if (hook.every((hook2)=>hook2.length <= 1)) done();
                    } else if (hook.length <= 1) {
                        done();
                    }
                };
                const hooks = {
                    mode,
                    persisted,
                    beforeEnter (el) {
                        let hook = onBeforeEnter;
                        if (!state.isMounted) {
                            if (appear) {
                                hook = onBeforeAppear || onBeforeEnter;
                            } else {
                                return;
                            }
                        }
                        if (el[leaveCbKey]) {
                            el[leaveCbKey](true);
                        }
                        const leavingVNode = leavingVNodesCache[key];
                        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
                            leavingVNode.el[leaveCbKey]();
                        }
                        callHook2(hook, [
                            el
                        ]);
                    },
                    enter (el) {
                        let hook = onEnter;
                        let afterHook = onAfterEnter;
                        let cancelHook = onEnterCancelled;
                        if (!state.isMounted) {
                            if (appear) {
                                hook = onAppear || onEnter;
                                afterHook = onAfterAppear || onAfterEnter;
                                cancelHook = onAppearCancelled || onEnterCancelled;
                            } else {
                                return;
                            }
                        }
                        let called = false;
                        const done = el[enterCbKey] = (cancelled)=>{
                            if (called) return;
                            called = true;
                            if (cancelled) {
                                callHook2(cancelHook, [
                                    el
                                ]);
                            } else {
                                callHook2(afterHook, [
                                    el
                                ]);
                            }
                            if (hooks.delayedLeave) {
                                hooks.delayedLeave();
                            }
                            el[enterCbKey] = void 0;
                        };
                        if (hook) {
                            callAsyncHook(hook, [
                                el,
                                done
                            ]);
                        } else {
                            done();
                        }
                    },
                    leave (el, remove2) {
                        const key2 = String(vnode.key);
                        if (el[enterCbKey]) {
                            el[enterCbKey](true);
                        }
                        if (state.isUnmounting) {
                            return remove2();
                        }
                        callHook2(onBeforeLeave, [
                            el
                        ]);
                        let called = false;
                        const done = el[leaveCbKey] = (cancelled)=>{
                            if (called) return;
                            called = true;
                            remove2();
                            if (cancelled) {
                                callHook2(onLeaveCancelled, [
                                    el
                                ]);
                            } else {
                                callHook2(onAfterLeave, [
                                    el
                                ]);
                            }
                            el[leaveCbKey] = void 0;
                            if (leavingVNodesCache[key2] === vnode) {
                                delete leavingVNodesCache[key2];
                            }
                        };
                        leavingVNodesCache[key2] = vnode;
                        if (onLeave) {
                            callAsyncHook(onLeave, [
                                el,
                                done
                            ]);
                        } else {
                            done();
                        }
                    },
                    clone (vnode2) {
                        const hooks2 = resolveTransitionHooks(vnode2, props, state, instance, postClone);
                        if (postClone) postClone(hooks2);
                        return hooks2;
                    }
                };
                return hooks;
            }
            function emptyPlaceholder(vnode) {
                if (isKeepAlive(vnode)) {
                    vnode = cloneVNode(vnode);
                    vnode.children = null;
                    return vnode;
                }
            }
            function getInnerChild$1(vnode) {
                if (!isKeepAlive(vnode)) {
                    if (isTeleport(vnode.type) && vnode.children) {
                        return findNonCommentChild(vnode.children);
                    }
                    return vnode;
                }
                if (vnode.component) {
                    return vnode.component.subTree;
                }
                const { shapeFlag, children } = vnode;
                if (children) {
                    if (shapeFlag & 16) {
                        return children[0];
                    }
                    if (shapeFlag & 32 && isFunction$2(children.default)) {
                        return children.default();
                    }
                }
            }
            function setTransitionHooks(vnode, hooks) {
                if (vnode.shapeFlag & 6 && vnode.component) {
                    vnode.transition = hooks;
                    setTransitionHooks(vnode.component.subTree, hooks);
                } else if (vnode.shapeFlag & 128) {
                    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
                    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
                } else {
                    vnode.transition = hooks;
                }
            }
            function getTransitionRawChildren(children, keepComment = false, parentKey) {
                let ret = [];
                let keyedFragmentCount = 0;
                for(let i = 0; i < children.length; i++){
                    let child = children[i];
                    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
                    if (child.type === Fragment) {
                        if (child.patchFlag & 128) keyedFragmentCount++;
                        ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
                    } else if (keepComment || child.type !== Comment) {
                        ret.push(key != null ? cloneVNode(child, {
                            key
                        }) : child);
                    }
                }
                if (keyedFragmentCount > 1) {
                    for(let i = 0; i < ret.length; i++){
                        ret[i].patchFlag = -2;
                    }
                }
                return ret;
            }
            function defineComponent(options, extraOptions) {
                return isFunction$2(options) ? ((()=>extend$1({
                        name: options.name
                    }, extraOptions, {
                        setup: options
                    }))()) : options;
            }
            function markAsyncBoundary(instance) {
                instance.ids = [
                    instance.ids[0] + instance.ids[2]++ + "-",
                    0,
                    0
                ];
            }
            const pendingSetRefMap = new WeakMap();
            function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
                if (isArray$2(rawRef)) {
                    rawRef.forEach((r2, i)=>setRef(r2, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
                    return;
                }
                if (isAsyncWrapper(vnode) && !isUnmount) {
                    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
                        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
                    }
                    return;
                }
                const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
                const value = isUnmount ? null : refValue;
                const { i: owner, r: ref3 } = rawRef;
                const oldRef = oldRawRef && oldRawRef.r;
                const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
                const setupState = owner.setupState;
                const rawSetupState = toRaw(setupState);
                const canSetSetupRef = setupState === EMPTY_OBJ ? NO : (key)=>{
                    return hasOwn(rawSetupState, key);
                };
                if (oldRef != null && oldRef !== ref3) {
                    invalidatePendingSetRef(oldRawRef);
                    if (isString$1(oldRef)) {
                        refs[oldRef] = null;
                        if (canSetSetupRef(oldRef)) {
                            setupState[oldRef] = null;
                        }
                    } else if (isRef(oldRef)) {
                        {
                            oldRef.value = null;
                        }
                        const oldRawRefAtom = oldRawRef;
                        if (oldRawRefAtom.k) refs[oldRawRefAtom.k] = null;
                    }
                }
                if (isFunction$2(ref3)) {
                    callWithErrorHandling(ref3, owner, 12, [
                        value,
                        refs
                    ]);
                } else {
                    const _isString = isString$1(ref3);
                    const _isRef = isRef(ref3);
                    if (_isString || _isRef) {
                        const doSet = ()=>{
                            if (rawRef.f) {
                                const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
                                if (isUnmount) {
                                    isArray$2(existing) && remove(existing, refValue);
                                } else {
                                    if (!isArray$2(existing)) {
                                        if (_isString) {
                                            refs[ref3] = [
                                                refValue
                                            ];
                                            if (canSetSetupRef(ref3)) {
                                                setupState[ref3] = refs[ref3];
                                            }
                                        } else {
                                            const newVal = [
                                                refValue
                                            ];
                                            {
                                                ref3.value = newVal;
                                            }
                                            if (rawRef.k) refs[rawRef.k] = newVal;
                                        }
                                    } else if (!existing.includes(refValue)) {
                                        existing.push(refValue);
                                    }
                                }
                            } else if (_isString) {
                                refs[ref3] = value;
                                if (canSetSetupRef(ref3)) {
                                    setupState[ref3] = value;
                                }
                            } else if (_isRef) {
                                {
                                    ref3.value = value;
                                }
                                if (rawRef.k) refs[rawRef.k] = value;
                            } else ;
                        };
                        if (value) {
                            const job = ()=>{
                                doSet();
                                pendingSetRefMap.delete(rawRef);
                            };
                            job.id = -1;
                            pendingSetRefMap.set(rawRef, job);
                            queuePostRenderEffect(job, parentSuspense);
                        } else {
                            invalidatePendingSetRef(rawRef);
                            doSet();
                        }
                    }
                }
            }
            function invalidatePendingSetRef(rawRef) {
                const pendingSetRef = pendingSetRefMap.get(rawRef);
                if (pendingSetRef) {
                    pendingSetRef.flags |= 8;
                    pendingSetRefMap.delete(rawRef);
                }
            }
            getGlobalThis().requestIdleCallback || ((cb)=>setTimeout(cb, 1));
            getGlobalThis().cancelIdleCallback || ((id)=>clearTimeout(id));
            const isAsyncWrapper = (i)=>!!i.type.__asyncLoader;
            const isKeepAlive = (vnode)=>vnode.type.__isKeepAlive;
            function onActivated(hook, target) {
                registerKeepAliveHook(hook, "a", target);
            }
            function onDeactivated(hook, target) {
                registerKeepAliveHook(hook, "da", target);
            }
            function registerKeepAliveHook(hook, type, target = currentInstance) {
                const wrappedHook = hook.__wdc || (hook.__wdc = ()=>{
                    let current = target;
                    while(current){
                        if (current.isDeactivated) {
                            return;
                        }
                        current = current.parent;
                    }
                    return hook();
                });
                injectHook(type, wrappedHook, target);
                if (target) {
                    let current = target.parent;
                    while(current && current.parent){
                        if (isKeepAlive(current.parent.vnode)) {
                            injectToKeepAliveRoot(wrappedHook, type, target, current);
                        }
                        current = current.parent;
                    }
                }
            }
            function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
                const injected = injectHook(type, hook, keepAliveRoot, true);
                onUnmounted(()=>{
                    remove(keepAliveRoot[type], injected);
                }, target);
            }
            function injectHook(type, hook, target = currentInstance, prepend = false) {
                if (target) {
                    const hooks = target[type] || (target[type] = []);
                    const wrappedHook = hook.__weh || (hook.__weh = (...args)=>{
                        pauseTracking();
                        const reset = setCurrentInstance(target);
                        const res = callWithAsyncErrorHandling(hook, target, type, args);
                        reset();
                        resetTracking();
                        return res;
                    });
                    if (prepend) {
                        hooks.unshift(wrappedHook);
                    } else {
                        hooks.push(wrappedHook);
                    }
                    return wrappedHook;
                }
            }
            const createHook = (lifecycle)=>(hook, target = currentInstance)=>{
                    if (!isInSSRComponentSetup || lifecycle === "sp") {
                        injectHook(lifecycle, (...args)=>hook(...args), target);
                    }
                };
            const onBeforeMount = createHook("bm");
            const onMounted = exports("o", createHook("m"));
            const onBeforeUpdate = createHook("bu");
            const onUpdated = createHook("u");
            const onBeforeUnmount = createHook("bum");
            const onUnmounted = createHook("um");
            const onServerPrefetch = createHook("sp");
            const onRenderTriggered = createHook("rtg");
            const onRenderTracked = createHook("rtc");
            function onErrorCaptured(hook, target = currentInstance) {
                injectHook("ec", hook, target);
            }
            const COMPONENTS = "components";
            function resolveComponent(name, maybeSelfReference) {
                return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
            }
            const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
            function resolveDynamicComponent(component) {
                if (isString$1(component)) {
                    return resolveAsset(COMPONENTS, component, false) || component;
                } else {
                    return component || NULL_DYNAMIC_COMPONENT;
                }
            }
            function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
                const instance = currentRenderingInstance || currentInstance;
                if (instance) {
                    const Component = instance.type;
                    {
                        const selfName = getComponentName(Component, false);
                        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
                            return Component;
                        }
                    }
                    const res = (resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name));
                    if (!res && maybeSelfReference) {
                        return Component;
                    }
                    return res;
                }
            }
            function resolve(registry, name) {
                return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
            }
            function renderList(source, renderItem, cache, index) {
                let ret;
                const cached = cache;
                const sourceIsArray = isArray$2(source);
                if (sourceIsArray || isString$1(source)) {
                    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
                    let needsWrap = false;
                    let isReadonlySource = false;
                    if (sourceIsReactiveArray) {
                        needsWrap = !isShallow(source);
                        isReadonlySource = isReadonly(source);
                        source = shallowReadArray(source);
                    }
                    ret = new Array(source.length);
                    for(let i = 0, l = source.length; i < l; i++){
                        ret[i] = renderItem(needsWrap ? isReadonlySource ? toReadonly(toReactive(source[i])) : toReactive(source[i]) : source[i], i, void 0, cached);
                    }
                } else if (typeof source === "number") {
                    ret = new Array(source);
                    for(let i = 0; i < source; i++){
                        ret[i] = renderItem(i + 1, i, void 0, cached);
                    }
                } else if (isObject$1(source)) {
                    if (source[Symbol.iterator]) {
                        ret = Array.from(source, (item, i)=>renderItem(item, i, void 0, cached));
                    } else {
                        const keys = Object.keys(source);
                        ret = new Array(keys.length);
                        for(let i = 0, l = keys.length; i < l; i++){
                            const key = keys[i];
                            ret[i] = renderItem(source[key], key, i, cached);
                        }
                    }
                } else {
                    ret = [];
                }
                return ret;
            }
            function renderSlot(slots, name, props = {}, fallback, noSlotted) {
                if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
                    if (name !== "default") props.name = name;
                    return openBlock(), createBlock(Fragment, null, [
                        createVNode("slot", props, fallback && fallback())
                    ], 64);
                }
                let slot = slots[name];
                if (slot && slot._c) {
                    slot._d = false;
                }
                openBlock();
                const validSlotContent = slot && ensureValidVNode(slot(props));
                const slotKey = props.key || validSlotContent && validSlotContent.key;
                const rendered = createBlock(Fragment, {
                    key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + (!validSlotContent && fallback ? "_fb" : "")
                }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
                if (rendered.scopeId) {
                    rendered.slotScopeIds = [
                        rendered.scopeId + "-s"
                    ];
                }
                if (slot && slot._c) {
                    slot._d = true;
                }
                return rendered;
            }
            function ensureValidVNode(vnodes) {
                return vnodes.some((child)=>{
                    if (!isVNode(child)) return true;
                    if (child.type === Comment) return false;
                    if (child.type === Fragment && !ensureValidVNode(child.children)) return false;
                    return true;
                }) ? vnodes : null;
            }
            const getPublicInstance = (i)=>{
                if (!i) return null;
                if (isStatefulComponent(i)) return getComponentPublicInstance(i);
                return getPublicInstance(i.parent);
            };
            const publicPropertiesMap = (extend$1(Object.create(null), {
                $: (i)=>i,
                $el: (i)=>i.vnode.el,
                $data: (i)=>i.data,
                $props: (i)=>i.props,
                $attrs: (i)=>i.attrs,
                $slots: (i)=>i.slots,
                $refs: (i)=>i.refs,
                $parent: (i)=>getPublicInstance(i.parent),
                $root: (i)=>getPublicInstance(i.root),
                $host: (i)=>i.ce,
                $emit: (i)=>i.emit,
                $options: (i)=>resolveMergedOptions(i),
                $forceUpdate: (i)=>i.f || (i.f = ()=>{
                        queueJob(i.update);
                    }),
                $nextTick: (i)=>i.n || (i.n = nextTick.bind(i.proxy)),
                $watch: (i)=>instanceWatch.bind(i)
            }));
            const hasSetupBinding = (state, key)=>state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
            const PublicInstanceProxyHandlers = {
                get ({ _: instance }, key) {
                    if (key === "__v_skip") {
                        return true;
                    }
                    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
                    let normalizedProps;
                    if (key[0] !== "$") {
                        const n = accessCache[key];
                        if (n !== void 0) {
                            switch(n){
                                case 1:
                                    return setupState[key];
                                case 2:
                                    return data[key];
                                case 4:
                                    return ctx[key];
                                case 3:
                                    return props[key];
                            }
                        } else if (hasSetupBinding(setupState, key)) {
                            accessCache[key] = 1;
                            return setupState[key];
                        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                            accessCache[key] = 2;
                            return data[key];
                        } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
                            accessCache[key] = 3;
                            return props[key];
                        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                            accessCache[key] = 4;
                            return ctx[key];
                        } else if (shouldCacheAccess) {
                            accessCache[key] = 0;
                        }
                    }
                    const publicGetter = publicPropertiesMap[key];
                    let cssModule, globalProperties;
                    if (publicGetter) {
                        if (key === "$attrs") {
                            track(instance.attrs, "get", "");
                        }
                        return publicGetter(instance);
                    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
                        return cssModule;
                    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
                        accessCache[key] = 4;
                        return ctx[key];
                    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
                        {
                            return globalProperties[key];
                        }
                    } else ;
                },
                set ({ _: instance }, key, value) {
                    const { data, setupState, ctx } = instance;
                    if (hasSetupBinding(setupState, key)) {
                        setupState[key] = value;
                        return true;
                    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
                        data[key] = value;
                        return true;
                    } else if (hasOwn(instance.props, key)) {
                        return false;
                    }
                    if (key[0] === "$" && key.slice(1) in instance) {
                        return false;
                    } else {
                        {
                            ctx[key] = value;
                        }
                    }
                    return true;
                },
                has ({ _: { data, setupState, accessCache, ctx, appContext, propsOptions, type } }, key) {
                    let normalizedProps, cssModules;
                    return !!(accessCache[key] || data !== EMPTY_OBJ && key[0] !== "$" && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) || (cssModules = type.__cssModules) && cssModules[key]);
                },
                defineProperty (target, key, descriptor) {
                    if (descriptor.get != null) {
                        target._.accessCache[key] = 0;
                    } else if (hasOwn(descriptor, "value")) {
                        this.set(target, key, descriptor.value, null);
                    }
                    return Reflect.defineProperty(target, key, descriptor);
                }
            };
            function normalizePropsOrEmits(props) {
                return isArray$2(props) ? props.reduce((normalized, p2)=>(normalized[p2] = null, normalized), {}) : props;
            }
            function withAsyncContext(getAwaitable) {
                const ctx = getCurrentInstance();
                let awaitable = getAwaitable();
                unsetCurrentInstance();
                if (isPromise(awaitable)) {
                    awaitable = awaitable.catch((e)=>{
                        setCurrentInstance(ctx);
                        throw e;
                    });
                }
                return [
                    awaitable,
                    ()=>setCurrentInstance(ctx)
                ];
            }
            let shouldCacheAccess = true;
            function applyOptions(instance) {
                const options = resolveMergedOptions(instance);
                const publicThis = instance.proxy;
                const ctx = instance.ctx;
                shouldCacheAccess = false;
                if (options.beforeCreate) {
                    callHook$1(options.beforeCreate, instance, "bc");
                }
                const { data: dataOptions, computed: computedOptions, methods, watch: watchOptions, provide: provideOptions, inject: injectOptions, created, beforeMount, mounted, beforeUpdate, updated, activated, deactivated, beforeDestroy, beforeUnmount, destroyed, unmounted, render: render2, renderTracked, renderTriggered, errorCaptured, serverPrefetch, expose, inheritAttrs, components, directives, filters } = options;
                const checkDuplicateProperties = null;
                if (injectOptions) {
                    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
                }
                if (methods) {
                    for(const key in methods){
                        const methodHandler = methods[key];
                        if (isFunction$2(methodHandler)) {
                            {
                                ctx[key] = methodHandler.bind(publicThis);
                            }
                        }
                    }
                }
                if (dataOptions) {
                    const data = dataOptions.call(publicThis, publicThis);
                    if (!isObject$1(data)) ;
                    else {
                        instance.data = reactive(data);
                    }
                }
                shouldCacheAccess = true;
                if (computedOptions) {
                    for(const key in computedOptions){
                        const opt = computedOptions[key];
                        const get = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
                        const set = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
                        const c = computed({
                            get,
                            set
                        });
                        Object.defineProperty(ctx, key, {
                            enumerable: true,
                            configurable: true,
                            get: ()=>c.value,
                            set: (v)=>c.value = v
                        });
                    }
                }
                if (watchOptions) {
                    for(const key in watchOptions){
                        createWatcher(watchOptions[key], ctx, publicThis, key);
                    }
                }
                if (provideOptions) {
                    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
                    Reflect.ownKeys(provides).forEach((key)=>{
                        provide(key, provides[key]);
                    });
                }
                if (created) {
                    callHook$1(created, instance, "c");
                }
                function registerLifecycleHook(register, hook) {
                    if (isArray$2(hook)) {
                        hook.forEach((_hook)=>register(_hook.bind(publicThis)));
                    } else if (hook) {
                        register(hook.bind(publicThis));
                    }
                }
                registerLifecycleHook(onBeforeMount, beforeMount);
                registerLifecycleHook(onMounted, mounted);
                registerLifecycleHook(onBeforeUpdate, beforeUpdate);
                registerLifecycleHook(onUpdated, updated);
                registerLifecycleHook(onActivated, activated);
                registerLifecycleHook(onDeactivated, deactivated);
                registerLifecycleHook(onErrorCaptured, errorCaptured);
                registerLifecycleHook(onRenderTracked, renderTracked);
                registerLifecycleHook(onRenderTriggered, renderTriggered);
                registerLifecycleHook(onBeforeUnmount, beforeUnmount);
                registerLifecycleHook(onUnmounted, unmounted);
                registerLifecycleHook(onServerPrefetch, serverPrefetch);
                if (isArray$2(expose)) {
                    if (expose.length) {
                        const exposed = instance.exposed || (instance.exposed = {});
                        expose.forEach((key)=>{
                            Object.defineProperty(exposed, key, {
                                get: ()=>publicThis[key],
                                set: (val)=>publicThis[key] = val,
                                enumerable: true
                            });
                        });
                    } else if (!instance.exposed) {
                        instance.exposed = {};
                    }
                }
                if (render2 && instance.render === NOOP) {
                    instance.render = render2;
                }
                if (inheritAttrs != null) {
                    instance.inheritAttrs = inheritAttrs;
                }
                if (components) instance.components = components;
                if (directives) instance.directives = directives;
                if (serverPrefetch) {
                    markAsyncBoundary(instance);
                }
            }
            function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
                if (isArray$2(injectOptions)) {
                    injectOptions = normalizeInject(injectOptions);
                }
                for(const key in injectOptions){
                    const opt = injectOptions[key];
                    let injected;
                    if (isObject$1(opt)) {
                        if ("default" in opt) {
                            injected = inject(opt.from || key, opt.default, true);
                        } else {
                            injected = inject(opt.from || key);
                        }
                    } else {
                        injected = inject(opt);
                    }
                    if (isRef(injected)) {
                        Object.defineProperty(ctx, key, {
                            enumerable: true,
                            configurable: true,
                            get: ()=>injected.value,
                            set: (v)=>injected.value = v
                        });
                    } else {
                        ctx[key] = injected;
                    }
                }
            }
            function callHook$1(hook, instance, type) {
                callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2)=>h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
            }
            function createWatcher(raw, ctx, publicThis, key) {
                let getter = key.includes(".") ? createPathGetter(publicThis, key) : ()=>publicThis[key];
                if (isString$1(raw)) {
                    const handler = ctx[raw];
                    if (isFunction$2(handler)) {
                        {
                            watch(getter, handler);
                        }
                    }
                } else if (isFunction$2(raw)) {
                    {
                        watch(getter, raw.bind(publicThis));
                    }
                } else if (isObject$1(raw)) {
                    if (isArray$2(raw)) {
                        raw.forEach((r2)=>createWatcher(r2, ctx, publicThis, key));
                    } else {
                        const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
                        if (isFunction$2(handler)) {
                            watch(getter, handler, raw);
                        }
                    }
                } else ;
            }
            function resolveMergedOptions(instance) {
                const base = instance.type;
                const { mixins, extends: extendsOptions } = base;
                const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
                const cached = cache.get(base);
                let resolved;
                if (cached) {
                    resolved = cached;
                } else if (!globalMixins.length && !mixins && !extendsOptions) {
                    {
                        resolved = base;
                    }
                } else {
                    resolved = {};
                    if (globalMixins.length) {
                        globalMixins.forEach((m)=>mergeOptions$1(resolved, m, optionMergeStrategies, true));
                    }
                    mergeOptions$1(resolved, base, optionMergeStrategies);
                }
                if (isObject$1(base)) {
                    cache.set(base, resolved);
                }
                return resolved;
            }
            function mergeOptions$1(to, from, strats, asMixin = false) {
                const { mixins, extends: extendsOptions } = from;
                if (extendsOptions) {
                    mergeOptions$1(to, extendsOptions, strats, true);
                }
                if (mixins) {
                    mixins.forEach((m)=>mergeOptions$1(to, m, strats, true));
                }
                for(const key in from){
                    if (asMixin && key === "expose") ;
                    else {
                        const strat = internalOptionMergeStrats[key] || strats && strats[key];
                        to[key] = strat ? strat(to[key], from[key]) : from[key];
                    }
                }
                return to;
            }
            const internalOptionMergeStrats = {
                data: mergeDataFn,
                props: mergeEmitsOrPropsOptions,
                emits: mergeEmitsOrPropsOptions,
                methods: mergeObjectOptions,
                computed: mergeObjectOptions,
                beforeCreate: mergeAsArray,
                created: mergeAsArray,
                beforeMount: mergeAsArray,
                mounted: mergeAsArray,
                beforeUpdate: mergeAsArray,
                updated: mergeAsArray,
                beforeDestroy: mergeAsArray,
                beforeUnmount: mergeAsArray,
                destroyed: mergeAsArray,
                unmounted: mergeAsArray,
                activated: mergeAsArray,
                deactivated: mergeAsArray,
                errorCaptured: mergeAsArray,
                serverPrefetch: mergeAsArray,
                components: mergeObjectOptions,
                directives: mergeObjectOptions,
                watch: mergeWatchOptions,
                provide: mergeDataFn,
                inject: mergeInject
            };
            function mergeDataFn(to, from) {
                if (!from) {
                    return to;
                }
                if (!to) {
                    return from;
                }
                return function mergedDataFn() {
                    return extend$1(isFunction$2(to) ? to.call(this, this) : to, isFunction$2(from) ? from.call(this, this) : from);
                };
            }
            function mergeInject(to, from) {
                return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
            }
            function normalizeInject(raw) {
                if (isArray$2(raw)) {
                    const res = {};
                    for(let i = 0; i < raw.length; i++){
                        res[raw[i]] = raw[i];
                    }
                    return res;
                }
                return raw;
            }
            function mergeAsArray(to, from) {
                return to ? [
                    ...new Set([].concat(to, from))
                ] : from;
            }
            function mergeObjectOptions(to, from) {
                return to ? extend$1(Object.create(null), to, from) : from;
            }
            function mergeEmitsOrPropsOptions(to, from) {
                if (to) {
                    if (isArray$2(to) && isArray$2(from)) {
                        return [
                            ...new Set([
                                ...to,
                                ...from
                            ])
                        ];
                    }
                    return extend$1(Object.create(null), normalizePropsOrEmits(to), normalizePropsOrEmits(from != null ? from : {}));
                } else {
                    return from;
                }
            }
            function mergeWatchOptions(to, from) {
                if (!to) return from;
                if (!from) return to;
                const merged = extend$1(Object.create(null), to);
                for(const key in from){
                    merged[key] = mergeAsArray(to[key], from[key]);
                }
                return merged;
            }
            function createAppContext() {
                return {
                    app: null,
                    config: {
                        isNativeTag: NO,
                        performance: false,
                        globalProperties: {},
                        optionMergeStrategies: {},
                        errorHandler: void 0,
                        warnHandler: void 0,
                        compilerOptions: {}
                    },
                    mixins: [],
                    components: {},
                    directives: {},
                    provides: Object.create(null),
                    optionsCache: new WeakMap(),
                    propsCache: new WeakMap(),
                    emitsCache: new WeakMap()
                };
            }
            let uid$1 = 0;
            function createAppAPI(render2, hydrate) {
                return function createApp2(rootComponent, rootProps = null) {
                    if (!isFunction$2(rootComponent)) {
                        rootComponent = extend$1({}, rootComponent);
                    }
                    if (rootProps != null && !isObject$1(rootProps)) {
                        rootProps = null;
                    }
                    const context = createAppContext();
                    const installedPlugins = new WeakSet();
                    const pluginCleanupFns = [];
                    let isMounted = false;
                    const app2 = context.app = {
                        _uid: uid$1++,
                        _component: rootComponent,
                        _props: rootProps,
                        _container: null,
                        _context: context,
                        _instance: null,
                        version,
                        get config () {
                            return context.config;
                        },
                        set config (v){},
                        use (plugin, ...options) {
                            if (installedPlugins.has(plugin)) ;
                            else if (plugin && isFunction$2(plugin.install)) {
                                installedPlugins.add(plugin);
                                plugin.install(app2, ...options);
                            } else if (isFunction$2(plugin)) {
                                installedPlugins.add(plugin);
                                plugin(app2, ...options);
                            } else ;
                            return app2;
                        },
                        mixin (mixin) {
                            {
                                if (!context.mixins.includes(mixin)) {
                                    context.mixins.push(mixin);
                                }
                            }
                            return app2;
                        },
                        component (name, component) {
                            if (!component) {
                                return context.components[name];
                            }
                            context.components[name] = component;
                            return app2;
                        },
                        directive (name, directive) {
                            if (!directive) {
                                return context.directives[name];
                            }
                            context.directives[name] = directive;
                            return app2;
                        },
                        mount (rootContainer, isHydrate, namespace2) {
                            if (!isMounted) {
                                const vnode = app2._ceVNode || createVNode(rootComponent, rootProps);
                                vnode.appContext = context;
                                if (namespace2 === true) {
                                    namespace2 = "svg";
                                } else if (namespace2 === false) {
                                    namespace2 = void 0;
                                }
                                {
                                    render2(vnode, rootContainer, namespace2);
                                }
                                isMounted = true;
                                app2._container = rootContainer;
                                rootContainer.__vue_app__ = app2;
                                return getComponentPublicInstance(vnode.component);
                            }
                        },
                        onUnmount (cleanupFn) {
                            pluginCleanupFns.push(cleanupFn);
                        },
                        unmount () {
                            if (isMounted) {
                                callWithAsyncErrorHandling(pluginCleanupFns, app2._instance, 16);
                                render2(null, app2._container);
                                delete app2._container.__vue_app__;
                            }
                        },
                        provide (key, value) {
                            context.provides[key] = value;
                            return app2;
                        },
                        runWithContext (fn) {
                            const lastApp = currentApp;
                            currentApp = app2;
                            try {
                                return fn();
                            } finally{
                                currentApp = lastApp;
                            }
                        }
                    };
                    return app2;
                };
            }
            let currentApp = null;
            function provide(key, value) {
                if (!currentInstance) ;
                else {
                    let provides = currentInstance.provides;
                    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
                    if (parentProvides === provides) {
                        provides = currentInstance.provides = Object.create(parentProvides);
                    }
                    provides[key] = value;
                }
            }
            function inject(key, defaultValue, treatDefaultAsFactory = false) {
                const instance = getCurrentInstance();
                if (instance || currentApp) {
                    let provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null || instance.ce ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
                    if (provides && key in provides) {
                        return provides[key];
                    } else if (arguments.length > 1) {
                        return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
                    } else ;
                }
            }
            const internalObjectProto = {};
            const createInternalObject = ()=>Object.create(internalObjectProto);
            const isInternalObject = (obj)=>Object.getPrototypeOf(obj) === internalObjectProto;
            function initProps(instance, rawProps, isStateful, isSSR = false) {
                const props = {};
                const attrs = createInternalObject();
                instance.propsDefaults = Object.create(null);
                setFullProps(instance, rawProps, props, attrs);
                for(const key in instance.propsOptions[0]){
                    if (!(key in props)) {
                        props[key] = void 0;
                    }
                }
                if (isStateful) {
                    instance.props = isSSR ? props : shallowReactive(props);
                } else {
                    if (!instance.type.props) {
                        instance.props = attrs;
                    } else {
                        instance.props = props;
                    }
                }
                instance.attrs = attrs;
            }
            function updateProps(instance, rawProps, rawPrevProps, optimized) {
                const { props, attrs, vnode: { patchFlag } } = instance;
                const rawCurrentProps = toRaw(props);
                const [options] = instance.propsOptions;
                let hasAttrsChanged = false;
                if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
                    if (patchFlag & 8) {
                        const propsToUpdate = instance.vnode.dynamicProps;
                        for(let i = 0; i < propsToUpdate.length; i++){
                            let key = propsToUpdate[i];
                            if (isEmitListener(instance.emitsOptions, key)) {
                                continue;
                            }
                            const value = rawProps[key];
                            if (options) {
                                if (hasOwn(attrs, key)) {
                                    if (value !== attrs[key]) {
                                        attrs[key] = value;
                                        hasAttrsChanged = true;
                                    }
                                } else {
                                    const camelizedKey = camelize(key);
                                    props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
                                }
                            } else {
                                if (value !== attrs[key]) {
                                    attrs[key] = value;
                                    hasAttrsChanged = true;
                                }
                            }
                        }
                    }
                } else {
                    if (setFullProps(instance, rawProps, props, attrs)) {
                        hasAttrsChanged = true;
                    }
                    let kebabKey;
                    for(const key in rawCurrentProps){
                        if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
                            if (options) {
                                if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
                                    props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
                                }
                            } else {
                                delete props[key];
                            }
                        }
                    }
                    if (attrs !== rawCurrentProps) {
                        for(const key in attrs){
                            if (!rawProps || !hasOwn(rawProps, key) && true) {
                                delete attrs[key];
                                hasAttrsChanged = true;
                            }
                        }
                    }
                }
                if (hasAttrsChanged) {
                    trigger(instance.attrs, "set", "");
                }
            }
            function setFullProps(instance, rawProps, props, attrs) {
                const [options, needCastKeys] = instance.propsOptions;
                let hasAttrsChanged = false;
                let rawCastValues;
                if (rawProps) {
                    for(let key in rawProps){
                        if (isReservedProp(key)) {
                            continue;
                        }
                        const value = rawProps[key];
                        let camelKey;
                        if (options && hasOwn(options, camelKey = camelize(key))) {
                            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
                                props[camelKey] = value;
                            } else {
                                (rawCastValues || (rawCastValues = {}))[camelKey] = value;
                            }
                        } else if (!isEmitListener(instance.emitsOptions, key)) {
                            if (!(key in attrs) || value !== attrs[key]) {
                                attrs[key] = value;
                                hasAttrsChanged = true;
                            }
                        }
                    }
                }
                if (needCastKeys) {
                    const rawCurrentProps = toRaw(props);
                    const castValues = rawCastValues || EMPTY_OBJ;
                    for(let i = 0; i < needCastKeys.length; i++){
                        const key = needCastKeys[i];
                        props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
                    }
                }
                return hasAttrsChanged;
            }
            function resolvePropValue(options, props, key, value, instance, isAbsent) {
                const opt = options[key];
                if (opt != null) {
                    const hasDefault = hasOwn(opt, "default");
                    if (hasDefault && value === void 0) {
                        const defaultValue = opt.default;
                        if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
                            const { propsDefaults } = instance;
                            if (key in propsDefaults) {
                                value = propsDefaults[key];
                            } else {
                                const reset = setCurrentInstance(instance);
                                value = propsDefaults[key] = defaultValue.call(null, props);
                                reset();
                            }
                        } else {
                            value = defaultValue;
                        }
                        if (instance.ce) {
                            instance.ce._setProp(key, value);
                        }
                    }
                    if (opt[0]) {
                        if (isAbsent && !hasDefault) {
                            value = false;
                        } else if (opt[1] && (value === "" || value === hyphenate(key))) {
                            value = true;
                        }
                    }
                }
                return value;
            }
            const mixinPropsCache = new WeakMap();
            function normalizePropsOptions(comp, appContext, asMixin = false) {
                const cache = asMixin ? mixinPropsCache : appContext.propsCache;
                const cached = cache.get(comp);
                if (cached) {
                    return cached;
                }
                const raw = comp.props;
                const normalized = {};
                const needCastKeys = [];
                let hasExtends = false;
                if (!isFunction$2(comp)) {
                    const extendProps = (raw2)=>{
                        hasExtends = true;
                        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
                        extend$1(normalized, props);
                        if (keys) needCastKeys.push(...keys);
                    };
                    if (!asMixin && appContext.mixins.length) {
                        appContext.mixins.forEach(extendProps);
                    }
                    if (comp.extends) {
                        extendProps(comp.extends);
                    }
                    if (comp.mixins) {
                        comp.mixins.forEach(extendProps);
                    }
                }
                if (!raw && !hasExtends) {
                    if (isObject$1(comp)) {
                        cache.set(comp, EMPTY_ARR);
                    }
                    return EMPTY_ARR;
                }
                if (isArray$2(raw)) {
                    for(let i = 0; i < raw.length; i++){
                        const normalizedKey = camelize(raw[i]);
                        if (validatePropName(normalizedKey)) {
                            normalized[normalizedKey] = EMPTY_OBJ;
                        }
                    }
                } else if (raw) {
                    for(const key in raw){
                        const normalizedKey = camelize(key);
                        if (validatePropName(normalizedKey)) {
                            const opt = raw[key];
                            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? {
                                type: opt
                            } : extend$1({}, opt);
                            const propType = prop.type;
                            let shouldCast = false;
                            let shouldCastTrue = true;
                            if (isArray$2(propType)) {
                                for(let index = 0; index < propType.length; ++index){
                                    const type = propType[index];
                                    const typeName = isFunction$2(type) && type.name;
                                    if (typeName === "Boolean") {
                                        shouldCast = true;
                                        break;
                                    } else if (typeName === "String") {
                                        shouldCastTrue = false;
                                    }
                                }
                            } else {
                                shouldCast = isFunction$2(propType) && propType.name === "Boolean";
                            }
                            prop[0] = shouldCast;
                            prop[1] = shouldCastTrue;
                            if (shouldCast || hasOwn(prop, "default")) {
                                needCastKeys.push(normalizedKey);
                            }
                        }
                    }
                }
                const res = [
                    normalized,
                    needCastKeys
                ];
                if (isObject$1(comp)) {
                    cache.set(comp, res);
                }
                return res;
            }
            function validatePropName(key) {
                if (key[0] !== "$" && !isReservedProp(key)) {
                    return true;
                }
                return false;
            }
            const isInternalKey = (key)=>key === "_" || key === "_ctx" || key === "$stable";
            const normalizeSlotValue = (value)=>isArray$2(value) ? value.map(normalizeVNode) : [
                    normalizeVNode(value)
                ];
            const normalizeSlot$1 = (key, rawSlot, ctx)=>{
                if (rawSlot._n) {
                    return rawSlot;
                }
                const normalized = withCtx((...args)=>{
                    if (false) ;
                    return normalizeSlotValue(rawSlot(...args));
                }, ctx);
                normalized._c = false;
                return normalized;
            };
            const normalizeObjectSlots = (rawSlots, slots, instance)=>{
                const ctx = rawSlots._ctx;
                for(const key in rawSlots){
                    if (isInternalKey(key)) continue;
                    const value = rawSlots[key];
                    if (isFunction$2(value)) {
                        slots[key] = normalizeSlot$1(key, value, ctx);
                    } else if (value != null) {
                        const normalized = normalizeSlotValue(value);
                        slots[key] = ()=>normalized;
                    }
                }
            };
            const normalizeVNodeSlots = (instance, children)=>{
                const normalized = normalizeSlotValue(children);
                instance.slots.default = ()=>normalized;
            };
            const assignSlots = (slots, children, optimized)=>{
                for(const key in children){
                    if (optimized || !isInternalKey(key)) {
                        slots[key] = children[key];
                    }
                }
            };
            const initSlots = (instance, children, optimized)=>{
                const slots = instance.slots = createInternalObject();
                if (instance.vnode.shapeFlag & 32) {
                    const type = children._;
                    if (type) {
                        assignSlots(slots, children, optimized);
                        if (optimized) {
                            def(slots, "_", type, true);
                        }
                    } else {
                        normalizeObjectSlots(children, slots);
                    }
                } else if (children) {
                    normalizeVNodeSlots(instance, children);
                }
            };
            const updateSlots = (instance, children, optimized)=>{
                const { vnode, slots } = instance;
                let needDeletionCheck = true;
                let deletionComparisonTarget = EMPTY_OBJ;
                if (vnode.shapeFlag & 32) {
                    const type = children._;
                    if (type) {
                        if (optimized && type === 1) {
                            needDeletionCheck = false;
                        } else {
                            assignSlots(slots, children, optimized);
                        }
                    } else {
                        needDeletionCheck = !children.$stable;
                        normalizeObjectSlots(children, slots);
                    }
                    deletionComparisonTarget = children;
                } else if (children) {
                    normalizeVNodeSlots(instance, children);
                    deletionComparisonTarget = {
                        default: 1
                    };
                }
                if (needDeletionCheck) {
                    for(const key in slots){
                        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
                            delete slots[key];
                        }
                    }
                }
            };
            const queuePostRenderEffect = queueEffectWithSuspense;
            function createRenderer(options) {
                return baseCreateRenderer(options);
            }
            function baseCreateRenderer(options, createHydrationFns) {
                const target = getGlobalThis();
                target.__VUE__ = true;
                const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
                const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren)=>{
                    if (n1 === n2) {
                        return;
                    }
                    if (n1 && !isSameVNodeType(n1, n2)) {
                        anchor = getNextHostNode(n1);
                        unmount(n1, parentComponent, parentSuspense, true);
                        n1 = null;
                    }
                    if (n2.patchFlag === -2) {
                        optimized = false;
                        n2.dynamicChildren = null;
                    }
                    const { type, ref: ref3, shapeFlag } = n2;
                    switch(type){
                        case Text:
                            processText(n1, n2, container, anchor);
                            break;
                        case Comment:
                            processCommentNode(n1, n2, container, anchor);
                            break;
                        case Static:
                            if (n1 == null) {
                                mountStaticNode(n2, container, anchor, namespace2);
                            }
                            break;
                        case Fragment:
                            processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            break;
                        default:
                            if (shapeFlag & 1) {
                                processElement(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            } else if (shapeFlag & 6) {
                                processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            } else if (shapeFlag & 64) {
                                type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals);
                            } else if (shapeFlag & 128) {
                                type.process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals);
                            } else ;
                    }
                    if (ref3 != null && parentComponent) {
                        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
                    } else if (ref3 == null && n1 && n1.ref != null) {
                        setRef(n1.ref, null, parentSuspense, n1, true);
                    }
                };
                const processText = (n1, n2, container, anchor)=>{
                    if (n1 == null) {
                        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
                    } else {
                        const el = n2.el = n1.el;
                        if (n2.children !== n1.children) {
                            hostSetText(el, n2.children);
                        }
                    }
                };
                const processCommentNode = (n1, n2, container, anchor)=>{
                    if (n1 == null) {
                        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
                    } else {
                        n2.el = n1.el;
                    }
                };
                const mountStaticNode = (n2, container, anchor, namespace2)=>{
                    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, namespace2, n2.el, n2.anchor);
                };
                const moveStaticNode = ({ el, anchor }, container, nextSibling)=>{
                    let next;
                    while(el && el !== anchor){
                        next = hostNextSibling(el);
                        hostInsert(el, container, nextSibling);
                        el = next;
                    }
                    hostInsert(anchor, container, nextSibling);
                };
                const removeStaticNode = ({ el, anchor })=>{
                    let next;
                    while(el && el !== anchor){
                        next = hostNextSibling(el);
                        hostRemove(el);
                        el = next;
                    }
                    hostRemove(anchor);
                };
                const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    if (n2.type === "svg") {
                        namespace2 = "svg";
                    } else if (n2.type === "math") {
                        namespace2 = "mathml";
                    }
                    if (n1 == null) {
                        mountElement(n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                    } else {
                        patchElement(n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                    }
                };
                const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    let el;
                    let vnodeHook;
                    const { props, shapeFlag, transition, dirs } = vnode;
                    el = vnode.el = hostCreateElement(vnode.type, namespace2, props && props.is, props);
                    if (shapeFlag & 8) {
                        hostSetElementText(el, vnode.children);
                    } else if (shapeFlag & 16) {
                        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(vnode, namespace2), slotScopeIds, optimized);
                    }
                    if (dirs) {
                        invokeDirectiveHook(vnode, null, parentComponent, "created");
                    }
                    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
                    if (props) {
                        for(const key in props){
                            if (key !== "value" && !isReservedProp(key)) {
                                hostPatchProp(el, key, null, props[key], namespace2, parentComponent);
                            }
                        }
                        if ("value" in props) {
                            hostPatchProp(el, "value", null, props.value, namespace2);
                        }
                        if (vnodeHook = props.onVnodeBeforeMount) {
                            invokeVNodeHook(vnodeHook, parentComponent, vnode);
                        }
                    }
                    if (dirs) {
                        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
                    }
                    const needCallTransitionHooks = needTransition(parentSuspense, transition);
                    if (needCallTransitionHooks) {
                        transition.beforeEnter(el);
                    }
                    hostInsert(el, container, anchor);
                    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
                        queuePostRenderEffect(()=>{
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                            needCallTransitionHooks && transition.enter(el);
                            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
                        }, parentSuspense);
                    }
                };
                const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent)=>{
                    if (scopeId) {
                        hostSetScopeId(el, scopeId);
                    }
                    if (slotScopeIds) {
                        for(let i = 0; i < slotScopeIds.length; i++){
                            hostSetScopeId(el, slotScopeIds[i]);
                        }
                    }
                    if (parentComponent) {
                        let subTree = parentComponent.subTree;
                        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
                            const parentVNode = parentComponent.vnode;
                            setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
                        }
                    }
                };
                const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start2 = 0)=>{
                    for(let i = start2; i < children.length; i++){
                        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
                        patch(null, child, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                    }
                };
                const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    const el = n2.el = n1.el;
                    let { patchFlag, dynamicChildren, dirs } = n2;
                    patchFlag |= n1.patchFlag & 16;
                    const oldProps = n1.props || EMPTY_OBJ;
                    const newProps = n2.props || EMPTY_OBJ;
                    let vnodeHook;
                    parentComponent && toggleRecurse(parentComponent, false);
                    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
                        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                    }
                    if (dirs) {
                        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
                    }
                    parentComponent && toggleRecurse(parentComponent, true);
                    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
                        hostSetElementText(el, "");
                    }
                    if (dynamicChildren) {
                        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace2), slotScopeIds);
                    } else if (!optimized) {
                        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, resolveChildrenNamespace(n2, namespace2), slotScopeIds, false);
                    }
                    if (patchFlag > 0) {
                        if (patchFlag & 16) {
                            patchProps(el, oldProps, newProps, parentComponent, namespace2);
                        } else {
                            if (patchFlag & 2) {
                                if (oldProps.class !== newProps.class) {
                                    hostPatchProp(el, "class", null, newProps.class, namespace2);
                                }
                            }
                            if (patchFlag & 4) {
                                hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
                            }
                            if (patchFlag & 8) {
                                const propsToUpdate = n2.dynamicProps;
                                for(let i = 0; i < propsToUpdate.length; i++){
                                    const key = propsToUpdate[i];
                                    const prev = oldProps[key];
                                    const next = newProps[key];
                                    if (next !== prev || key === "value") {
                                        hostPatchProp(el, key, prev, next, namespace2, parentComponent);
                                    }
                                }
                            }
                        }
                        if (patchFlag & 1) {
                            if (n1.children !== n2.children) {
                                hostSetElementText(el, n2.children);
                            }
                        }
                    } else if (!optimized && dynamicChildren == null) {
                        patchProps(el, oldProps, newProps, parentComponent, namespace2);
                    }
                    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
                        queuePostRenderEffect(()=>{
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
                            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
                        }, parentSuspense);
                    }
                };
                const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds)=>{
                    for(let i = 0; i < newChildren.length; i++){
                        const oldVNode = oldChildren[i];
                        const newVNode = newChildren[i];
                        const container = (oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64 | 128)) ? hostParentNode(oldVNode.el) : (fallbackContainer));
                        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, namespace2, slotScopeIds, true);
                    }
                };
                const patchProps = (el, oldProps, newProps, parentComponent, namespace2)=>{
                    if (oldProps !== newProps) {
                        if (oldProps !== EMPTY_OBJ) {
                            for(const key in oldProps){
                                if (!isReservedProp(key) && !(key in newProps)) {
                                    hostPatchProp(el, key, oldProps[key], null, namespace2, parentComponent);
                                }
                            }
                        }
                        for(const key in newProps){
                            if (isReservedProp(key)) continue;
                            const next = newProps[key];
                            const prev = oldProps[key];
                            if (next !== prev && key !== "value") {
                                hostPatchProp(el, key, prev, next, namespace2, parentComponent);
                            }
                        }
                        if ("value" in newProps) {
                            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
                        }
                    }
                };
                const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
                    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
                    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
                    if (fragmentSlotScopeIds) {
                        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
                    }
                    if (n1 == null) {
                        hostInsert(fragmentStartAnchor, container, anchor);
                        hostInsert(fragmentEndAnchor, container, anchor);
                        mountChildren(n2.children || [], container, fragmentEndAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                    } else {
                        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
                            patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, namespace2, slotScopeIds);
                            if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
                                traverseStaticChildren(n1, n2, true);
                            }
                        } else {
                            patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                        }
                    }
                };
                const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    n2.slotScopeIds = slotScopeIds;
                    if (n1 == null) {
                        if (n2.shapeFlag & 512) {
                            parentComponent.ctx.activate(n2, container, anchor, namespace2, optimized);
                        } else {
                            mountComponent(n2, container, anchor, parentComponent, parentSuspense, namespace2, optimized);
                        }
                    } else {
                        updateComponent(n1, n2, optimized);
                    }
                };
                const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized)=>{
                    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
                    if (isKeepAlive(initialVNode)) {
                        instance.ctx.renderer = internals;
                    }
                    {
                        setupComponent(instance, false, optimized);
                    }
                    if (instance.asyncDep) {
                        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
                        if (!initialVNode.el) {
                            const placeholder = instance.subTree = createVNode(Comment);
                            processCommentNode(null, placeholder, container, anchor);
                            initialVNode.placeholder = placeholder.el;
                        }
                    } else {
                        setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized);
                    }
                };
                const updateComponent = (n1, n2, optimized)=>{
                    const instance = n2.component = n1.component;
                    if (shouldUpdateComponent(n1, n2, optimized)) {
                        if (instance.asyncDep && !instance.asyncResolved) {
                            updateComponentPreRender(instance, n2, optimized);
                            return;
                        } else {
                            instance.next = n2;
                            instance.update();
                        }
                    } else {
                        n2.el = n1.el;
                        instance.vnode = n2;
                    }
                };
                const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized)=>{
                    const componentUpdateFn = ()=>{
                        if (!instance.isMounted) {
                            let vnodeHook;
                            const { el, props } = initialVNode;
                            const { bm, m, parent, root, type } = instance;
                            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
                            toggleRecurse(instance, false);
                            if (bm) {
                                invokeArrayFns(bm);
                            }
                            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
                                invokeVNodeHook(vnodeHook, parent, initialVNode);
                            }
                            toggleRecurse(instance, true);
                            {
                                if (root.ce && root.ce._def.shadowRoot !== false) {
                                    root.ce._injectChildStyle(type);
                                }
                                const subTree = instance.subTree = renderComponentRoot(instance);
                                patch(null, subTree, container, anchor, instance, parentSuspense, namespace2);
                                initialVNode.el = subTree.el;
                            }
                            if (m) {
                                queuePostRenderEffect(m, parentSuspense);
                            }
                            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
                                const scopedInitialVNode = initialVNode;
                                queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
                            }
                            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
                                instance.a && queuePostRenderEffect(instance.a, parentSuspense);
                            }
                            instance.isMounted = true;
                            initialVNode = container = anchor = null;
                        } else {
                            let { next, bu, u, parent, vnode } = instance;
                            {
                                const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
                                if (nonHydratedAsyncRoot) {
                                    if (next) {
                                        next.el = vnode.el;
                                        updateComponentPreRender(instance, next, optimized);
                                    }
                                    nonHydratedAsyncRoot.asyncDep.then(()=>{
                                        if (!instance.isUnmounted) {
                                            componentUpdateFn();
                                        }
                                    });
                                    return;
                                }
                            }
                            let originNext = next;
                            let vnodeHook;
                            toggleRecurse(instance, false);
                            if (next) {
                                next.el = vnode.el;
                                updateComponentPreRender(instance, next, optimized);
                            } else {
                                next = vnode;
                            }
                            if (bu) {
                                invokeArrayFns(bu);
                            }
                            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
                                invokeVNodeHook(vnodeHook, parent, next, vnode);
                            }
                            toggleRecurse(instance, true);
                            const nextTree = renderComponentRoot(instance);
                            const prevTree = instance.subTree;
                            instance.subTree = nextTree;
                            patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, namespace2);
                            next.el = nextTree.el;
                            if (originNext === null) {
                                updateHOCHostEl(instance, nextTree.el);
                            }
                            if (u) {
                                queuePostRenderEffect(u, parentSuspense);
                            }
                            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
                                queuePostRenderEffect(()=>invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
                            }
                        }
                    };
                    instance.scope.on();
                    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
                    instance.scope.off();
                    const update = instance.update = effect2.run.bind(effect2);
                    const job = instance.job = effect2.runIfDirty.bind(effect2);
                    job.i = instance;
                    job.id = instance.uid;
                    effect2.scheduler = ()=>queueJob(job);
                    toggleRecurse(instance, true);
                    update();
                };
                const updateComponentPreRender = (instance, nextVNode, optimized)=>{
                    nextVNode.component = instance;
                    const prevProps = instance.vnode.props;
                    instance.vnode = nextVNode;
                    instance.next = null;
                    updateProps(instance, nextVNode.props, prevProps, optimized);
                    updateSlots(instance, nextVNode.children, optimized);
                    pauseTracking();
                    flushPreFlushCbs(instance);
                    resetTracking();
                };
                const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false)=>{
                    const c1 = n1 && n1.children;
                    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
                    const c2 = n2.children;
                    const { patchFlag, shapeFlag } = n2;
                    if (patchFlag > 0) {
                        if (patchFlag & 128) {
                            patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            return;
                        } else if (patchFlag & 256) {
                            patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            return;
                        }
                    }
                    if (shapeFlag & 8) {
                        if (prevShapeFlag & 16) {
                            unmountChildren(c1, parentComponent, parentSuspense);
                        }
                        if (c2 !== c1) {
                            hostSetElementText(container, c2);
                        }
                    } else {
                        if (prevShapeFlag & 16) {
                            if (shapeFlag & 16) {
                                patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            } else {
                                unmountChildren(c1, parentComponent, parentSuspense, true);
                            }
                        } else {
                            if (prevShapeFlag & 8) {
                                hostSetElementText(container, "");
                            }
                            if (shapeFlag & 16) {
                                mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            }
                        }
                    }
                };
                const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    c1 = c1 || EMPTY_ARR;
                    c2 = c2 || EMPTY_ARR;
                    const oldLength = c1.length;
                    const newLength = c2.length;
                    const commonLength = Math.min(oldLength, newLength);
                    let i;
                    for(i = 0; i < commonLength; i++){
                        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                        patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                    }
                    if (oldLength > newLength) {
                        unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
                    } else {
                        mountChildren(c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, commonLength);
                    }
                };
                const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized)=>{
                    let i = 0;
                    const l2 = c2.length;
                    let e1 = c1.length - 1;
                    let e2 = l2 - 1;
                    while(i <= e1 && i <= e2){
                        const n1 = c1[i];
                        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                        if (isSameVNodeType(n1, n2)) {
                            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                        } else {
                            break;
                        }
                        i++;
                    }
                    while(i <= e1 && i <= e2){
                        const n1 = c1[e1];
                        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
                        if (isSameVNodeType(n1, n2)) {
                            patch(n1, n2, container, null, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                        } else {
                            break;
                        }
                        e1--;
                        e2--;
                    }
                    if (i > e1) {
                        if (i <= e2) {
                            const nextPos = e2 + 1;
                            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
                            while(i <= e2){
                                patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                                i++;
                            }
                        }
                    } else if (i > e2) {
                        while(i <= e1){
                            unmount(c1[i], parentComponent, parentSuspense, true);
                            i++;
                        }
                    } else {
                        const s1 = i;
                        const s2 = i;
                        const keyToNewIndexMap = new Map();
                        for(i = s2; i <= e2; i++){
                            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
                            if (nextChild.key != null) {
                                keyToNewIndexMap.set(nextChild.key, i);
                            }
                        }
                        let j;
                        let patched = 0;
                        const toBePatched = e2 - s2 + 1;
                        let moved = false;
                        let maxNewIndexSoFar = 0;
                        const newIndexToOldIndexMap = new Array(toBePatched);
                        for(i = 0; i < toBePatched; i++)newIndexToOldIndexMap[i] = 0;
                        for(i = s1; i <= e1; i++){
                            const prevChild = c1[i];
                            if (patched >= toBePatched) {
                                unmount(prevChild, parentComponent, parentSuspense, true);
                                continue;
                            }
                            let newIndex;
                            if (prevChild.key != null) {
                                newIndex = keyToNewIndexMap.get(prevChild.key);
                            } else {
                                for(j = s2; j <= e2; j++){
                                    if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                                        newIndex = j;
                                        break;
                                    }
                                }
                            }
                            if (newIndex === void 0) {
                                unmount(prevChild, parentComponent, parentSuspense, true);
                            } else {
                                newIndexToOldIndexMap[newIndex - s2] = i + 1;
                                if (newIndex >= maxNewIndexSoFar) {
                                    maxNewIndexSoFar = newIndex;
                                } else {
                                    moved = true;
                                }
                                patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                                patched++;
                            }
                        }
                        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
                        j = increasingNewIndexSequence.length - 1;
                        for(i = toBePatched - 1; i >= 0; i--){
                            const nextIndex = s2 + i;
                            const nextChild = c2[nextIndex];
                            const anchorVNode = c2[nextIndex + 1];
                            const anchor = nextIndex + 1 < l2 ? (anchorVNode.el || anchorVNode.placeholder) : parentAnchor;
                            if (newIndexToOldIndexMap[i] === 0) {
                                patch(null, nextChild, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized);
                            } else if (moved) {
                                if (j < 0 || i !== increasingNewIndexSequence[j]) {
                                    move(nextChild, container, anchor, 2);
                                } else {
                                    j--;
                                }
                            }
                        }
                    }
                };
                const move = (vnode, container, anchor, moveType, parentSuspense = null)=>{
                    const { el, type, transition, children, shapeFlag } = vnode;
                    if (shapeFlag & 6) {
                        move(vnode.component.subTree, container, anchor, moveType);
                        return;
                    }
                    if (shapeFlag & 128) {
                        vnode.suspense.move(container, anchor, moveType);
                        return;
                    }
                    if (shapeFlag & 64) {
                        type.move(vnode, container, anchor, internals);
                        return;
                    }
                    if (type === Fragment) {
                        hostInsert(el, container, anchor);
                        for(let i = 0; i < children.length; i++){
                            move(children[i], container, anchor, moveType);
                        }
                        hostInsert(vnode.anchor, container, anchor);
                        return;
                    }
                    if (type === Static) {
                        moveStaticNode(vnode, container, anchor);
                        return;
                    }
                    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
                    if (needTransition2) {
                        if (moveType === 0) {
                            transition.beforeEnter(el);
                            hostInsert(el, container, anchor);
                            queuePostRenderEffect(()=>transition.enter(el), parentSuspense);
                        } else {
                            const { leave, delayLeave, afterLeave } = transition;
                            const remove22 = ()=>{
                                if (vnode.ctx.isUnmounted) {
                                    hostRemove(el);
                                } else {
                                    hostInsert(el, container, anchor);
                                }
                            };
                            const performLeave = ()=>{
                                if (el._isLeaving) {
                                    el[leaveCbKey](true);
                                }
                                leave(el, ()=>{
                                    remove22();
                                    afterLeave && afterLeave();
                                });
                            };
                            if (delayLeave) {
                                delayLeave(el, remove22, performLeave);
                            } else {
                                performLeave();
                            }
                        }
                    } else {
                        hostInsert(el, container, anchor);
                    }
                };
                const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false)=>{
                    const { type, props, ref: ref3, children, dynamicChildren, shapeFlag, patchFlag, dirs, cacheIndex } = vnode;
                    if (patchFlag === -2) {
                        optimized = false;
                    }
                    if (ref3 != null) {
                        pauseTracking();
                        setRef(ref3, null, parentSuspense, vnode, true);
                        resetTracking();
                    }
                    if (cacheIndex != null) {
                        parentComponent.renderCache[cacheIndex] = void 0;
                    }
                    if (shapeFlag & 256) {
                        parentComponent.ctx.deactivate(vnode);
                        return;
                    }
                    const shouldInvokeDirs = shapeFlag & 1 && dirs;
                    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
                    let vnodeHook;
                    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
                        invokeVNodeHook(vnodeHook, parentComponent, vnode);
                    }
                    if (shapeFlag & 6) {
                        unmountComponent(vnode.component, parentSuspense, doRemove);
                    } else {
                        if (shapeFlag & 128) {
                            vnode.suspense.unmount(parentSuspense, doRemove);
                            return;
                        }
                        if (shouldInvokeDirs) {
                            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
                        }
                        if (shapeFlag & 64) {
                            vnode.type.remove(vnode, parentComponent, parentSuspense, internals, doRemove);
                        } else if (dynamicChildren && !dynamicChildren.hasOnce && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
                            unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
                        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
                            unmountChildren(children, parentComponent, parentSuspense);
                        }
                        if (doRemove) {
                            remove2(vnode);
                        }
                    }
                    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
                        queuePostRenderEffect(()=>{
                            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
                            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
                        }, parentSuspense);
                    }
                };
                const remove2 = (vnode)=>{
                    const { type, el, anchor, transition } = vnode;
                    if (type === Fragment) {
                        {
                            removeFragment(el, anchor);
                        }
                        return;
                    }
                    if (type === Static) {
                        removeStaticNode(vnode);
                        return;
                    }
                    const performRemove = ()=>{
                        hostRemove(el);
                        if (transition && !transition.persisted && transition.afterLeave) {
                            transition.afterLeave();
                        }
                    };
                    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
                        const { leave, delayLeave } = transition;
                        const performLeave = ()=>leave(el, performRemove);
                        if (delayLeave) {
                            delayLeave(vnode.el, performRemove, performLeave);
                        } else {
                            performLeave();
                        }
                    } else {
                        performRemove();
                    }
                };
                const removeFragment = (cur, end2)=>{
                    let next;
                    while(cur !== end2){
                        next = hostNextSibling(cur);
                        hostRemove(cur);
                        cur = next;
                    }
                    hostRemove(end2);
                };
                const unmountComponent = (instance, parentSuspense, doRemove)=>{
                    const { bum, scope, job, subTree, um, m, a } = instance;
                    invalidateMount(m);
                    invalidateMount(a);
                    if (bum) {
                        invokeArrayFns(bum);
                    }
                    scope.stop();
                    if (job) {
                        job.flags |= 8;
                        unmount(subTree, instance, parentSuspense, doRemove);
                    }
                    if (um) {
                        queuePostRenderEffect(um, parentSuspense);
                    }
                    queuePostRenderEffect(()=>{
                        instance.isUnmounted = true;
                    }, parentSuspense);
                };
                const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0)=>{
                    for(let i = start2; i < children.length; i++){
                        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
                    }
                };
                const getNextHostNode = (vnode)=>{
                    if (vnode.shapeFlag & 6) {
                        return getNextHostNode(vnode.component.subTree);
                    }
                    if (vnode.shapeFlag & 128) {
                        return vnode.suspense.next();
                    }
                    const el = hostNextSibling(vnode.anchor || vnode.el);
                    const teleportEnd = el && el[TeleportEndKey];
                    return teleportEnd ? hostNextSibling(teleportEnd) : el;
                };
                let isFlushing = false;
                const render2 = (vnode, container, namespace2)=>{
                    if (vnode == null) {
                        if (container._vnode) {
                            unmount(container._vnode, null, null, true);
                        }
                    } else {
                        patch(container._vnode || null, vnode, container, null, null, null, namespace2);
                    }
                    container._vnode = vnode;
                    if (!isFlushing) {
                        isFlushing = true;
                        flushPreFlushCbs();
                        flushPostFlushCbs();
                        isFlushing = false;
                    }
                };
                const internals = {
                    p: patch,
                    um: unmount,
                    m: move,
                    r: remove2,
                    mt: mountComponent,
                    mc: mountChildren,
                    pc: patchChildren,
                    pbc: patchBlockChildren,
                    n: getNextHostNode,
                    o: options
                };
                let hydrate;
                return {
                    render: render2,
                    hydrate,
                    createApp: createAppAPI(render2)
                };
            }
            function resolveChildrenNamespace({ type, props }, currentNamespace) {
                return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
            }
            function toggleRecurse({ effect: effect2, job }, allowed) {
                if (allowed) {
                    effect2.flags |= 32;
                    job.flags |= 4;
                } else {
                    effect2.flags &= -33;
                    job.flags &= -5;
                }
            }
            function needTransition(parentSuspense, transition) {
                return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
            }
            function traverseStaticChildren(n1, n2, shallow = false) {
                const ch1 = n1.children;
                const ch2 = n2.children;
                if (isArray$2(ch1) && isArray$2(ch2)) {
                    for(let i = 0; i < ch1.length; i++){
                        const c1 = ch1[i];
                        let c2 = ch2[i];
                        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
                            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
                                c2 = ch2[i] = cloneIfMounted(ch2[i]);
                                c2.el = c1.el;
                            }
                            if (!shallow && c2.patchFlag !== -2) traverseStaticChildren(c1, c2);
                        }
                        if (c2.type === Text && c2.patchFlag !== -1) {
                            c2.el = c1.el;
                        }
                        if (c2.type === Comment && !c2.el) {
                            c2.el = c1.el;
                        }
                    }
                }
            }
            function getSequence(arr) {
                const p2 = arr.slice();
                const result = [
                    0
                ];
                let i, j, u, v, c;
                const len = arr.length;
                for(i = 0; i < len; i++){
                    const arrI = arr[i];
                    if (arrI !== 0) {
                        j = result[result.length - 1];
                        if (arr[j] < arrI) {
                            p2[i] = j;
                            result.push(i);
                            continue;
                        }
                        u = 0;
                        v = result.length - 1;
                        while(u < v){
                            c = u + v >> 1;
                            if (arr[result[c]] < arrI) {
                                u = c + 1;
                            } else {
                                v = c;
                            }
                        }
                        if (arrI < arr[result[u]]) {
                            if (u > 0) {
                                p2[i] = result[u - 1];
                            }
                            result[u] = i;
                        }
                    }
                }
                u = result.length;
                v = result[u - 1];
                while(u-- > 0){
                    result[u] = v;
                    v = p2[v];
                }
                return result;
            }
            function locateNonHydratedAsyncRoot(instance) {
                const subComponent = instance.subTree.component;
                if (subComponent) {
                    if (subComponent.asyncDep && !subComponent.asyncResolved) {
                        return subComponent;
                    } else {
                        return locateNonHydratedAsyncRoot(subComponent);
                    }
                }
            }
            function invalidateMount(hooks) {
                if (hooks) {
                    for(let i = 0; i < hooks.length; i++)hooks[i].flags |= 8;
                }
            }
            const ssrContextKey = Symbol.for("v-scx");
            const useSSRContext = ()=>{
                {
                    const ctx = inject(ssrContextKey);
                    return ctx;
                }
            };
            function watch(source, cb, options) {
                return doWatch(source, cb, options);
            }
            function doWatch(source, cb, options = EMPTY_OBJ) {
                const { immediate, deep, flush, once } = options;
                const baseWatchOptions = extend$1({}, options);
                const runsImmediately = cb && immediate || !cb && flush !== "post";
                let ssrCleanup;
                if (isInSSRComponentSetup) {
                    if (flush === "sync") {
                        const ctx = useSSRContext();
                        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
                    } else if (!runsImmediately) {
                        const watchStopHandle = ()=>{};
                        watchStopHandle.stop = NOOP;
                        watchStopHandle.resume = NOOP;
                        watchStopHandle.pause = NOOP;
                        return watchStopHandle;
                    }
                }
                const instance = currentInstance;
                baseWatchOptions.call = (fn, type, args)=>callWithAsyncErrorHandling(fn, instance, type, args);
                let isPre = false;
                if (flush === "post") {
                    baseWatchOptions.scheduler = (job)=>{
                        queuePostRenderEffect(job, instance && instance.suspense);
                    };
                } else if (flush !== "sync") {
                    isPre = true;
                    baseWatchOptions.scheduler = (job, isFirstRun)=>{
                        if (isFirstRun) {
                            job();
                        } else {
                            queueJob(job);
                        }
                    };
                }
                baseWatchOptions.augmentJob = (job)=>{
                    if (cb) {
                        job.flags |= 4;
                    }
                    if (isPre) {
                        job.flags |= 2;
                        if (instance) {
                            job.id = instance.uid;
                            job.i = instance;
                        }
                    }
                };
                const watchHandle = watch$1(source, cb, baseWatchOptions);
                if (isInSSRComponentSetup) {
                    if (ssrCleanup) {
                        ssrCleanup.push(watchHandle);
                    } else if (runsImmediately) {
                        watchHandle();
                    }
                }
                return watchHandle;
            }
            function instanceWatch(source, value, options) {
                const publicThis = this.proxy;
                const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : ()=>publicThis[source] : source.bind(publicThis, publicThis);
                let cb;
                if (isFunction$2(value)) {
                    cb = value;
                } else {
                    cb = value.handler;
                    options = value;
                }
                const reset = setCurrentInstance(this);
                const res = doWatch(getter, cb.bind(publicThis), options);
                reset();
                return res;
            }
            function createPathGetter(ctx, path) {
                const segments = path.split(".");
                return ()=>{
                    let cur = ctx;
                    for(let i = 0; i < segments.length && cur; i++){
                        cur = cur[segments[i]];
                    }
                    return cur;
                };
            }
            const getModelModifiers = (props, modelName)=>{
                return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
            };
            function emit(instance, event, ...rawArgs) {
                if (instance.isUnmounted) return;
                const props = instance.vnode.props || EMPTY_OBJ;
                let args = rawArgs;
                const isModelListener2 = event.startsWith("update:");
                const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
                if (modifiers) {
                    if (modifiers.trim) {
                        args = rawArgs.map((a)=>isString$1(a) ? a.trim() : a);
                    }
                    if (modifiers.number) {
                        args = rawArgs.map(looseToNumber);
                    }
                }
                let handlerName;
                let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
                if (!handler && isModelListener2) {
                    handler = props[handlerName = toHandlerKey(hyphenate(event))];
                }
                if (handler) {
                    callWithAsyncErrorHandling(handler, instance, 6, args);
                }
                const onceHandler = props[handlerName + `Once`];
                if (onceHandler) {
                    if (!instance.emitted) {
                        instance.emitted = {};
                    } else if (instance.emitted[handlerName]) {
                        return;
                    }
                    instance.emitted[handlerName] = true;
                    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
                }
            }
            const mixinEmitsCache = new WeakMap();
            function normalizeEmitsOptions(comp, appContext, asMixin = false) {
                const cache = asMixin ? mixinEmitsCache : appContext.emitsCache;
                const cached = cache.get(comp);
                if (cached !== void 0) {
                    return cached;
                }
                const raw = comp.emits;
                let normalized = {};
                let hasExtends = false;
                if (!isFunction$2(comp)) {
                    const extendEmits = (raw2)=>{
                        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
                        if (normalizedFromExtend) {
                            hasExtends = true;
                            extend$1(normalized, normalizedFromExtend);
                        }
                    };
                    if (!asMixin && appContext.mixins.length) {
                        appContext.mixins.forEach(extendEmits);
                    }
                    if (comp.extends) {
                        extendEmits(comp.extends);
                    }
                    if (comp.mixins) {
                        comp.mixins.forEach(extendEmits);
                    }
                }
                if (!raw && !hasExtends) {
                    if (isObject$1(comp)) {
                        cache.set(comp, null);
                    }
                    return null;
                }
                if (isArray$2(raw)) {
                    raw.forEach((key)=>normalized[key] = null);
                } else {
                    extend$1(normalized, raw);
                }
                if (isObject$1(comp)) {
                    cache.set(comp, normalized);
                }
                return normalized;
            }
            function isEmitListener(options, key) {
                if (!options || !isOn(key)) {
                    return false;
                }
                key = key.slice(2).replace(/Once$/, "");
                return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
            }
            function markAttrsAccessed() {}
            function renderComponentRoot(instance) {
                const { type: Component, vnode, proxy, withProxy, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render2, renderCache, props, data, setupState, ctx, inheritAttrs } = instance;
                const prev = setCurrentRenderingInstance(instance);
                let result;
                let fallthroughAttrs;
                try {
                    if (vnode.shapeFlag & 4) {
                        const proxyToUse = withProxy || proxy;
                        const thisProxy = false ? new Proxy(proxyToUse, {
                            get (target, key, receiver) {
                                warn$1(`Property '${String(key)}' was accessed via 'this'. Avoid using 'this' in templates.`);
                                return Reflect.get(target, key, receiver);
                            }
                        }) : proxyToUse;
                        result = normalizeVNode(render2.call(thisProxy, proxyToUse, renderCache, false ? shallowReadonly(props) : props, setupState, data, ctx));
                        fallthroughAttrs = attrs;
                    } else {
                        const render22 = Component;
                        if (false) ;
                        result = normalizeVNode(render22.length > 1 ? render22(false ? shallowReadonly(props) : props, false ? {
                            get attrs () {
                                markAttrsAccessed();
                                return shallowReadonly(attrs);
                            },
                            slots,
                            emit: emit2
                        } : {
                            attrs,
                            slots,
                            emit: emit2
                        }) : render22(false ? shallowReadonly(props) : props, null));
                        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
                    }
                } catch (err) {
                    blockStack.length = 0;
                    handleError(err, instance, 1);
                    result = createVNode(Comment);
                }
                let root = result;
                if (fallthroughAttrs && inheritAttrs !== false) {
                    const keys = Object.keys(fallthroughAttrs);
                    const { shapeFlag } = root;
                    if (keys.length) {
                        if (shapeFlag & (1 | 6)) {
                            if (propsOptions && keys.some(isModelListener)) {
                                fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
                            }
                            root = cloneVNode(root, fallthroughAttrs, false, true);
                        }
                    }
                }
                if (vnode.dirs) {
                    root = cloneVNode(root, null, false, true);
                    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
                }
                if (vnode.transition) {
                    setTransitionHooks(root, vnode.transition);
                }
                {
                    result = root;
                }
                setCurrentRenderingInstance(prev);
                return result;
            }
            function filterSingleRoot(children, recurse = true) {
                let singleRoot;
                for(let i = 0; i < children.length; i++){
                    const child = children[i];
                    if (isVNode(child)) {
                        if (child.type !== Comment || child.children === "v-if") {
                            if (singleRoot) {
                                return;
                            } else {
                                singleRoot = child;
                            }
                        }
                    } else {
                        return;
                    }
                }
                return singleRoot;
            }
            const getFunctionalFallthrough = (attrs)=>{
                let res;
                for(const key in attrs){
                    if (key === "class" || key === "style" || isOn(key)) {
                        (res || (res = {}))[key] = attrs[key];
                    }
                }
                return res;
            };
            const filterModelListeners = (attrs, props)=>{
                const res = {};
                for(const key in attrs){
                    if (!isModelListener(key) || !(key.slice(9) in props)) {
                        res[key] = attrs[key];
                    }
                }
                return res;
            };
            function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
                const { props: prevProps, children: prevChildren, component } = prevVNode;
                const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
                const emits = component.emitsOptions;
                if (nextVNode.dirs || nextVNode.transition) {
                    return true;
                }
                if (optimized && patchFlag >= 0) {
                    if (patchFlag & 1024) {
                        return true;
                    }
                    if (patchFlag & 16) {
                        if (!prevProps) {
                            return !!nextProps;
                        }
                        return hasPropsChanged(prevProps, nextProps, emits);
                    } else if (patchFlag & 8) {
                        const dynamicProps = nextVNode.dynamicProps;
                        for(let i = 0; i < dynamicProps.length; i++){
                            const key = dynamicProps[i];
                            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
                                return true;
                            }
                        }
                    }
                } else {
                    if (prevChildren || nextChildren) {
                        if (!nextChildren || !nextChildren.$stable) {
                            return true;
                        }
                    }
                    if (prevProps === nextProps) {
                        return false;
                    }
                    if (!prevProps) {
                        return !!nextProps;
                    }
                    if (!nextProps) {
                        return true;
                    }
                    return hasPropsChanged(prevProps, nextProps, emits);
                }
                return false;
            }
            function hasPropsChanged(prevProps, nextProps, emitsOptions) {
                const nextKeys = Object.keys(nextProps);
                if (nextKeys.length !== Object.keys(prevProps).length) {
                    return true;
                }
                for(let i = 0; i < nextKeys.length; i++){
                    const key = nextKeys[i];
                    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
                        return true;
                    }
                }
                return false;
            }
            function updateHOCHostEl({ vnode, parent }, el) {
                while(parent){
                    const root = parent.subTree;
                    if (root.suspense && root.suspense.activeBranch === vnode) {
                        root.el = vnode.el;
                    }
                    if (root === vnode) {
                        (vnode = parent.vnode).el = el;
                        parent = parent.parent;
                    } else {
                        break;
                    }
                }
            }
            const isSuspense = (type)=>type.__isSuspense;
            let suspenseId = 0;
            const SuspenseImpl = {
                name: "Suspense",
                __isSuspense: true,
                process (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals) {
                    if (n1 == null) {
                        mountSuspense(n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals);
                    } else {
                        if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
                            n2.suspense = n1.suspense;
                            n2.suspense.vnode = n2;
                            n2.el = n1.el;
                            return;
                        }
                        patchSuspense(n1, n2, container, anchor, parentComponent, namespace2, slotScopeIds, optimized, rendererInternals);
                    }
                },
                hydrate: hydrateSuspense,
                normalize: normalizeSuspenseChildren
            };
            const Suspense = SuspenseImpl;
            function triggerEvent(vnode, name) {
                const eventListener = vnode.props && vnode.props[name];
                if (isFunction$2(eventListener)) {
                    eventListener();
                }
            }
            function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals) {
                const { p: patch, o: { createElement: createElement2 } } = rendererInternals;
                const hiddenContainer = createElement2("div");
                const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace2, slotScopeIds, optimized, rendererInternals);
                patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, namespace2, slotScopeIds);
                if (suspense.deps > 0) {
                    triggerEvent(vnode, "onPending");
                    triggerEvent(vnode, "onFallback");
                    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, namespace2, slotScopeIds);
                    setActiveBranch(suspense, vnode.ssFallback);
                } else {
                    suspense.resolve(false, true);
                }
            }
            function patchSuspense(n1, n2, container, anchor, parentComponent, namespace2, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
                const suspense = n2.suspense = n1.suspense;
                suspense.vnode = n2;
                n2.el = n1.el;
                const newBranch = n2.ssContent;
                const newFallback = n2.ssFallback;
                const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
                if (pendingBranch) {
                    suspense.pendingBranch = newBranch;
                    if (isSameVNodeType(pendingBranch, newBranch)) {
                        patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                        if (suspense.deps <= 0) {
                            suspense.resolve();
                        } else if (isInFallback) {
                            if (!isHydrating) {
                                patch(activeBranch, newFallback, container, anchor, parentComponent, null, namespace2, slotScopeIds, optimized);
                                setActiveBranch(suspense, newFallback);
                            }
                        }
                    } else {
                        suspense.pendingId = suspenseId++;
                        if (isHydrating) {
                            suspense.isHydrating = false;
                            suspense.activeBranch = pendingBranch;
                        } else {
                            unmount(pendingBranch, parentComponent, suspense);
                        }
                        suspense.deps = 0;
                        suspense.effects.length = 0;
                        suspense.hiddenContainer = createElement2("div");
                        if (isInFallback) {
                            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                            if (suspense.deps <= 0) {
                                suspense.resolve();
                            } else {
                                patch(activeBranch, newFallback, container, anchor, parentComponent, null, namespace2, slotScopeIds, optimized);
                                setActiveBranch(suspense, newFallback);
                            }
                        } else if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
                            patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                            suspense.resolve(true);
                        } else {
                            patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                            if (suspense.deps <= 0) {
                                suspense.resolve();
                            }
                        }
                    }
                } else {
                    if (activeBranch && isSameVNodeType(activeBranch, newBranch)) {
                        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                        setActiveBranch(suspense, newBranch);
                    } else {
                        triggerEvent(n2, "onPending");
                        suspense.pendingBranch = newBranch;
                        if (newBranch.shapeFlag & 512) {
                            suspense.pendingId = newBranch.component.suspenseId;
                        } else {
                            suspense.pendingId = suspenseId++;
                        }
                        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, namespace2, slotScopeIds, optimized);
                        if (suspense.deps <= 0) {
                            suspense.resolve();
                        } else {
                            const { timeout, pendingId } = suspense;
                            if (timeout > 0) {
                                setTimeout(()=>{
                                    if (suspense.pendingId === pendingId) {
                                        suspense.fallback(newFallback);
                                    }
                                }, timeout);
                            } else if (timeout === 0) {
                                suspense.fallback(newFallback);
                            }
                        }
                    }
                }
            }
            function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace2, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
                const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove2 } } = rendererInternals;
                let parentSuspenseId;
                const isSuspensible = isVNodeSuspensible(vnode);
                if (isSuspensible) {
                    if (parentSuspense && parentSuspense.pendingBranch) {
                        parentSuspenseId = parentSuspense.pendingId;
                        parentSuspense.deps++;
                    }
                }
                const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
                const initialAnchor = anchor;
                const suspense = {
                    vnode,
                    parent: parentSuspense,
                    parentComponent,
                    namespace: namespace2,
                    container,
                    hiddenContainer,
                    deps: 0,
                    pendingId: suspenseId++,
                    timeout: typeof timeout === "number" ? timeout : -1,
                    activeBranch: null,
                    pendingBranch: null,
                    isInFallback: !isHydrating,
                    isHydrating,
                    isUnmounted: false,
                    effects: [],
                    resolve (resume = false, sync = false) {
                        const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
                        let delayEnter = false;
                        if (suspense.isHydrating) {
                            suspense.isHydrating = false;
                        } else if (!resume) {
                            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
                            if (delayEnter) {
                                activeBranch.transition.afterLeave = ()=>{
                                    if (pendingId === suspense.pendingId) {
                                        move(pendingBranch, container2, anchor === initialAnchor ? next(activeBranch) : anchor, 0);
                                        queuePostFlushCb(effects);
                                    }
                                };
                            }
                            if (activeBranch) {
                                if (parentNode(activeBranch.el) === container2) {
                                    anchor = next(activeBranch);
                                }
                                unmount(activeBranch, parentComponent2, suspense, true);
                            }
                            if (!delayEnter) {
                                move(pendingBranch, container2, anchor, 0);
                            }
                        }
                        setActiveBranch(suspense, pendingBranch);
                        suspense.pendingBranch = null;
                        suspense.isInFallback = false;
                        let parent = suspense.parent;
                        let hasUnresolvedAncestor = false;
                        while(parent){
                            if (parent.pendingBranch) {
                                parent.effects.push(...effects);
                                hasUnresolvedAncestor = true;
                                break;
                            }
                            parent = parent.parent;
                        }
                        if (!hasUnresolvedAncestor && !delayEnter) {
                            queuePostFlushCb(effects);
                        }
                        suspense.effects = [];
                        if (isSuspensible) {
                            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
                                parentSuspense.deps--;
                                if (parentSuspense.deps === 0 && !sync) {
                                    parentSuspense.resolve();
                                }
                            }
                        }
                        triggerEvent(vnode2, "onResolve");
                    },
                    fallback (fallbackVNode) {
                        if (!suspense.pendingBranch) {
                            return;
                        }
                        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace22 } = suspense;
                        triggerEvent(vnode2, "onFallback");
                        const anchor2 = next(activeBranch);
                        const mountFallback = ()=>{
                            if (!suspense.isInFallback) {
                                return;
                            }
                            patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, namespace22, slotScopeIds, optimized);
                            setActiveBranch(suspense, fallbackVNode);
                        };
                        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
                        if (delayEnter) {
                            activeBranch.transition.afterLeave = mountFallback;
                        }
                        suspense.isInFallback = true;
                        unmount(activeBranch, parentComponent2, null, true);
                        if (!delayEnter) {
                            mountFallback();
                        }
                    },
                    move (container2, anchor2, type) {
                        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
                        suspense.container = container2;
                    },
                    next () {
                        return suspense.activeBranch && next(suspense.activeBranch);
                    },
                    registerDep (instance, setupRenderEffect, optimized2) {
                        const isInPendingSuspense = !!suspense.pendingBranch;
                        if (isInPendingSuspense) {
                            suspense.deps++;
                        }
                        const hydratedEl = instance.vnode.el;
                        instance.asyncDep.catch((err)=>{
                            handleError(err, instance, 0);
                        }).then((asyncSetupResult)=>{
                            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
                                return;
                            }
                            instance.asyncResolved = true;
                            const { vnode: vnode2 } = instance;
                            handleSetupResult(instance, asyncSetupResult);
                            if (hydratedEl) {
                                vnode2.el = hydratedEl;
                            }
                            const placeholder = !hydratedEl && instance.subTree.el;
                            setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, namespace2, optimized2);
                            if (placeholder) {
                                remove2(placeholder);
                            }
                            updateHOCHostEl(instance, vnode2.el);
                            if (isInPendingSuspense && --suspense.deps === 0) {
                                suspense.resolve();
                            }
                        });
                    },
                    unmount (parentSuspense2, doRemove) {
                        suspense.isUnmounted = true;
                        if (suspense.activeBranch) {
                            unmount(suspense.activeBranch, parentComponent, parentSuspense2, doRemove);
                        }
                        if (suspense.pendingBranch) {
                            unmount(suspense.pendingBranch, parentComponent, parentSuspense2, doRemove);
                        }
                    }
                };
                return suspense;
            }
            function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals, hydrateNode) {
                const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, namespace2, slotScopeIds, optimized, rendererInternals, true);
                const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
                if (suspense.deps === 0) {
                    suspense.resolve(false, true);
                }
                return result;
            }
            function normalizeSuspenseChildren(vnode) {
                const { shapeFlag, children } = vnode;
                const isSlotChildren = shapeFlag & 32;
                vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
                vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
            }
            function normalizeSuspenseSlot(s2) {
                let block;
                if (isFunction$2(s2)) {
                    const trackBlock = isBlockTreeEnabled && s2._c;
                    if (trackBlock) {
                        s2._d = false;
                        openBlock();
                    }
                    s2 = s2();
                    if (trackBlock) {
                        s2._d = true;
                        block = currentBlock;
                        closeBlock();
                    }
                }
                if (isArray$2(s2)) {
                    const singleChild = filterSingleRoot(s2);
                    s2 = singleChild;
                }
                s2 = normalizeVNode(s2);
                if (block && !s2.dynamicChildren) {
                    s2.dynamicChildren = block.filter((c)=>c !== s2);
                }
                return s2;
            }
            function queueEffectWithSuspense(fn, suspense) {
                if (suspense && suspense.pendingBranch) {
                    if (isArray$2(fn)) {
                        suspense.effects.push(...fn);
                    } else {
                        suspense.effects.push(fn);
                    }
                } else {
                    queuePostFlushCb(fn);
                }
            }
            function setActiveBranch(suspense, branch) {
                suspense.activeBranch = branch;
                const { vnode, parentComponent } = suspense;
                let el = branch.el;
                while(!el && branch.component){
                    branch = branch.component.subTree;
                    el = branch.el;
                }
                vnode.el = el;
                if (parentComponent && parentComponent.subTree === vnode) {
                    parentComponent.vnode.el = el;
                    updateHOCHostEl(parentComponent, el);
                }
            }
            function isVNodeSuspensible(vnode) {
                const suspensible = vnode.props && vnode.props.suspensible;
                return suspensible != null && suspensible !== false;
            }
            const Fragment = exports("F", Symbol.for("v-fgt"));
            const Text = Symbol.for("v-txt");
            const Comment = Symbol.for("v-cmt");
            const Static = Symbol.for("v-stc");
            const blockStack = [];
            let currentBlock = null;
            function openBlock(disableTracking = false) {
                blockStack.push(currentBlock = disableTracking ? null : []);
            }
            function closeBlock() {
                blockStack.pop();
                currentBlock = blockStack[blockStack.length - 1] || null;
            }
            let isBlockTreeEnabled = 1;
            function setBlockTracking(value, inVOnce = false) {
                isBlockTreeEnabled += value;
                if (value < 0 && currentBlock && inVOnce) {
                    currentBlock.hasOnce = true;
                }
            }
            function setupBlock(vnode) {
                vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
                closeBlock();
                if (isBlockTreeEnabled > 0 && currentBlock) {
                    currentBlock.push(vnode);
                }
                return vnode;
            }
            function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
                return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
            }
            function createBlock(type, props, children, patchFlag, dynamicProps) {
                return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
            }
            function isVNode(value) {
                return value ? value.__v_isVNode === true : false;
            }
            function isSameVNodeType(n1, n2) {
                return n1.type === n2.type && n1.key === n2.key;
            }
            const normalizeKey = ({ key })=>key != null ? key : null;
            const normalizeRef = ({ ref: ref3, ref_key, ref_for })=>{
                if (typeof ref3 === "number") {
                    ref3 = "" + ref3;
                }
                return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$2(ref3) ? {
                    i: currentRenderingInstance,
                    r: ref3,
                    k: ref_key,
                    f: !!ref_for
                } : ref3 : null;
            };
            function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
                const vnode = {
                    __v_isVNode: true,
                    __v_skip: true,
                    type,
                    props,
                    key: props && normalizeKey(props),
                    ref: props && normalizeRef(props),
                    scopeId: currentScopeId,
                    slotScopeIds: null,
                    children,
                    component: null,
                    suspense: null,
                    ssContent: null,
                    ssFallback: null,
                    dirs: null,
                    transition: null,
                    el: null,
                    anchor: null,
                    target: null,
                    targetStart: null,
                    targetAnchor: null,
                    staticCount: 0,
                    shapeFlag,
                    patchFlag,
                    dynamicProps,
                    dynamicChildren: null,
                    appContext: null,
                    ctx: currentRenderingInstance
                };
                if (needFullChildrenNormalization) {
                    normalizeChildren(vnode, children);
                    if (shapeFlag & 128) {
                        type.normalize(vnode);
                    }
                } else if (children) {
                    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
                }
                if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
                    currentBlock.push(vnode);
                }
                return vnode;
            }
            const createVNode = exports("g", _createVNode);
            function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
                if (!type || type === NULL_DYNAMIC_COMPONENT) {
                    type = Comment;
                }
                if (isVNode(type)) {
                    const cloned = cloneVNode(type, props, true);
                    if (children) {
                        normalizeChildren(cloned, children);
                    }
                    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
                        if (cloned.shapeFlag & 6) {
                            currentBlock[currentBlock.indexOf(type)] = cloned;
                        } else {
                            currentBlock.push(cloned);
                        }
                    }
                    cloned.patchFlag = -2;
                    return cloned;
                }
                if (isClassComponent(type)) {
                    type = type.__vccOpts;
                }
                if (props) {
                    props = guardReactiveProps(props);
                    let { class: klass, style } = props;
                    if (klass && !isString$1(klass)) {
                        props.class = normalizeClass(klass);
                    }
                    if (isObject$1(style)) {
                        if (isProxy(style) && !isArray$2(style)) {
                            style = extend$1({}, style);
                        }
                        props.style = normalizeStyle(style);
                    }
                }
                const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$2(type) ? 2 : 0;
                return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
            }
            function guardReactiveProps(props) {
                if (!props) return null;
                return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
            }
            function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
                const { props, ref: ref3, patchFlag, children, transition } = vnode;
                const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
                const cloned = {
                    __v_isVNode: true,
                    __v_skip: true,
                    type: vnode.type,
                    props: mergedProps,
                    key: mergedProps && normalizeKey(mergedProps),
                    ref: extraProps && extraProps.ref ? (mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [
                        ref3,
                        normalizeRef(extraProps)
                    ] : normalizeRef(extraProps)) : ref3,
                    scopeId: vnode.scopeId,
                    slotScopeIds: vnode.slotScopeIds,
                    children,
                    target: vnode.target,
                    targetStart: vnode.targetStart,
                    targetAnchor: vnode.targetAnchor,
                    staticCount: vnode.staticCount,
                    shapeFlag: vnode.shapeFlag,
                    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
                    dynamicProps: vnode.dynamicProps,
                    dynamicChildren: vnode.dynamicChildren,
                    appContext: vnode.appContext,
                    dirs: vnode.dirs,
                    transition,
                    component: vnode.component,
                    suspense: vnode.suspense,
                    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
                    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
                    placeholder: vnode.placeholder,
                    el: vnode.el,
                    anchor: vnode.anchor,
                    ctx: vnode.ctx,
                    ce: vnode.ce
                };
                if (transition && cloneTransition) {
                    setTransitionHooks(cloned, transition.clone(cloned));
                }
                return cloned;
            }
            function createTextVNode(text = " ", flag = 0) {
                return createVNode(Text, null, text, flag);
            }
            function createCommentVNode(text = "", asBlock = false) {
                return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
            }
            function normalizeVNode(child) {
                if (child == null || typeof child === "boolean") {
                    return createVNode(Comment);
                } else if (isArray$2(child)) {
                    return createVNode(Fragment, null, child.slice());
                } else if (isVNode(child)) {
                    return cloneIfMounted(child);
                } else {
                    return createVNode(Text, null, String(child));
                }
            }
            function cloneIfMounted(child) {
                return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
            }
            function normalizeChildren(vnode, children) {
                let type = 0;
                const { shapeFlag } = vnode;
                if (children == null) {
                    children = null;
                } else if (isArray$2(children)) {
                    type = 16;
                } else if (typeof children === "object") {
                    if (shapeFlag & (1 | 64)) {
                        const slot = children.default;
                        if (slot) {
                            slot._c && (slot._d = false);
                            normalizeChildren(vnode, slot());
                            slot._c && (slot._d = true);
                        }
                        return;
                    } else {
                        type = 32;
                        const slotFlag = children._;
                        if (!slotFlag && !isInternalObject(children)) {
                            children._ctx = currentRenderingInstance;
                        } else if (slotFlag === 3 && currentRenderingInstance) {
                            if (currentRenderingInstance.slots._ === 1) {
                                children._ = 1;
                            } else {
                                children._ = 2;
                                vnode.patchFlag |= 1024;
                            }
                        }
                    }
                } else if (isFunction$2(children)) {
                    children = {
                        default: children,
                        _ctx: currentRenderingInstance
                    };
                    type = 32;
                } else {
                    children = String(children);
                    if (shapeFlag & 64) {
                        type = 16;
                        children = [
                            createTextVNode(children)
                        ];
                    } else {
                        type = 8;
                    }
                }
                vnode.children = children;
                vnode.shapeFlag |= type;
            }
            function mergeProps(...args) {
                const ret = {};
                for(let i = 0; i < args.length; i++){
                    const toMerge = args[i];
                    for(const key in toMerge){
                        if (key === "class") {
                            if (ret.class !== toMerge.class) {
                                ret.class = normalizeClass([
                                    ret.class,
                                    toMerge.class
                                ]);
                            }
                        } else if (key === "style") {
                            ret.style = normalizeStyle([
                                ret.style,
                                toMerge.style
                            ]);
                        } else if (isOn(key)) {
                            const existing = ret[key];
                            const incoming = toMerge[key];
                            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
                                ret[key] = existing ? [].concat(existing, incoming) : incoming;
                            }
                        } else if (key !== "") {
                            ret[key] = toMerge[key];
                        }
                    }
                }
                return ret;
            }
            function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
                callWithAsyncErrorHandling(hook, instance, 7, [
                    vnode,
                    prevVNode
                ]);
            }
            const emptyAppContext = createAppContext();
            let uid = 0;
            function createComponentInstance(vnode, parent, suspense) {
                const type = vnode.type;
                const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
                const instance = {
                    uid: uid++,
                    vnode,
                    type,
                    parent,
                    appContext,
                    root: null,
                    next: null,
                    subTree: null,
                    effect: null,
                    update: null,
                    job: null,
                    scope: new EffectScope(true),
                    render: null,
                    proxy: null,
                    exposed: null,
                    exposeProxy: null,
                    withProxy: null,
                    provides: parent ? parent.provides : Object.create(appContext.provides),
                    ids: parent ? parent.ids : [
                        "",
                        0,
                        0
                    ],
                    accessCache: null,
                    renderCache: [],
                    components: null,
                    directives: null,
                    propsOptions: normalizePropsOptions(type, appContext),
                    emitsOptions: normalizeEmitsOptions(type, appContext),
                    emit: null,
                    emitted: null,
                    propsDefaults: EMPTY_OBJ,
                    inheritAttrs: type.inheritAttrs,
                    ctx: EMPTY_OBJ,
                    data: EMPTY_OBJ,
                    props: EMPTY_OBJ,
                    attrs: EMPTY_OBJ,
                    slots: EMPTY_OBJ,
                    refs: EMPTY_OBJ,
                    setupState: EMPTY_OBJ,
                    setupContext: null,
                    suspense,
                    suspenseId: suspense ? suspense.pendingId : 0,
                    asyncDep: null,
                    asyncResolved: false,
                    isMounted: false,
                    isUnmounted: false,
                    isDeactivated: false,
                    bc: null,
                    c: null,
                    bm: null,
                    m: null,
                    bu: null,
                    u: null,
                    um: null,
                    bum: null,
                    da: null,
                    a: null,
                    rtg: null,
                    rtc: null,
                    ec: null,
                    sp: null
                };
                {
                    instance.ctx = {
                        _: instance
                    };
                }
                instance.root = parent ? parent.root : instance;
                instance.emit = emit.bind(null, instance);
                if (vnode.ce) {
                    vnode.ce(instance);
                }
                return instance;
            }
            let currentInstance = null;
            const getCurrentInstance = ()=>currentInstance || currentRenderingInstance;
            let internalSetCurrentInstance;
            let setInSSRSetupState;
            {
                const g2 = getGlobalThis();
                const registerGlobalSetter = (key, setter)=>{
                    let setters;
                    if (!(setters = g2[key])) setters = g2[key] = [];
                    setters.push(setter);
                    return (v)=>{
                        if (setters.length > 1) setters.forEach((set)=>set(v));
                        else setters[0](v);
                    };
                };
                internalSetCurrentInstance = registerGlobalSetter(`__VUE_INSTANCE_SETTERS__`, (v)=>currentInstance = v);
                setInSSRSetupState = registerGlobalSetter(`__VUE_SSR_SETTERS__`, (v)=>isInSSRComponentSetup = v);
            }
            const setCurrentInstance = (instance)=>{
                const prev = currentInstance;
                internalSetCurrentInstance(instance);
                instance.scope.on();
                return ()=>{
                    instance.scope.off();
                    internalSetCurrentInstance(prev);
                };
            };
            const unsetCurrentInstance = ()=>{
                currentInstance && currentInstance.scope.off();
                internalSetCurrentInstance(null);
            };
            function isStatefulComponent(instance) {
                return instance.vnode.shapeFlag & 4;
            }
            let isInSSRComponentSetup = false;
            function setupComponent(instance, isSSR = false, optimized = false) {
                isSSR && setInSSRSetupState(isSSR);
                const { props, children } = instance.vnode;
                const isStateful = isStatefulComponent(instance);
                initProps(instance, props, isStateful, isSSR);
                initSlots(instance, children, optimized || isSSR);
                const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
                isSSR && setInSSRSetupState(false);
                return setupResult;
            }
            function setupStatefulComponent(instance, isSSR) {
                const Component = instance.type;
                instance.accessCache = Object.create(null);
                instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
                const { setup } = Component;
                if (setup) {
                    pauseTracking();
                    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
                    const reset = setCurrentInstance(instance);
                    const setupResult = callWithErrorHandling(setup, instance, 0, [
                        instance.props,
                        setupContext
                    ]);
                    const isAsyncSetup = isPromise(setupResult);
                    resetTracking();
                    reset();
                    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
                        markAsyncBoundary(instance);
                    }
                    if (isAsyncSetup) {
                        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
                        if (isSSR) {
                            return setupResult.then((resolvedResult)=>{
                                handleSetupResult(instance, resolvedResult);
                            }).catch((e)=>{
                                handleError(e, instance, 0);
                            });
                        } else {
                            instance.asyncDep = setupResult;
                        }
                    } else {
                        handleSetupResult(instance, setupResult);
                    }
                } else {
                    finishComponentSetup(instance);
                }
            }
            function handleSetupResult(instance, setupResult, isSSR) {
                if (isFunction$2(setupResult)) {
                    if (instance.type.__ssrInlineRender) {
                        instance.ssrRender = setupResult;
                    } else {
                        instance.render = setupResult;
                    }
                } else if (isObject$1(setupResult)) {
                    instance.setupState = proxyRefs(setupResult);
                } else ;
                finishComponentSetup(instance);
            }
            function finishComponentSetup(instance, isSSR, skipOptions) {
                const Component = instance.type;
                if (!instance.render) {
                    instance.render = Component.render || NOOP;
                }
                {
                    const reset = setCurrentInstance(instance);
                    pauseTracking();
                    try {
                        applyOptions(instance);
                    } finally{
                        resetTracking();
                        reset();
                    }
                }
            }
            const attrsProxyHandlers = {
                get (target, key) {
                    track(target, "get", "");
                    return target[key];
                }
            };
            function createSetupContext(instance) {
                const expose = (exposed)=>{
                    instance.exposed = exposed || {};
                };
                {
                    return {
                        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
                        slots: instance.slots,
                        emit: instance.emit,
                        expose
                    };
                }
            }
            function getComponentPublicInstance(instance) {
                if (instance.exposed) {
                    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
                        get (target, key) {
                            if (key in target) {
                                return target[key];
                            } else if (key in publicPropertiesMap) {
                                return publicPropertiesMap[key](instance);
                            }
                        },
                        has (target, key) {
                            return key in target || key in publicPropertiesMap;
                        }
                    }));
                } else {
                    return instance.proxy;
                }
            }
            const classifyRE = /(?:^|[-_])\w/g;
            const classify = (str)=>str.replace(classifyRE, (c)=>c.toUpperCase()).replace(/[-_]/g, "");
            function getComponentName(Component, includeInferred = true) {
                return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
            }
            function formatComponentName(instance, Component, isRoot = false) {
                let name = getComponentName(Component);
                if (!name && Component.__file) {
                    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
                    if (match) {
                        name = match[1];
                    }
                }
                if (!name && instance && instance.parent) {
                    const inferFromRegistry = (registry)=>{
                        for(const key in registry){
                            if (registry[key] === Component) {
                                return key;
                            }
                        }
                    };
                    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
                }
                return name ? classify(name) : isRoot ? `App` : `Anonymous`;
            }
            function isClassComponent(value) {
                return isFunction$2(value) && "__vccOpts" in value;
            }
            const computed = exports("m", (getterOrOptions, debugOptions)=>{
                const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
                return c;
            });
            function h(type, propsOrChildren, children) {
                const doCreateVNode = (type2, props, children2)=>{
                    setBlockTracking(-1);
                    try {
                        return createVNode(type2, props, children2);
                    } finally{
                        setBlockTracking(1);
                    }
                };
                const l = arguments.length;
                if (l === 2) {
                    if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
                        if (isVNode(propsOrChildren)) {
                            return doCreateVNode(type, null, [
                                propsOrChildren
                            ]);
                        }
                        return doCreateVNode(type, propsOrChildren);
                    } else {
                        return doCreateVNode(type, null, propsOrChildren);
                    }
                } else {
                    if (l > 3) {
                        children = Array.prototype.slice.call(arguments, 2);
                    } else if (l === 3 && isVNode(children)) {
                        children = [
                            children
                        ];
                    }
                    return doCreateVNode(type, propsOrChildren, children);
                }
            }
            const version = "3.5.21";
            let policy = void 0;
            const tt = typeof window !== "undefined" && window.trustedTypes;
            if (tt) {
                try {
                    policy = tt.createPolicy("vue", {
                        createHTML: (val)=>val
                    });
                } catch (e) {}
            }
            const unsafeToTrustedHTML = policy ? (val)=>policy.createHTML(val) : (val)=>val;
            const svgNS = "http://www.w3.org/2000/svg";
            const mathmlNS = "http://www.w3.org/1998/Math/MathML";
            const doc = typeof document !== "undefined" ? document : null;
            const templateContainer = doc && doc.createElement("template");
            const nodeOps = {
                insert: (child, parent, anchor)=>{
                    parent.insertBefore(child, anchor || null);
                },
                remove: (child)=>{
                    const parent = child.parentNode;
                    if (parent) {
                        parent.removeChild(child);
                    }
                },
                createElement: (tag, namespace2, is, props)=>{
                    const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, {
                        is
                    }) : doc.createElement(tag);
                    if (tag === "select" && props && props.multiple != null) {
                        el.setAttribute("multiple", props.multiple);
                    }
                    return el;
                },
                createText: (text)=>doc.createTextNode(text),
                createComment: (text)=>doc.createComment(text),
                setText: (node, text)=>{
                    node.nodeValue = text;
                },
                setElementText: (el, text)=>{
                    el.textContent = text;
                },
                parentNode: (node)=>node.parentNode,
                nextSibling: (node)=>node.nextSibling,
                querySelector: (selector)=>doc.querySelector(selector),
                setScopeId (el, id) {
                    el.setAttribute(id, "");
                },
                insertStaticContent (content, parent, anchor, namespace2, start2, end2) {
                    const before = anchor ? anchor.previousSibling : parent.lastChild;
                    if (start2 && (start2 === end2 || start2.nextSibling)) {
                        while(true){
                            parent.insertBefore(start2.cloneNode(true), anchor);
                            if (start2 === end2 || !(start2 = start2.nextSibling)) break;
                        }
                    } else {
                        templateContainer.innerHTML = unsafeToTrustedHTML(namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content);
                        const template = templateContainer.content;
                        if (namespace2 === "svg" || namespace2 === "mathml") {
                            const wrapper = template.firstChild;
                            while(wrapper.firstChild){
                                template.appendChild(wrapper.firstChild);
                            }
                            template.removeChild(wrapper);
                        }
                        parent.insertBefore(template, anchor);
                    }
                    return [
                        before ? before.nextSibling : parent.firstChild,
                        anchor ? anchor.previousSibling : parent.lastChild
                    ];
                }
            };
            const TRANSITION = "transition";
            const ANIMATION = "animation";
            const vtcKey = Symbol("_vtc");
            const DOMTransitionPropsValidators = {
                name: String,
                type: String,
                css: {
                    type: Boolean,
                    default: true
                },
                duration: [
                    String,
                    Number,
                    Object
                ],
                enterFromClass: String,
                enterActiveClass: String,
                enterToClass: String,
                appearFromClass: String,
                appearActiveClass: String,
                appearToClass: String,
                leaveFromClass: String,
                leaveActiveClass: String,
                leaveToClass: String
            };
            const TransitionPropsValidators = extend$1({}, BaseTransitionPropsValidators, DOMTransitionPropsValidators);
            const decorate$1 = (t2)=>{
                t2.displayName = "Transition";
                t2.props = TransitionPropsValidators;
                return t2;
            };
            const Transition = decorate$1((props, { slots })=>h(BaseTransition, resolveTransitionProps(props), slots));
            const callHook = (hook, args = [])=>{
                if (isArray$2(hook)) {
                    hook.forEach((h2)=>h2(...args));
                } else if (hook) {
                    hook(...args);
                }
            };
            const hasExplicitCallback = (hook)=>{
                return hook ? isArray$2(hook) ? hook.some((h2)=>h2.length > 1) : hook.length > 1 : false;
            };
            function resolveTransitionProps(rawProps) {
                const baseProps = {};
                for(const key in rawProps){
                    if (!(key in DOMTransitionPropsValidators)) {
                        baseProps[key] = rawProps[key];
                    }
                }
                if (rawProps.css === false) {
                    return baseProps;
                }
                const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
                const durations = normalizeDuration(duration);
                const enterDuration = durations && durations[0];
                const leaveDuration = durations && durations[1];
                const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
                const finishEnter = (el, isAppear, done, isCancelled)=>{
                    el._enterCancelled = isCancelled;
                    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
                    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
                    done && done();
                };
                const finishLeave = (el, done)=>{
                    el._isLeaving = false;
                    removeTransitionClass(el, leaveFromClass);
                    removeTransitionClass(el, leaveToClass);
                    removeTransitionClass(el, leaveActiveClass);
                    done && done();
                };
                const makeEnterHook = (isAppear)=>{
                    return (el, done)=>{
                        const hook = isAppear ? onAppear : onEnter;
                        const resolve2 = ()=>finishEnter(el, isAppear, done);
                        callHook(hook, [
                            el,
                            resolve2
                        ]);
                        nextFrame(()=>{
                            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
                            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
                            if (!hasExplicitCallback(hook)) {
                                whenTransitionEnds(el, type, enterDuration, resolve2);
                            }
                        });
                    };
                };
                return extend$1(baseProps, {
                    onBeforeEnter (el) {
                        callHook(onBeforeEnter, [
                            el
                        ]);
                        addTransitionClass(el, enterFromClass);
                        addTransitionClass(el, enterActiveClass);
                    },
                    onBeforeAppear (el) {
                        callHook(onBeforeAppear, [
                            el
                        ]);
                        addTransitionClass(el, appearFromClass);
                        addTransitionClass(el, appearActiveClass);
                    },
                    onEnter: makeEnterHook(false),
                    onAppear: makeEnterHook(true),
                    onLeave (el, done) {
                        el._isLeaving = true;
                        const resolve2 = ()=>finishLeave(el, done);
                        addTransitionClass(el, leaveFromClass);
                        if (!el._enterCancelled) {
                            forceReflow();
                            addTransitionClass(el, leaveActiveClass);
                        } else {
                            addTransitionClass(el, leaveActiveClass);
                            forceReflow();
                        }
                        nextFrame(()=>{
                            if (!el._isLeaving) {
                                return;
                            }
                            removeTransitionClass(el, leaveFromClass);
                            addTransitionClass(el, leaveToClass);
                            if (!hasExplicitCallback(onLeave)) {
                                whenTransitionEnds(el, type, leaveDuration, resolve2);
                            }
                        });
                        callHook(onLeave, [
                            el,
                            resolve2
                        ]);
                    },
                    onEnterCancelled (el) {
                        finishEnter(el, false, void 0, true);
                        callHook(onEnterCancelled, [
                            el
                        ]);
                    },
                    onAppearCancelled (el) {
                        finishEnter(el, true, void 0, true);
                        callHook(onAppearCancelled, [
                            el
                        ]);
                    },
                    onLeaveCancelled (el) {
                        finishLeave(el);
                        callHook(onLeaveCancelled, [
                            el
                        ]);
                    }
                });
            }
            function normalizeDuration(duration) {
                if (duration == null) {
                    return null;
                } else if (isObject$1(duration)) {
                    return [
                        NumberOf(duration.enter),
                        NumberOf(duration.leave)
                    ];
                } else {
                    const n = NumberOf(duration);
                    return [
                        n,
                        n
                    ];
                }
            }
            function NumberOf(val) {
                const res = toNumber(val);
                return res;
            }
            function addTransitionClass(el, cls) {
                cls.split(/\s+/).forEach((c)=>c && el.classList.add(c));
                (el[vtcKey] || (el[vtcKey] = new Set())).add(cls);
            }
            function removeTransitionClass(el, cls) {
                cls.split(/\s+/).forEach((c)=>c && el.classList.remove(c));
                const _vtc = el[vtcKey];
                if (_vtc) {
                    _vtc.delete(cls);
                    if (!_vtc.size) {
                        el[vtcKey] = void 0;
                    }
                }
            }
            function nextFrame(cb) {
                requestAnimationFrame(()=>{
                    requestAnimationFrame(cb);
                });
            }
            let endId = 0;
            function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
                const id = el._endId = ++endId;
                const resolveIfNotStale = ()=>{
                    if (id === el._endId) {
                        resolve2();
                    }
                };
                if (explicitTimeout != null) {
                    return setTimeout(resolveIfNotStale, explicitTimeout);
                }
                const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
                if (!type) {
                    return resolve2();
                }
                const endEvent = type + "end";
                let ended = 0;
                const end2 = ()=>{
                    el.removeEventListener(endEvent, onEnd);
                    resolveIfNotStale();
                };
                const onEnd = (e)=>{
                    if (e.target === el && ++ended >= propCount) {
                        end2();
                    }
                };
                setTimeout(()=>{
                    if (ended < propCount) {
                        end2();
                    }
                }, timeout + 1);
                el.addEventListener(endEvent, onEnd);
            }
            function getTransitionInfo(el, expectedType) {
                const styles2 = window.getComputedStyle(el);
                const getStyleProperties = (key)=>(styles2[key] || "").split(", ");
                const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
                const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
                const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
                const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
                const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
                const animationTimeout = getTimeout(animationDelays, animationDurations);
                let type = null;
                let timeout = 0;
                let propCount = 0;
                if (expectedType === TRANSITION) {
                    if (transitionTimeout > 0) {
                        type = TRANSITION;
                        timeout = transitionTimeout;
                        propCount = transitionDurations.length;
                    }
                } else if (expectedType === ANIMATION) {
                    if (animationTimeout > 0) {
                        type = ANIMATION;
                        timeout = animationTimeout;
                        propCount = animationDurations.length;
                    }
                } else {
                    timeout = Math.max(transitionTimeout, animationTimeout);
                    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
                    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
                }
                const hasTransform = type === TRANSITION && /\b(?:transform|all)(?:,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
                return {
                    type,
                    timeout,
                    propCount,
                    hasTransform
                };
            }
            function getTimeout(delays, durations) {
                while(delays.length < durations.length){
                    delays = delays.concat(delays);
                }
                return Math.max(...durations.map((d, i)=>toMs(d) + toMs(delays[i])));
            }
            function toMs(s2) {
                if (s2 === "auto") return 0;
                return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
            }
            function forceReflow() {
                return document.body.offsetHeight;
            }
            function patchClass(el, value, isSVG) {
                const transitionClasses = el[vtcKey];
                if (transitionClasses) {
                    value = (value ? [
                        value,
                        ...transitionClasses
                    ] : [
                        ...transitionClasses
                    ]).join(" ");
                }
                if (value == null) {
                    el.removeAttribute("class");
                } else if (isSVG) {
                    el.setAttribute("class", value);
                } else {
                    el.className = value;
                }
            }
            const vShowOriginalDisplay = Symbol("_vod");
            const vShowHidden = Symbol("_vsh");
            const CSS_VAR_TEXT = Symbol("");
            const displayRE = /(?:^|;)\s*display\s*:/;
            function patchStyle(el, prev, next) {
                const style = el.style;
                const isCssString = isString$1(next);
                let hasControlledDisplay = false;
                if (next && !isCssString) {
                    if (prev) {
                        if (!isString$1(prev)) {
                            for(const key in prev){
                                if (next[key] == null) {
                                    setStyle(style, key, "");
                                }
                            }
                        } else {
                            for (const prevStyle of prev.split(";")){
                                const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
                                if (next[key] == null) {
                                    setStyle(style, key, "");
                                }
                            }
                        }
                    }
                    for(const key in next){
                        if (key === "display") {
                            hasControlledDisplay = true;
                        }
                        setStyle(style, key, next[key]);
                    }
                } else {
                    if (isCssString) {
                        if (prev !== next) {
                            const cssVarText = style[CSS_VAR_TEXT];
                            if (cssVarText) {
                                next += ";" + cssVarText;
                            }
                            style.cssText = next;
                            hasControlledDisplay = displayRE.test(next);
                        }
                    } else if (prev) {
                        el.removeAttribute("style");
                    }
                }
                if (vShowOriginalDisplay in el) {
                    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
                    if (el[vShowHidden]) {
                        style.display = "none";
                    }
                }
            }
            const importantRE = /\s*!important$/;
            function setStyle(style, name, val) {
                if (isArray$2(val)) {
                    val.forEach((v)=>setStyle(style, name, v));
                } else {
                    if (val == null) val = "";
                    if (name.startsWith("--")) {
                        style.setProperty(name, val);
                    } else {
                        const prefixed = autoPrefix(style, name);
                        if (importantRE.test(val)) {
                            style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
                        } else {
                            style[prefixed] = val;
                        }
                    }
                }
            }
            const prefixes = [
                "Webkit",
                "Moz",
                "ms"
            ];
            const prefixCache = {};
            function autoPrefix(style, rawName) {
                const cached = prefixCache[rawName];
                if (cached) {
                    return cached;
                }
                let name = camelize(rawName);
                if (name !== "filter" && name in style) {
                    return prefixCache[rawName] = name;
                }
                name = capitalize(name);
                for(let i = 0; i < prefixes.length; i++){
                    const prefixed = prefixes[i] + name;
                    if (prefixed in style) {
                        return prefixCache[rawName] = prefixed;
                    }
                }
                return rawName;
            }
            const xlinkNS = "http://www.w3.org/1999/xlink";
            function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
                if (isSVG && key.startsWith("xlink:")) {
                    if (value == null) {
                        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
                    } else {
                        el.setAttributeNS(xlinkNS, key, value);
                    }
                } else {
                    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
                        el.removeAttribute(key);
                    } else {
                        el.setAttribute(key, isBoolean2 ? "" : isSymbol(value) ? String(value) : value);
                    }
                }
            }
            function patchDOMProp(el, key, value, parentComponent, attrName) {
                if (key === "innerHTML" || key === "textContent") {
                    if (value != null) {
                        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
                    }
                    return;
                }
                const tag = el.tagName;
                if (key === "value" && tag !== "PROGRESS" && !tag.includes("-")) {
                    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
                    const newValue = value == null ? (el.type === "checkbox" ? "on" : "") : String(value);
                    if (oldValue !== newValue || !("_value" in el)) {
                        el.value = newValue;
                    }
                    if (value == null) {
                        el.removeAttribute(key);
                    }
                    el._value = value;
                    return;
                }
                let needRemove = false;
                if (value === "" || value == null) {
                    const type = typeof el[key];
                    if (type === "boolean") {
                        value = includeBooleanAttr(value);
                    } else if (value == null && type === "string") {
                        value = "";
                        needRemove = true;
                    } else if (type === "number") {
                        value = 0;
                        needRemove = true;
                    }
                }
                try {
                    el[key] = value;
                } catch (e) {}
                needRemove && el.removeAttribute(attrName || key);
            }
            function addEventListener(el, event, handler, options) {
                el.addEventListener(event, handler, options);
            }
            function removeEventListener(el, event, handler, options) {
                el.removeEventListener(event, handler, options);
            }
            const veiKey = Symbol("_vei");
            function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
                const invokers = el[veiKey] || (el[veiKey] = {});
                const existingInvoker = invokers[rawName];
                if (nextValue && existingInvoker) {
                    existingInvoker.value = nextValue;
                } else {
                    const [name, options] = parseName(rawName);
                    if (nextValue) {
                        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
                        addEventListener(el, name, invoker, options);
                    } else if (existingInvoker) {
                        removeEventListener(el, name, existingInvoker, options);
                        invokers[rawName] = void 0;
                    }
                }
            }
            const optionsModifierRE = /(?:Once|Passive|Capture)$/;
            function parseName(name) {
                let options;
                if (optionsModifierRE.test(name)) {
                    options = {};
                    let m;
                    while(m = name.match(optionsModifierRE)){
                        name = name.slice(0, name.length - m[0].length);
                        options[m[0].toLowerCase()] = true;
                    }
                }
                const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
                return [
                    event,
                    options
                ];
            }
            let cachedNow = 0;
            const p$1 = Promise.resolve();
            const getNow = ()=>cachedNow || (p$1.then(()=>cachedNow = 0), cachedNow = Date.now());
            function createInvoker(initialValue, instance) {
                const invoker = (e)=>{
                    if (!e._vts) {
                        e._vts = Date.now();
                    } else if (e._vts <= invoker.attached) {
                        return;
                    }
                    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [
                        e
                    ]);
                };
                invoker.value = initialValue;
                invoker.attached = getNow();
                return invoker;
            }
            function patchStopImmediatePropagation(e, value) {
                if (isArray$2(value)) {
                    const originalStop = e.stopImmediatePropagation;
                    e.stopImmediatePropagation = ()=>{
                        originalStop.call(e);
                        e._stopped = true;
                    };
                    return value.map((fn)=>(e2)=>!e2._stopped && fn && fn(e2));
                } else {
                    return value;
                }
            }
            const isNativeOn = (key)=>key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
            const patchProp = (el, key, prevValue, nextValue, namespace2, parentComponent)=>{
                const isSVG = namespace2 === "svg";
                if (key === "class") {
                    patchClass(el, nextValue, isSVG);
                } else if (key === "style") {
                    patchStyle(el, prevValue, nextValue);
                } else if (isOn(key)) {
                    if (!isModelListener(key)) {
                        patchEvent(el, key, prevValue, nextValue, parentComponent);
                    }
                } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
                    patchDOMProp(el, key, nextValue);
                    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
                        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
                    }
                } else if (el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))) {
                    patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
                } else {
                    if (key === "true-value") {
                        el._trueValue = nextValue;
                    } else if (key === "false-value") {
                        el._falseValue = nextValue;
                    }
                    patchAttr(el, key, nextValue, isSVG);
                }
            };
            function shouldSetAsProp(el, key, value, isSVG) {
                if (isSVG) {
                    if (key === "innerHTML" || key === "textContent") {
                        return true;
                    }
                    if (key in el && isNativeOn(key) && isFunction$2(value)) {
                        return true;
                    }
                    return false;
                }
                if (key === "spellcheck" || key === "draggable" || key === "translate" || key === "autocorrect") {
                    return false;
                }
                if (key === "form") {
                    return false;
                }
                if (key === "list" && el.tagName === "INPUT") {
                    return false;
                }
                if (key === "type" && el.tagName === "TEXTAREA") {
                    return false;
                }
                if (key === "width" || key === "height") {
                    const tag = el.tagName;
                    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
                        return false;
                    }
                }
                if (isNativeOn(key) && isString$1(value)) {
                    return false;
                }
                return key in el;
            }
            const systemModifiers = [
                "ctrl",
                "shift",
                "alt",
                "meta"
            ];
            const modifierGuards = {
                stop: (e)=>e.stopPropagation(),
                prevent: (e)=>e.preventDefault(),
                self: (e)=>e.target !== e.currentTarget,
                ctrl: (e)=>!e.ctrlKey,
                shift: (e)=>!e.shiftKey,
                alt: (e)=>!e.altKey,
                meta: (e)=>!e.metaKey,
                left: (e)=>"button" in e && e.button !== 0,
                middle: (e)=>"button" in e && e.button !== 1,
                right: (e)=>"button" in e && e.button !== 2,
                exact: (e, modifiers)=>systemModifiers.some((m)=>e[`${m}Key`] && !modifiers.includes(m))
            };
            const withModifiers = exports("w", (fn, modifiers)=>{
                const cache = fn._withMods || (fn._withMods = {});
                const cacheKey = modifiers.join(".");
                return cache[cacheKey] || (cache[cacheKey] = ((event, ...args)=>{
                    for(let i = 0; i < modifiers.length; i++){
                        const guard = modifierGuards[modifiers[i]];
                        if (guard && guard(event, modifiers)) return;
                    }
                    return fn(event, ...args);
                }));
            });
            const rendererOptions = extend$1({
                patchProp
            }, nodeOps);
            let renderer;
            function ensureRenderer() {
                return renderer || (renderer = createRenderer(rendererOptions));
            }
            const createApp = ((...args)=>{
                const app2 = ensureRenderer().createApp(...args);
                const { mount } = app2;
                app2.mount = (containerOrSelector)=>{
                    const container = normalizeContainer(containerOrSelector);
                    if (!container) return;
                    const component = app2._component;
                    if (!isFunction$2(component) && !component.render && !component.template) {
                        component.template = container.innerHTML;
                    }
                    if (container.nodeType === 1) {
                        container.textContent = "";
                    }
                    const proxy = mount(container, false, resolveRootNamespace(container));
                    if (container instanceof Element) {
                        container.removeAttribute("v-cloak");
                        container.setAttribute("data-v-app", "");
                    }
                    return proxy;
                };
                return app2;
            });
            function resolveRootNamespace(container) {
                if (container instanceof SVGElement) {
                    return "svg";
                }
                if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
                    return "mathml";
                }
            }
            function normalizeContainer(container) {
                if (isString$1(container)) {
                    const res = document.querySelector(container);
                    return res;
                }
                return container;
            }
            const logo = window.externalPublicPath + "windwalker-logo-h-w.svg";
            const isBrowser = typeof document !== "undefined";
            function isRouteComponent(component) {
                return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
            }
            function isESModule(obj) {
                return obj.__esModule || obj[Symbol.toStringTag] === "Module" || obj.default && isRouteComponent(obj.default);
            }
            const assign = Object.assign;
            function applyToParams(fn, params) {
                const newParams = {};
                for(const key in params){
                    const value = params[key];
                    newParams[key] = isArray$1(value) ? value.map(fn) : fn(value);
                }
                return newParams;
            }
            const noop$3 = ()=>{};
            const isArray$1 = Array.isArray;
            const HASH_RE = /#/g;
            const AMPERSAND_RE = /&/g;
            const SLASH_RE = /\//g;
            const EQUAL_RE = /=/g;
            const IM_RE = /\?/g;
            const PLUS_RE = /\+/g;
            const ENC_BRACKET_OPEN_RE = /%5B/g;
            const ENC_BRACKET_CLOSE_RE = /%5D/g;
            const ENC_CARET_RE = /%5E/g;
            const ENC_BACKTICK_RE = /%60/g;
            const ENC_CURLY_OPEN_RE = /%7B/g;
            const ENC_PIPE_RE = /%7C/g;
            const ENC_CURLY_CLOSE_RE = /%7D/g;
            const ENC_SPACE_RE = /%20/g;
            function commonEncode(text) {
                return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
            }
            function encodeHash(text) {
                return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
            }
            function encodeQueryValue(text) {
                return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
            }
            function encodeQueryKey(text) {
                return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
            }
            function encodePath(text) {
                return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
            }
            function encodeParam(text) {
                return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
            }
            function decode(text) {
                try {
                    return decodeURIComponent("" + text);
                } catch (err) {}
                return "" + text;
            }
            const TRAILING_SLASH_RE = /\/$/;
            const removeTrailingSlash = (path)=>path.replace(TRAILING_SLASH_RE, "");
            function parseURL(parseQuery2, location2, currentLocation = "/") {
                let path, query = {}, searchString = "", hash2 = "";
                const hashPos = location2.indexOf("#");
                let searchPos = location2.indexOf("?");
                if (hashPos < searchPos && hashPos >= 0) {
                    searchPos = -1;
                }
                if (searchPos > -1) {
                    path = location2.slice(0, searchPos);
                    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
                    query = parseQuery2(searchString);
                }
                if (hashPos > -1) {
                    path = path || location2.slice(0, hashPos);
                    hash2 = location2.slice(hashPos, location2.length);
                }
                path = resolveRelativePath(path != null ? path : location2, currentLocation);
                return {
                    fullPath: path + (searchString && "?") + searchString + hash2,
                    path,
                    query,
                    hash: decode(hash2)
                };
            }
            function stringifyURL(stringifyQuery2, location2) {
                const query = location2.query ? stringifyQuery2(location2.query) : "";
                return location2.path + (query && "?") + query + (location2.hash || "");
            }
            function stripBase(pathname, base) {
                if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;
                return pathname.slice(base.length) || "/";
            }
            function isSameRouteLocation(stringifyQuery2, a, b) {
                const aLastIndex = a.matched.length - 1;
                const bLastIndex = b.matched.length - 1;
                return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
            }
            function isSameRouteRecord(a, b) {
                return (a.aliasOf || a) === (b.aliasOf || b);
            }
            function isSameRouteLocationParams(a, b) {
                if (Object.keys(a).length !== Object.keys(b).length) return false;
                for(const key in a){
                    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;
                }
                return true;
            }
            function isSameRouteLocationParamsValue(a, b) {
                return isArray$1(a) ? isEquivalentArray(a, b) : isArray$1(b) ? isEquivalentArray(b, a) : a === b;
            }
            function isEquivalentArray(a, b) {
                return isArray$1(b) ? a.length === b.length && a.every((value, i)=>value === b[i]) : a.length === 1 && a[0] === b;
            }
            function resolveRelativePath(to, from) {
                if (to.startsWith("/")) return to;
                if (!to) return from;
                const fromSegments = from.split("/");
                const toSegments = to.split("/");
                const lastToSegment = toSegments[toSegments.length - 1];
                if (lastToSegment === ".." || lastToSegment === ".") {
                    toSegments.push("");
                }
                let position = fromSegments.length - 1;
                let toPosition;
                let segment;
                for(toPosition = 0; toPosition < toSegments.length; toPosition++){
                    segment = toSegments[toPosition];
                    if (segment === ".") continue;
                    if (segment === "..") {
                        if (position > 1) position--;
                    } else break;
                }
                return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
            }
            const START_LOCATION_NORMALIZED = {
                path: "/",
                name: void 0,
                params: {},
                query: {},
                hash: "",
                fullPath: "/",
                matched: [],
                meta: {},
                redirectedFrom: void 0
            };
            var NavigationType;
            (function(NavigationType2) {
                NavigationType2["pop"] = "pop";
                NavigationType2["push"] = "push";
            })(NavigationType || (NavigationType = {}));
            var NavigationDirection;
            (function(NavigationDirection2) {
                NavigationDirection2["back"] = "back";
                NavigationDirection2["forward"] = "forward";
                NavigationDirection2["unknown"] = "";
            })(NavigationDirection || (NavigationDirection = {}));
            function normalizeBase(base) {
                if (!base) {
                    if (isBrowser) {
                        const baseEl = document.querySelector("base");
                        base = baseEl && baseEl.getAttribute("href") || "/";
                        base = base.replace(/^\w+:\/\/[^\/]+/, "");
                    } else {
                        base = "/";
                    }
                }
                if (base[0] !== "/" && base[0] !== "#") base = "/" + base;
                return removeTrailingSlash(base);
            }
            const BEFORE_HASH_RE = /^[^#]+#/;
            function createHref(base, location2) {
                return base.replace(BEFORE_HASH_RE, "#") + location2;
            }
            function getElementPosition(el, offset2) {
                const docRect = document.documentElement.getBoundingClientRect();
                const elRect = el.getBoundingClientRect();
                return {
                    behavior: offset2.behavior,
                    left: elRect.left - docRect.left - (offset2.left || 0),
                    top: elRect.top - docRect.top - (offset2.top || 0)
                };
            }
            const computeScrollPosition = ()=>({
                    left: window.scrollX,
                    top: window.scrollY
                });
            function scrollToPosition(position) {
                let scrollToOptions;
                if ("el" in position) {
                    const positionEl = position.el;
                    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
                    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
                    if (!el) {
                        return;
                    }
                    scrollToOptions = getElementPosition(el, position);
                } else {
                    scrollToOptions = position;
                }
                if ("scrollBehavior" in document.documentElement.style) window.scrollTo(scrollToOptions);
                else {
                    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
                }
            }
            function getScrollKey(path, delta) {
                const position = history.state ? history.state.position - delta : -1;
                return position + path;
            }
            const scrollPositions = new Map();
            function saveScrollPosition(key, scrollPosition) {
                scrollPositions.set(key, scrollPosition);
            }
            function getSavedScrollPosition(key) {
                const scroll = scrollPositions.get(key);
                scrollPositions.delete(key);
                return scroll;
            }
            let createBaseLocation = ()=>location.protocol + "//" + location.host;
            function createCurrentLocation(base, location2) {
                const { pathname, search, hash: hash2 } = location2;
                const hashPos = base.indexOf("#");
                if (hashPos > -1) {
                    let slicePos = hash2.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
                    let pathFromHash = hash2.slice(slicePos);
                    if (pathFromHash[0] !== "/") pathFromHash = "/" + pathFromHash;
                    return stripBase(pathFromHash, "");
                }
                const path = stripBase(pathname, base);
                return path + search + hash2;
            }
            function useHistoryListeners(base, historyState, currentLocation, replace2) {
                let listeners = [];
                let teardowns = [];
                let pauseState = null;
                const popStateHandler = ({ state })=>{
                    const to = createCurrentLocation(base, location);
                    const from = currentLocation.value;
                    const fromState = historyState.value;
                    let delta = 0;
                    if (state) {
                        currentLocation.value = to;
                        historyState.value = state;
                        if (pauseState && pauseState === from) {
                            pauseState = null;
                            return;
                        }
                        delta = fromState ? state.position - fromState.position : 0;
                    } else {
                        replace2(to);
                    }
                    listeners.forEach((listener2)=>{
                        listener2(currentLocation.value, from, {
                            delta,
                            type: NavigationType.pop,
                            direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
                        });
                    });
                };
                function pauseListeners() {
                    pauseState = currentLocation.value;
                }
                function listen(callback) {
                    listeners.push(callback);
                    const teardown = ()=>{
                        const index = listeners.indexOf(callback);
                        if (index > -1) listeners.splice(index, 1);
                    };
                    teardowns.push(teardown);
                    return teardown;
                }
                function beforeUnloadListener() {
                    const { history: history2 } = window;
                    if (!history2.state) return;
                    history2.replaceState(assign({}, history2.state, {
                        scroll: computeScrollPosition()
                    }), "");
                }
                function destroy() {
                    for (const teardown of teardowns)teardown();
                    teardowns = [];
                    window.removeEventListener("popstate", popStateHandler);
                    window.removeEventListener("beforeunload", beforeUnloadListener);
                }
                window.addEventListener("popstate", popStateHandler);
                window.addEventListener("beforeunload", beforeUnloadListener, {
                    passive: true
                });
                return {
                    pauseListeners,
                    listen,
                    destroy
                };
            }
            function buildState(back, current, forward, replaced = false, computeScroll = false) {
                return {
                    back,
                    current,
                    forward,
                    replaced,
                    position: window.history.length,
                    scroll: computeScroll ? computeScrollPosition() : null
                };
            }
            function useHistoryStateNavigation(base) {
                const { history: history2, location: location2 } = window;
                const currentLocation = {
                    value: createCurrentLocation(base, location2)
                };
                const historyState = {
                    value: history2.state
                };
                if (!historyState.value) {
                    changeLocation(currentLocation.value, {
                        back: null,
                        current: currentLocation.value,
                        forward: null,
                        position: history2.length - 1,
                        replaced: true,
                        scroll: null
                    }, true);
                }
                function changeLocation(to, state, replace22) {
                    const hashIndex = base.indexOf("#");
                    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
                    try {
                        history2[replace22 ? "replaceState" : "pushState"](state, "", url);
                        historyState.value = state;
                    } catch (err) {
                        {
                            console.error(err);
                        }
                        location2[replace22 ? "replace" : "assign"](url);
                    }
                }
                function replace2(to, data) {
                    const state = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, {
                        position: historyState.value.position
                    });
                    changeLocation(to, state, true);
                    currentLocation.value = to;
                }
                function push(to, data) {
                    const currentState = assign({}, historyState.value, history2.state, {
                        forward: to,
                        scroll: computeScrollPosition()
                    });
                    changeLocation(currentState.current, currentState, true);
                    const state = assign({}, buildState(currentLocation.value, to, null), {
                        position: currentState.position + 1
                    }, data);
                    changeLocation(to, state, false);
                    currentLocation.value = to;
                }
                return {
                    location: currentLocation,
                    state: historyState,
                    push,
                    replace: replace2
                };
            }
            function createWebHistory(base) {
                base = normalizeBase(base);
                const historyNavigation = useHistoryStateNavigation(base);
                const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
                function go(delta, triggerListeners = true) {
                    if (!triggerListeners) historyListeners.pauseListeners();
                    history.go(delta);
                }
                const routerHistory = assign({
                    location: "",
                    base,
                    go,
                    createHref: createHref.bind(null, base)
                }, historyNavigation, historyListeners);
                Object.defineProperty(routerHistory, "location", {
                    enumerable: true,
                    get: ()=>historyNavigation.location.value
                });
                Object.defineProperty(routerHistory, "state", {
                    enumerable: true,
                    get: ()=>historyNavigation.state.value
                });
                return routerHistory;
            }
            function createWebHashHistory(base) {
                base = location.host ? base || location.pathname + location.search : "";
                if (!base.includes("#")) base += "#";
                return createWebHistory(base);
            }
            function isRouteLocation(route) {
                return typeof route === "string" || route && typeof route === "object";
            }
            function isRouteName(name) {
                return typeof name === "string" || typeof name === "symbol";
            }
            const NavigationFailureSymbol = Symbol("");
            var NavigationFailureType;
            (function(NavigationFailureType2) {
                NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
                NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
                NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
            })(NavigationFailureType || (NavigationFailureType = {}));
            function createRouterError(type, params) {
                {
                    return assign(new Error(), {
                        type,
                        [NavigationFailureSymbol]: true
                    }, params);
                }
            }
            function isNavigationFailure(error, type) {
                return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
            }
            const BASE_PARAM_PATTERN = "[^/]+?";
            const BASE_PATH_PARSER_OPTIONS = {
                sensitive: false,
                strict: false,
                start: true,
                end: true
            };
            const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
            function tokensToParser(segments, extraOptions) {
                const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
                const score = [];
                let pattern = options.start ? "^" : "";
                const keys = [];
                for (const segment of segments){
                    const segmentScores = segment.length ? [] : [
                        90
                    ];
                    if (options.strict && !segment.length) pattern += "/";
                    for(let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++){
                        const token = segment[tokenIndex];
                        let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
                        if (token.type === 0) {
                            if (!tokenIndex) pattern += "/";
                            pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
                            subSegmentScore += 40;
                        } else if (token.type === 1) {
                            const { value, repeatable, optional, regexp } = token;
                            keys.push({
                                name: value,
                                repeatable,
                                optional
                            });
                            const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
                            if (re2 !== BASE_PARAM_PATTERN) {
                                subSegmentScore += 10;
                                try {
                                    new RegExp(`(${re2})`);
                                } catch (err) {
                                    throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
                                }
                            }
                            let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
                            if (!tokenIndex) subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
                            if (optional) subPattern += "?";
                            pattern += subPattern;
                            subSegmentScore += 20;
                            if (optional) subSegmentScore += -8;
                            if (repeatable) subSegmentScore += -20;
                            if (re2 === ".*") subSegmentScore += -50;
                        }
                        segmentScores.push(subSegmentScore);
                    }
                    score.push(segmentScores);
                }
                if (options.strict && options.end) {
                    const i = score.length - 1;
                    score[i][score[i].length - 1] += 0.7000000000000001;
                }
                if (!options.strict) pattern += "/?";
                if (options.end) pattern += "$";
                else if (options.strict && !pattern.endsWith("/")) pattern += "(?:/|$)";
                const re = new RegExp(pattern, options.sensitive ? "" : "i");
                function parse2(path) {
                    const match = path.match(re);
                    const params = {};
                    if (!match) return null;
                    for(let i = 1; i < match.length; i++){
                        const value = match[i] || "";
                        const key = keys[i - 1];
                        params[key.name] = value && key.repeatable ? value.split("/") : value;
                    }
                    return params;
                }
                function stringify(params) {
                    let path = "";
                    let avoidDuplicatedSlash = false;
                    for (const segment of segments){
                        if (!avoidDuplicatedSlash || !path.endsWith("/")) path += "/";
                        avoidDuplicatedSlash = false;
                        for (const token of segment){
                            if (token.type === 0) {
                                path += token.value;
                            } else if (token.type === 1) {
                                const { value, repeatable, optional } = token;
                                const param = value in params ? params[value] : "";
                                if (isArray$1(param) && !repeatable) {
                                    throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
                                }
                                const text = isArray$1(param) ? param.join("/") : param;
                                if (!text) {
                                    if (optional) {
                                        if (segment.length < 2) {
                                            if (path.endsWith("/")) path = path.slice(0, -1);
                                            else avoidDuplicatedSlash = true;
                                        }
                                    } else throw new Error(`Missing required param "${value}"`);
                                }
                                path += text;
                            }
                        }
                    }
                    return path || "/";
                }
                return {
                    re,
                    score,
                    keys,
                    parse: parse2,
                    stringify
                };
            }
            function compareScoreArray(a, b) {
                let i = 0;
                while(i < a.length && i < b.length){
                    const diff = b[i] - a[i];
                    if (diff) return diff;
                    i++;
                }
                if (a.length < b.length) {
                    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
                } else if (a.length > b.length) {
                    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
                }
                return 0;
            }
            function comparePathParserScore(a, b) {
                let i = 0;
                const aScore = a.score;
                const bScore = b.score;
                while(i < aScore.length && i < bScore.length){
                    const comp = compareScoreArray(aScore[i], bScore[i]);
                    if (comp) return comp;
                    i++;
                }
                if (Math.abs(bScore.length - aScore.length) === 1) {
                    if (isLastScoreNegative(aScore)) return 1;
                    if (isLastScoreNegative(bScore)) return -1;
                }
                return bScore.length - aScore.length;
            }
            function isLastScoreNegative(score) {
                const last = score[score.length - 1];
                return score.length > 0 && last[last.length - 1] < 0;
            }
            const ROOT_TOKEN = {
                type: 0,
                value: ""
            };
            const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
            function tokenizePath(path) {
                if (!path) return [
                    []
                ];
                if (path === "/") return [
                    [
                        ROOT_TOKEN
                    ]
                ];
                if (!path.startsWith("/")) {
                    throw new Error(`Invalid path "${path}"`);
                }
                function crash(message) {
                    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
                }
                let state = 0;
                let previousState = state;
                const tokens = [];
                let segment;
                function finalizeSegment() {
                    if (segment) tokens.push(segment);
                    segment = [];
                }
                let i = 0;
                let char;
                let buffer = "";
                let customRe = "";
                function consumeBuffer() {
                    if (!buffer) return;
                    if (state === 0) {
                        segment.push({
                            type: 0,
                            value: buffer
                        });
                    } else if (state === 1 || state === 2 || state === 3) {
                        if (segment.length > 1 && (char === "*" || char === "+")) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
                        segment.push({
                            type: 1,
                            value: buffer,
                            regexp: customRe,
                            repeatable: char === "*" || char === "+",
                            optional: char === "*" || char === "?"
                        });
                    } else {
                        crash("Invalid state to consume buffer");
                    }
                    buffer = "";
                }
                function addCharToBuffer() {
                    buffer += char;
                }
                while(i < path.length){
                    char = path[i++];
                    if (char === "\\" && state !== 2) {
                        previousState = state;
                        state = 4;
                        continue;
                    }
                    switch(state){
                        case 0:
                            if (char === "/") {
                                if (buffer) {
                                    consumeBuffer();
                                }
                                finalizeSegment();
                            } else if (char === ":") {
                                consumeBuffer();
                                state = 1;
                            } else {
                                addCharToBuffer();
                            }
                            break;
                        case 4:
                            addCharToBuffer();
                            state = previousState;
                            break;
                        case 1:
                            if (char === "(") {
                                state = 2;
                            } else if (VALID_PARAM_RE.test(char)) {
                                addCharToBuffer();
                            } else {
                                consumeBuffer();
                                state = 0;
                                if (char !== "*" && char !== "?" && char !== "+") i--;
                            }
                            break;
                        case 2:
                            if (char === ")") {
                                if (customRe[customRe.length - 1] == "\\") customRe = customRe.slice(0, -1) + char;
                                else state = 3;
                            } else {
                                customRe += char;
                            }
                            break;
                        case 3:
                            consumeBuffer();
                            state = 0;
                            if (char !== "*" && char !== "?" && char !== "+") i--;
                            customRe = "";
                            break;
                        default:
                            crash("Unknown state");
                            break;
                    }
                }
                if (state === 2) crash(`Unfinished custom RegExp for param "${buffer}"`);
                consumeBuffer();
                finalizeSegment();
                return tokens;
            }
            function createRouteRecordMatcher(record, parent, options) {
                const parser = tokensToParser(tokenizePath(record.path), options);
                const matcher = assign(parser, {
                    record,
                    parent,
                    children: [],
                    alias: []
                });
                if (parent) {
                    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);
                }
                return matcher;
            }
            function createRouterMatcher(routes2, globalOptions) {
                const matchers = [];
                const matcherMap = new Map();
                globalOptions = mergeOptions({
                    strict: false,
                    end: true,
                    sensitive: false
                }, globalOptions);
                function getRecordMatcher(name) {
                    return matcherMap.get(name);
                }
                function addRoute(record, parent, originalRecord) {
                    const isRootAdd = !originalRecord;
                    const mainNormalizedRecord = normalizeRouteRecord(record);
                    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
                    const options = mergeOptions(globalOptions, record);
                    const normalizedRecords = [
                        mainNormalizedRecord
                    ];
                    if ("alias" in record) {
                        const aliases = typeof record.alias === "string" ? [
                            record.alias
                        ] : record.alias;
                        for (const alias of aliases){
                            normalizedRecords.push(normalizeRouteRecord(assign({}, mainNormalizedRecord, {
                                components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
                                path: alias,
                                aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
                            })));
                        }
                    }
                    let matcher;
                    let originalMatcher;
                    for (const normalizedRecord of normalizedRecords){
                        const { path } = normalizedRecord;
                        if (parent && path[0] !== "/") {
                            const parentPath = parent.record.path;
                            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
                            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
                        }
                        matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
                        if (originalRecord) {
                            originalRecord.alias.push(matcher);
                        } else {
                            originalMatcher = originalMatcher || matcher;
                            if (originalMatcher !== matcher) originalMatcher.alias.push(matcher);
                            if (isRootAdd && record.name && !isAliasRecord(matcher)) {
                                removeRoute(record.name);
                            }
                        }
                        if (isMatchable(matcher)) {
                            insertMatcher(matcher);
                        }
                        if (mainNormalizedRecord.children) {
                            const children = mainNormalizedRecord.children;
                            for(let i = 0; i < children.length; i++){
                                addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
                            }
                        }
                        originalRecord = originalRecord || matcher;
                    }
                    return originalMatcher ? ()=>{
                        removeRoute(originalMatcher);
                    } : noop$3;
                }
                function removeRoute(matcherRef) {
                    if (isRouteName(matcherRef)) {
                        const matcher = matcherMap.get(matcherRef);
                        if (matcher) {
                            matcherMap.delete(matcherRef);
                            matchers.splice(matchers.indexOf(matcher), 1);
                            matcher.children.forEach(removeRoute);
                            matcher.alias.forEach(removeRoute);
                        }
                    } else {
                        const index = matchers.indexOf(matcherRef);
                        if (index > -1) {
                            matchers.splice(index, 1);
                            if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);
                            matcherRef.children.forEach(removeRoute);
                            matcherRef.alias.forEach(removeRoute);
                        }
                    }
                }
                function getRoutes() {
                    return matchers;
                }
                function insertMatcher(matcher) {
                    const index = findInsertionIndex(matcher, matchers);
                    matchers.splice(index, 0, matcher);
                    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);
                }
                function resolve2(location2, currentLocation) {
                    let matcher;
                    let params = {};
                    let path;
                    let name;
                    if ("name" in location2 && location2.name) {
                        matcher = matcherMap.get(location2.name);
                        if (!matcher) throw createRouterError(1, {
                            location: location2
                        });
                        name = matcher.record.name;
                        params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k)=>!k.optional).concat(matcher.parent ? matcher.parent.keys.filter((k)=>k.optional) : []).map((k)=>k.name)), location2.params && paramsFromLocation(location2.params, matcher.keys.map((k)=>k.name)));
                        path = matcher.stringify(params);
                    } else if (location2.path != null) {
                        path = location2.path;
                        matcher = matchers.find((m)=>m.re.test(path));
                        if (matcher) {
                            params = matcher.parse(path);
                            name = matcher.record.name;
                        }
                    } else {
                        matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m)=>m.re.test(currentLocation.path));
                        if (!matcher) throw createRouterError(1, {
                            location: location2,
                            currentLocation
                        });
                        name = matcher.record.name;
                        params = assign({}, currentLocation.params, location2.params);
                        path = matcher.stringify(params);
                    }
                    const matched = [];
                    let parentMatcher = matcher;
                    while(parentMatcher){
                        matched.unshift(parentMatcher.record);
                        parentMatcher = parentMatcher.parent;
                    }
                    return {
                        name,
                        path,
                        params,
                        matched,
                        meta: mergeMetaFields(matched)
                    };
                }
                routes2.forEach((route)=>addRoute(route));
                function clearRoutes() {
                    matchers.length = 0;
                    matcherMap.clear();
                }
                return {
                    addRoute,
                    resolve: resolve2,
                    removeRoute,
                    clearRoutes,
                    getRoutes,
                    getRecordMatcher
                };
            }
            function paramsFromLocation(params, keys) {
                const newParams = {};
                for (const key of keys){
                    if (key in params) newParams[key] = params[key];
                }
                return newParams;
            }
            function normalizeRouteRecord(record) {
                const normalized = {
                    path: record.path,
                    redirect: record.redirect,
                    name: record.name,
                    meta: record.meta || {},
                    aliasOf: record.aliasOf,
                    beforeEnter: record.beforeEnter,
                    props: normalizeRecordProps(record),
                    children: record.children || [],
                    instances: {},
                    leaveGuards: new Set(),
                    updateGuards: new Set(),
                    enterCallbacks: {},
                    components: "components" in record ? record.components || null : record.component && {
                        default: record.component
                    }
                };
                Object.defineProperty(normalized, "mods", {
                    value: {}
                });
                return normalized;
            }
            function normalizeRecordProps(record) {
                const propsObject = {};
                const props = record.props || false;
                if ("component" in record) {
                    propsObject.default = props;
                } else {
                    for(const name in record.components)propsObject[name] = typeof props === "object" ? props[name] : props;
                }
                return propsObject;
            }
            function isAliasRecord(record) {
                while(record){
                    if (record.record.aliasOf) return true;
                    record = record.parent;
                }
                return false;
            }
            function mergeMetaFields(matched) {
                return matched.reduce((meta, record)=>assign(meta, record.meta), {});
            }
            function mergeOptions(defaults2, partialOptions) {
                const options = {};
                for(const key in defaults2){
                    options[key] = key in partialOptions ? partialOptions[key] : defaults2[key];
                }
                return options;
            }
            function findInsertionIndex(matcher, matchers) {
                let lower = 0;
                let upper = matchers.length;
                while(lower !== upper){
                    const mid = lower + upper >> 1;
                    const sortOrder = comparePathParserScore(matcher, matchers[mid]);
                    if (sortOrder < 0) {
                        upper = mid;
                    } else {
                        lower = mid + 1;
                    }
                }
                const insertionAncestor = getInsertionAncestor(matcher);
                if (insertionAncestor) {
                    upper = matchers.lastIndexOf(insertionAncestor, upper - 1);
                }
                return upper;
            }
            function getInsertionAncestor(matcher) {
                let ancestor = matcher;
                while(ancestor = ancestor.parent){
                    if (isMatchable(ancestor) && comparePathParserScore(matcher, ancestor) === 0) {
                        return ancestor;
                    }
                }
                return;
            }
            function isMatchable({ record }) {
                return !!(record.name || record.components && Object.keys(record.components).length || record.redirect);
            }
            function parseQuery(search) {
                const query = {};
                if (search === "" || search === "?") return query;
                const hasLeadingIM = search[0] === "?";
                const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
                for(let i = 0; i < searchParams.length; ++i){
                    const searchParam = searchParams[i].replace(PLUS_RE, " ");
                    const eqPos = searchParam.indexOf("=");
                    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
                    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
                    if (key in query) {
                        let currentValue = query[key];
                        if (!isArray$1(currentValue)) {
                            currentValue = query[key] = [
                                currentValue
                            ];
                        }
                        currentValue.push(value);
                    } else {
                        query[key] = value;
                    }
                }
                return query;
            }
            function stringifyQuery(query) {
                let search = "";
                for(let key in query){
                    const value = query[key];
                    key = encodeQueryKey(key);
                    if (value == null) {
                        if (value !== void 0) {
                            search += (search.length ? "&" : "") + key;
                        }
                        continue;
                    }
                    const values = isArray$1(value) ? value.map((v)=>v && encodeQueryValue(v)) : [
                        value && encodeQueryValue(value)
                    ];
                    values.forEach((value2)=>{
                        if (value2 !== void 0) {
                            search += (search.length ? "&" : "") + key;
                            if (value2 != null) search += "=" + value2;
                        }
                    });
                }
                return search;
            }
            function normalizeQuery(query) {
                const normalizedQuery = {};
                for(const key in query){
                    const value = query[key];
                    if (value !== void 0) {
                        normalizedQuery[key] = isArray$1(value) ? value.map((v)=>v == null ? null : "" + v) : value == null ? value : "" + value;
                    }
                }
                return normalizedQuery;
            }
            const matchedRouteKey = Symbol("");
            const viewDepthKey = Symbol("");
            const routerKey = Symbol("");
            const routeLocationKey = Symbol("");
            const routerViewLocationKey = Symbol("");
            function useCallbacks() {
                let handlers = [];
                function add(handler) {
                    handlers.push(handler);
                    return ()=>{
                        const i = handlers.indexOf(handler);
                        if (i > -1) handlers.splice(i, 1);
                    };
                }
                function reset() {
                    handlers = [];
                }
                return {
                    add,
                    list: ()=>handlers.slice(),
                    reset
                };
            }
            function guardToPromiseFn(guard, to, from, record, name, runWithContext = (fn)=>fn()) {
                const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
                return ()=>new Promise((resolve2, reject)=>{
                        const next = (valid)=>{
                            if (valid === false) {
                                reject(createRouterError(4, {
                                    from,
                                    to
                                }));
                            } else if (valid instanceof Error) {
                                reject(valid);
                            } else if (isRouteLocation(valid)) {
                                reject(createRouterError(2, {
                                    from: to,
                                    to: valid
                                }));
                            } else {
                                if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
                                    enterCallbackArray.push(valid);
                                }
                                resolve2();
                            }
                        };
                        const guardReturn = runWithContext(()=>guard.call(record && record.instances[name], to, from, next));
                        let guardCall = Promise.resolve(guardReturn);
                        if (guard.length < 3) guardCall = guardCall.then(next);
                        guardCall.catch((err)=>reject(err));
                    });
            }
            function extractComponentsGuards(matched, guardType, to, from, runWithContext = (fn)=>fn()) {
                const guards = [];
                for (const record of matched){
                    for(const name in record.components){
                        let rawComponent = record.components[name];
                        if (guardType !== "beforeRouteEnter" && !record.instances[name]) continue;
                        if (isRouteComponent(rawComponent)) {
                            const options = rawComponent.__vccOpts || rawComponent;
                            const guard = options[guardType];
                            guard && guards.push(guardToPromiseFn(guard, to, from, record, name, runWithContext));
                        } else {
                            let componentPromise = rawComponent();
                            guards.push(()=>componentPromise.then((resolved)=>{
                                    if (!resolved) throw new Error(`Couldn't resolve component "${name}" at "${record.path}"`);
                                    const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
                                    record.mods[name] = resolved;
                                    record.components[name] = resolvedComponent;
                                    const options = resolvedComponent.__vccOpts || resolvedComponent;
                                    const guard = options[guardType];
                                    return guard && guardToPromiseFn(guard, to, from, record, name, runWithContext)();
                                }));
                        }
                    }
                }
                return guards;
            }
            function useLink(props) {
                const router2 = inject(routerKey);
                const currentRoute = inject(routeLocationKey);
                const route = computed(()=>{
                    const to = unref(props.to);
                    return router2.resolve(to);
                });
                const activeRecordIndex = computed(()=>{
                    const { matched } = route.value;
                    const { length } = matched;
                    const routeMatched = matched[length - 1];
                    const currentMatched = currentRoute.matched;
                    if (!routeMatched || !currentMatched.length) return -1;
                    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
                    if (index > -1) return index;
                    const parentRecordPath = getOriginalPath(matched[length - 2]);
                    return (length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index);
                });
                const isActive = computed(()=>activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
                const isExactActive = computed(()=>activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
                function navigate(e = {}) {
                    if (guardEvent(e)) {
                        const p2 = router2[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop$3);
                        if (props.viewTransition && typeof document !== "undefined" && "startViewTransition" in document) {
                            document.startViewTransition(()=>p2);
                        }
                        return p2;
                    }
                    return Promise.resolve();
                }
                return {
                    route,
                    href: computed(()=>route.value.href),
                    isActive,
                    isExactActive,
                    navigate
                };
            }
            function preferSingleVNode(vnodes) {
                return vnodes.length === 1 ? vnodes[0] : vnodes;
            }
            const RouterLinkImpl = defineComponent({
                name: "RouterLink",
                compatConfig: {
                    MODE: 3
                },
                props: {
                    to: {
                        type: [
                            String,
                            Object
                        ],
                        required: true
                    },
                    replace: Boolean,
                    activeClass: String,
                    exactActiveClass: String,
                    custom: Boolean,
                    ariaCurrentValue: {
                        type: String,
                        default: "page"
                    },
                    viewTransition: Boolean
                },
                useLink,
                setup (props, { slots }) {
                    const link = reactive(useLink(props));
                    const { options } = inject(routerKey);
                    const elClass = computed(()=>({
                            [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
                            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
                        }));
                    return ()=>{
                        const children = slots.default && preferSingleVNode(slots.default(link));
                        return props.custom ? children : h("a", {
                            "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
                            href: link.href,
                            onClick: link.navigate,
                            class: elClass.value
                        }, children);
                    };
                }
            });
            const RouterLink = RouterLinkImpl;
            function guardEvent(e) {
                if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
                if (e.defaultPrevented) return;
                if (e.button !== void 0 && e.button !== 0) return;
                if (e.currentTarget && e.currentTarget.getAttribute) {
                    const target = e.currentTarget.getAttribute("target");
                    if (/\b_blank\b/i.test(target)) return;
                }
                if (e.preventDefault) e.preventDefault();
                return true;
            }
            function includesParams(outer, inner) {
                for(const key in inner){
                    const innerValue = inner[key];
                    const outerValue = outer[key];
                    if (typeof innerValue === "string") {
                        if (innerValue !== outerValue) return false;
                    } else {
                        if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i)=>value !== outerValue[i])) return false;
                    }
                }
                return true;
            }
            function getOriginalPath(record) {
                return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
            }
            const getLinkClass = (propClass, globalClass, defaultClass)=>propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
            const RouterViewImpl = defineComponent({
                name: "RouterView",
                inheritAttrs: false,
                props: {
                    name: {
                        type: String,
                        default: "default"
                    },
                    route: Object
                },
                compatConfig: {
                    MODE: 3
                },
                setup (props, { attrs, slots }) {
                    const injectedRoute = inject(routerViewLocationKey);
                    const routeToDisplay = computed(()=>props.route || injectedRoute.value);
                    const injectedDepth = inject(viewDepthKey, 0);
                    const depth = computed(()=>{
                        let initialDepth = unref(injectedDepth);
                        const { matched } = routeToDisplay.value;
                        let matchedRoute;
                        while((matchedRoute = matched[initialDepth]) && !matchedRoute.components){
                            initialDepth++;
                        }
                        return initialDepth;
                    });
                    const matchedRouteRef = computed(()=>routeToDisplay.value.matched[depth.value]);
                    provide(viewDepthKey, computed(()=>depth.value + 1));
                    provide(matchedRouteKey, matchedRouteRef);
                    provide(routerViewLocationKey, routeToDisplay);
                    const viewRef = ref();
                    watch(()=>[
                            viewRef.value,
                            matchedRouteRef.value,
                            props.name
                        ], ([instance, to, name], [oldInstance, from, oldName])=>{
                        if (to) {
                            to.instances[name] = instance;
                            if (from && from !== to && instance && instance === oldInstance) {
                                if (!to.leaveGuards.size) {
                                    to.leaveGuards = from.leaveGuards;
                                }
                                if (!to.updateGuards.size) {
                                    to.updateGuards = from.updateGuards;
                                }
                            }
                        }
                        if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
                            (to.enterCallbacks[name] || []).forEach((callback)=>callback(instance));
                        }
                    }, {
                        flush: "post"
                    });
                    return ()=>{
                        const route = routeToDisplay.value;
                        const currentName = props.name;
                        const matchedRoute = matchedRouteRef.value;
                        const ViewComponent = matchedRoute && matchedRoute.components[currentName];
                        if (!ViewComponent) {
                            return normalizeSlot(slots.default, {
                                Component: ViewComponent,
                                route
                            });
                        }
                        const routePropsOption = matchedRoute.props[currentName];
                        const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
                        const onVnodeUnmounted = (vnode)=>{
                            if (vnode.component.isUnmounted) {
                                matchedRoute.instances[currentName] = null;
                            }
                        };
                        const component = h(ViewComponent, assign({}, routeProps, attrs, {
                            onVnodeUnmounted,
                            ref: viewRef
                        }));
                        return (normalizeSlot(slots.default, {
                            Component: component,
                            route
                        }) || component);
                    };
                }
            });
            function normalizeSlot(slot, data) {
                if (!slot) return null;
                const slotContent = slot(data);
                return slotContent.length === 1 ? slotContent[0] : slotContent;
            }
            const RouterView = RouterViewImpl;
            function createRouter(options) {
                const matcher = createRouterMatcher(options.routes, options);
                const parseQuery$1 = options.parseQuery || parseQuery;
                const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
                const routerHistory = options.history;
                const beforeGuards = useCallbacks();
                const beforeResolveGuards = useCallbacks();
                const afterGuards = useCallbacks();
                const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
                let pendingLocation = START_LOCATION_NORMALIZED;
                if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
                    history.scrollRestoration = "manual";
                }
                const normalizeParams = applyToParams.bind(null, (paramValue)=>"" + paramValue);
                const encodeParams = applyToParams.bind(null, encodeParam);
                const decodeParams = (applyToParams.bind(null, decode));
                function addRoute(parentOrRoute, route) {
                    let parent;
                    let record;
                    if (isRouteName(parentOrRoute)) {
                        parent = matcher.getRecordMatcher(parentOrRoute);
                        record = route;
                    } else {
                        record = parentOrRoute;
                    }
                    return matcher.addRoute(record, parent);
                }
                function removeRoute(name) {
                    const recordMatcher = matcher.getRecordMatcher(name);
                    if (recordMatcher) {
                        matcher.removeRoute(recordMatcher);
                    }
                }
                function getRoutes() {
                    return matcher.getRoutes().map((routeMatcher)=>routeMatcher.record);
                }
                function hasRoute(name) {
                    return !!matcher.getRecordMatcher(name);
                }
                function resolve2(rawLocation, currentLocation) {
                    currentLocation = assign({}, currentLocation || currentRoute.value);
                    if (typeof rawLocation === "string") {
                        const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
                        const matchedRoute2 = matcher.resolve({
                            path: locationNormalized.path
                        }, currentLocation);
                        const href2 = routerHistory.createHref(locationNormalized.fullPath);
                        return assign(locationNormalized, matchedRoute2, {
                            params: decodeParams(matchedRoute2.params),
                            hash: decode(locationNormalized.hash),
                            redirectedFrom: void 0,
                            href: href2
                        });
                    }
                    let matcherLocation;
                    if (rawLocation.path != null) {
                        matcherLocation = assign({}, rawLocation, {
                            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
                        });
                    } else {
                        const targetParams = assign({}, rawLocation.params);
                        for(const key in targetParams){
                            if (targetParams[key] == null) {
                                delete targetParams[key];
                            }
                        }
                        matcherLocation = assign({}, rawLocation, {
                            params: encodeParams(targetParams)
                        });
                        currentLocation.params = encodeParams(currentLocation.params);
                    }
                    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
                    const hash2 = rawLocation.hash || "";
                    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
                    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
                        hash: encodeHash(hash2),
                        path: matchedRoute.path
                    }));
                    const href = routerHistory.createHref(fullPath);
                    return assign({
                        fullPath,
                        hash: hash2,
                        query: (stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {})
                    }, matchedRoute, {
                        redirectedFrom: void 0,
                        href
                    });
                }
                function locationAsObject(to) {
                    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
                }
                function checkCanceledNavigation(to, from) {
                    if (pendingLocation !== to) {
                        return createRouterError(8, {
                            from,
                            to
                        });
                    }
                }
                function push(to) {
                    return pushWithRedirect(to);
                }
                function replace2(to) {
                    return push(assign(locationAsObject(to), {
                        replace: true
                    }));
                }
                function handleRedirectRecord(to) {
                    const lastMatched = to.matched[to.matched.length - 1];
                    if (lastMatched && lastMatched.redirect) {
                        const { redirect } = lastMatched;
                        let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
                        if (typeof newTargetLocation === "string") {
                            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : ({
                                path: newTargetLocation
                            });
                            newTargetLocation.params = {};
                        }
                        return assign({
                            query: to.query,
                            hash: to.hash,
                            params: newTargetLocation.path != null ? {} : to.params
                        }, newTargetLocation);
                    }
                }
                function pushWithRedirect(to, redirectedFrom) {
                    const targetLocation = pendingLocation = resolve2(to);
                    const from = currentRoute.value;
                    const data = to.state;
                    const force = to.force;
                    const replace22 = to.replace === true;
                    const shouldRedirect = handleRedirectRecord(targetLocation);
                    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
                        state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
                        force,
                        replace: replace22
                    }), redirectedFrom || targetLocation);
                    const toLocation = targetLocation;
                    toLocation.redirectedFrom = redirectedFrom;
                    let failure;
                    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
                        failure = createRouterError(16, {
                            to: toLocation,
                            from
                        });
                        handleScroll(from, from, true, false);
                    }
                    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error)=>isNavigationFailure(error) ? (isNavigationFailure(error, 2) ? error : markAsReady(error)) : (triggerError(error, toLocation, from))).then((failure2)=>{
                        if (failure2) {
                            if (isNavigationFailure(failure2, 2)) {
                                return pushWithRedirect(assign({
                                    replace: replace22
                                }, locationAsObject(failure2.to), {
                                    state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                                    force
                                }), redirectedFrom || toLocation);
                            }
                        } else {
                            failure2 = finalizeNavigation(toLocation, from, true, replace22, data);
                        }
                        triggerAfterEach(toLocation, from, failure2);
                        return failure2;
                    });
                }
                function checkCanceledNavigationAndReject(to, from) {
                    const error = checkCanceledNavigation(to, from);
                    return error ? Promise.reject(error) : Promise.resolve();
                }
                function runWithContext(fn) {
                    const app2 = installedApps.values().next().value;
                    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
                }
                function navigate(to, from) {
                    let guards;
                    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
                    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
                    for (const record of leavingRecords){
                        record.leaveGuards.forEach((guard)=>{
                            guards.push(guardToPromiseFn(guard, to, from));
                        });
                    }
                    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
                    guards.push(canceledNavigationCheck);
                    return runGuardQueue(guards).then(()=>{
                        guards = [];
                        for (const guard of beforeGuards.list()){
                            guards.push(guardToPromiseFn(guard, to, from));
                        }
                        guards.push(canceledNavigationCheck);
                        return runGuardQueue(guards);
                    }).then(()=>{
                        guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
                        for (const record of updatingRecords){
                            record.updateGuards.forEach((guard)=>{
                                guards.push(guardToPromiseFn(guard, to, from));
                            });
                        }
                        guards.push(canceledNavigationCheck);
                        return runGuardQueue(guards);
                    }).then(()=>{
                        guards = [];
                        for (const record of enteringRecords){
                            if (record.beforeEnter) {
                                if (isArray$1(record.beforeEnter)) {
                                    for (const beforeEnter of record.beforeEnter)guards.push(guardToPromiseFn(beforeEnter, to, from));
                                } else {
                                    guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                                }
                            }
                        }
                        guards.push(canceledNavigationCheck);
                        return runGuardQueue(guards);
                    }).then(()=>{
                        to.matched.forEach((record)=>record.enterCallbacks = {});
                        guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from, runWithContext);
                        guards.push(canceledNavigationCheck);
                        return runGuardQueue(guards);
                    }).then(()=>{
                        guards = [];
                        for (const guard of beforeResolveGuards.list()){
                            guards.push(guardToPromiseFn(guard, to, from));
                        }
                        guards.push(canceledNavigationCheck);
                        return runGuardQueue(guards);
                    }).catch((err)=>isNavigationFailure(err, 8) ? err : Promise.reject(err));
                }
                function triggerAfterEach(to, from, failure) {
                    afterGuards.list().forEach((guard)=>runWithContext(()=>guard(to, from, failure)));
                }
                function finalizeNavigation(toLocation, from, isPush, replace22, data) {
                    const error = checkCanceledNavigation(toLocation, from);
                    if (error) return error;
                    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
                    const state = !isBrowser ? {} : history.state;
                    if (isPush) {
                        if (replace22 || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({
                            scroll: isFirstNavigation && state && state.scroll
                        }, data));
                        else routerHistory.push(toLocation.fullPath, data);
                    }
                    currentRoute.value = toLocation;
                    handleScroll(toLocation, from, isPush, isFirstNavigation);
                    markAsReady();
                }
                let removeHistoryListener;
                function setupListeners() {
                    if (removeHistoryListener) return;
                    removeHistoryListener = routerHistory.listen((to, _from, info)=>{
                        if (!router2.listening) return;
                        const toLocation = resolve2(to);
                        const shouldRedirect = handleRedirectRecord(toLocation);
                        if (shouldRedirect) {
                            pushWithRedirect(assign(shouldRedirect, {
                                replace: true,
                                force: true
                            }), toLocation).catch(noop$3);
                            return;
                        }
                        pendingLocation = toLocation;
                        const from = currentRoute.value;
                        if (isBrowser) {
                            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
                        }
                        navigate(toLocation, from).catch((error)=>{
                            if (isNavigationFailure(error, 4 | 8)) {
                                return error;
                            }
                            if (isNavigationFailure(error, 2)) {
                                pushWithRedirect(assign(locationAsObject(error.to), {
                                    force: true
                                }), toLocation).then((failure)=>{
                                    if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                                        routerHistory.go(-1, false);
                                    }
                                }).catch(noop$3);
                                return Promise.reject();
                            }
                            if (info.delta) {
                                routerHistory.go(-info.delta, false);
                            }
                            return triggerError(error, toLocation, from);
                        }).then((failure)=>{
                            failure = failure || finalizeNavigation(toLocation, from, false);
                            if (failure) {
                                if (info.delta && !isNavigationFailure(failure, 8)) {
                                    routerHistory.go(-info.delta, false);
                                } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
                                    routerHistory.go(-1, false);
                                }
                            }
                            triggerAfterEach(toLocation, from, failure);
                        }).catch(noop$3);
                    });
                }
                let readyHandlers = useCallbacks();
                let errorListeners = useCallbacks();
                let ready;
                function triggerError(error, to, from) {
                    markAsReady(error);
                    const list = errorListeners.list();
                    if (list.length) {
                        list.forEach((handler)=>handler(error, to, from));
                    } else {
                        console.error(error);
                    }
                    return Promise.reject(error);
                }
                function isReady() {
                    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();
                    return new Promise((resolve22, reject)=>{
                        readyHandlers.add([
                            resolve22,
                            reject
                        ]);
                    });
                }
                function markAsReady(err) {
                    if (!ready) {
                        ready = !err;
                        setupListeners();
                        readyHandlers.list().forEach(([resolve22, reject])=>err ? reject(err) : resolve22());
                        readyHandlers.reset();
                    }
                    return err;
                }
                function handleScroll(to, from, isPush, isFirstNavigation) {
                    const { scrollBehavior } = options;
                    if (!isBrowser || !scrollBehavior) return Promise.resolve();
                    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
                    return nextTick().then(()=>scrollBehavior(to, from, scrollPosition)).then((position)=>position && scrollToPosition(position)).catch((err)=>triggerError(err, to, from));
                }
                const go = (delta)=>routerHistory.go(delta);
                let started;
                const installedApps = new Set();
                const router2 = {
                    currentRoute,
                    listening: true,
                    addRoute,
                    removeRoute,
                    clearRoutes: matcher.clearRoutes,
                    hasRoute,
                    getRoutes,
                    resolve: resolve2,
                    options,
                    push,
                    replace: replace2,
                    go,
                    back: ()=>go(-1),
                    forward: ()=>go(1),
                    beforeEach: beforeGuards.add,
                    beforeResolve: beforeResolveGuards.add,
                    afterEach: afterGuards.add,
                    onError: errorListeners.add,
                    isReady,
                    install (app2) {
                        const router22 = this;
                        app2.component("RouterLink", RouterLink);
                        app2.component("RouterView", RouterView);
                        app2.config.globalProperties.$router = router22;
                        Object.defineProperty(app2.config.globalProperties, "$route", {
                            enumerable: true,
                            get: ()=>unref(currentRoute)
                        });
                        if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
                            started = true;
                            push(routerHistory.location).catch((err)=>{});
                        }
                        const reactiveRoute = {};
                        for(const key in START_LOCATION_NORMALIZED){
                            Object.defineProperty(reactiveRoute, key, {
                                get: ()=>currentRoute.value[key],
                                enumerable: true
                            });
                        }
                        app2.provide(routerKey, router22);
                        app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
                        app2.provide(routerViewLocationKey, currentRoute);
                        const unmountApp = app2.unmount;
                        installedApps.add(app2);
                        app2.unmount = function() {
                            installedApps.delete(app2);
                            if (installedApps.size < 1) {
                                pendingLocation = START_LOCATION_NORMALIZED;
                                removeHistoryListener && removeHistoryListener();
                                removeHistoryListener = null;
                                currentRoute.value = START_LOCATION_NORMALIZED;
                                started = false;
                                ready = false;
                            }
                            unmountApp();
                        };
                    }
                };
                function runGuardQueue(guards) {
                    return guards.reduce((promise, guard)=>promise.then(()=>runWithContext(guard)), Promise.resolve());
                }
                return router2;
            }
            function extractChangingRecords(to, from) {
                const leavingRecords = [];
                const updatingRecords = [];
                const enteringRecords = [];
                const len = Math.max(from.matched.length, to.matched.length);
                for(let i = 0; i < len; i++){
                    const recordFrom = from.matched[i];
                    if (recordFrom) {
                        if (to.matched.find((record)=>isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);
                        else leavingRecords.push(recordFrom);
                    }
                    const recordTo = to.matched[i];
                    if (recordTo) {
                        if (!from.matched.find((record)=>isSameRouteRecord(record, recordTo))) {
                            enteringRecords.push(recordTo);
                        }
                    }
                }
                return [
                    leavingRecords,
                    updatingRecords,
                    enteringRecords
                ];
            }
            function useRoute(_name) {
                return inject(routeLocationKey);
            }
            const currentId = exports("A", ref());
            const currentData = exports("y", ref());
            const _export_sfc = exports("_", (sfc, props)=>{
                const target = sfc.__vccOpts || sfc;
                for (const [key, val] of props){
                    target[key] = val;
                }
                return target;
            });
            const _sfc_main$1 = {
                name: "Store",
                setup () {
                    return {
                        currentId
                    };
                }
            };
            function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
                return null;
            }
            const Store = _export_sfc(_sfc_main$1, [
                [
                    "render",
                    _sfc_render
                ]
            ]);
            const _hoisted_1 = {
                class: "c-main-wrapper"
            };
            const _hoisted_2 = {
                class: "navbar navbar-expand-lg fixed-top navbar-dark bg-dark-primary",
                style: {
                    "height": "60px"
                }
            };
            const _hoisted_3 = {
                class: "container-fluid"
            };
            const _hoisted_4 = {
                class: "navbar-brand"
            };
            const _hoisted_5 = [
                "src"
            ];
            const _hoisted_6 = {
                class: "d-flex flex-column flex-md-row",
                style: {
                    "margin-top": "60px"
                }
            };
            const _hoisted_7 = {
                class: "h-w-sidebar",
                style: {
                    "background-color": "var(--bs-gray-800)"
                }
            };
            const _hoisted_8 = {
                class: "nav flex-column position-sticky",
                style: {
                    "min-width": "200px",
                    "top": "60px",
                    "background-color": "var(--bs-gray-800)"
                }
            };
            const _hoisted_9 = {
                class: "nav-item nav-item--dashboard"
            };
            const _hoisted_10 = {
                class: "nav-item nav-item--system"
            };
            const _hoisted_11 = {
                class: "nav-item nav-item--request"
            };
            const _hoisted_12 = {
                class: "nav-item nav-item--routing"
            };
            const _hoisted_13 = {
                class: "nav-item nav-item--timeline"
            };
            const _hoisted_14 = {
                class: "nav-item nav-item--timeline"
            };
            const _hoisted_15 = {
                class: "nav-item nav-item--db"
            };
            const _hoisted_16 = {
                class: "flex-grow-1"
            };
            const _sfc_main = {
                __name: "App",
                setup (__props) {
                    const route = useRoute();
                    const currentRoute = computed(()=>route.name);
                    return (_ctx, _cache)=>{
                        return openBlock(), createElementBlock("div", _hoisted_1, [
                            createBaseVNode("div", _hoisted_2, [
                                createBaseVNode("div", _hoisted_3, [
                                    createBaseVNode("div", _hoisted_4, [
                                        createBaseVNode("img", {
                                            src: unref(logo),
                                            alt: "logo",
                                            style: {
                                                "height": "30px"
                                            }
                                        }, null, 8, _hoisted_5)
                                    ]),
                                    _cache[0] || (_cache[0] = createBaseVNode("div", {
                                        class: ""
                                    }, null, -1))
                                ])
                            ]),
                            createBaseVNode("div", _hoisted_6, [
                                createBaseVNode("div", _hoisted_7, [
                                    createBaseVNode("div", _hoisted_8, [
                                        createBaseVNode("div", _hoisted_9, [
                                            createVNode(unref(RouterLink), {
                                                to: "/",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "dashboard"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[1] || (_cache[1] = [
                                                            createTextVNode(" Dashboard ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_10, [
                                            createVNode(unref(RouterLink), {
                                                to: "/system",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "system"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[2] || (_cache[2] = [
                                                            createTextVNode(" System ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_11, [
                                            createVNode(unref(RouterLink), {
                                                to: "/request",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "request"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[3] || (_cache[3] = [
                                                            createTextVNode(" Request ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_12, [
                                            createVNode(unref(RouterLink), {
                                                to: "/routing",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "routing"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[4] || (_cache[4] = [
                                                            createTextVNode(" Routing ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_13, [
                                            createVNode(unref(RouterLink), {
                                                to: "/timeline",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "timeline"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[5] || (_cache[5] = [
                                                            createTextVNode(" Timeline ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_14, [
                                            createVNode(unref(RouterLink), {
                                                to: "/events",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "events"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[6] || (_cache[6] = [
                                                            createTextVNode(" Events ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ]),
                                        createBaseVNode("div", _hoisted_15, [
                                            createVNode(unref(RouterLink), {
                                                to: "/db",
                                                class: normalizeClass([
                                                    "c-sidebar-menu-item nav-link",
                                                    {
                                                        active: currentRoute.value === "db"
                                                    }
                                                ])
                                            }, {
                                                default: withCtx(()=>[
                                                        ..._cache[7] || (_cache[7] = [
                                                            createTextVNode(" Database ", -1)
                                                        ])
                                                    ]),
                                                _: 1
                                            }, 8, [
                                                "class"
                                            ])
                                        ])
                                    ])
                                ]),
                                createBaseVNode("div", _hoisted_16, [
                                    createVNode(unref(RouterView), null, {
                                        default: withCtx(({ Component })=>[
                                                (openBlock(), createBlock(Transition, {
                                                    name: "fade",
                                                    mode: "out-in",
                                                    key: unref(route).fullPath
                                                }, {
                                                    default: withCtx(()=>[
                                                            (openBlock(), createBlock(Suspense, null, {
                                                                default: withCtx(()=>[
                                                                        createBaseVNode("div", null, [
                                                                            (openBlock(), createBlock(resolveDynamicComponent(Component)))
                                                                        ])
                                                                    ]),
                                                                _: 2
                                                            }, 1024))
                                                        ]),
                                                    _: 2
                                                }, 1024))
                                            ]),
                                        _: 1
                                    })
                                ])
                            ]),
                            createVNode(Store)
                        ]);
                    };
                }
            };
            const App = _export_sfc(_sfc_main, [
                [
                    "__scopeId",
                    "data-v-86d05095"
                ]
            ]);
            function _defineProperty$1(e, r2, t2) {
                return (r2 = _toPropertyKey$1(r2)) in e ? Object.defineProperty(e, r2, {
                    value: t2,
                    enumerable: true,
                    configurable: true,
                    writable: true
                }) : e[r2] = t2, e;
            }
            function ownKeys$1(e, r2) {
                var t2 = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var o2 = Object.getOwnPropertySymbols(e);
                    r2 && (o2 = o2.filter(function(r3) {
                        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
                    })), t2.push.apply(t2, o2);
                }
                return t2;
            }
            function _objectSpread2$1(e) {
                for(var r2 = 1; r2 < arguments.length; r2++){
                    var t2 = null != arguments[r2] ? arguments[r2] : {};
                    r2 % 2 ? ownKeys$1(Object(t2), true).forEach(function(r3) {
                        _defineProperty$1(e, r3, t2[r3]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys$1(Object(t2)).forEach(function(r3) {
                        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
                    });
                }
                return e;
            }
            function _toPrimitive$1(t2, r2) {
                if ("object" != typeof t2 || !t2) return t2;
                var e = t2[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var i = e.call(t2, r2);
                    if ("object" != typeof i) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r2 ? String : Number)(t2);
            }
            function _toPropertyKey$1(t2) {
                var i = _toPrimitive$1(t2, "string");
                return "symbol" == typeof i ? i : i + "";
            }
            const noop$1 = ()=>{};
            let _WINDOW = {};
            let _DOCUMENT = {};
            let _MUTATION_OBSERVER = null;
            let _PERFORMANCE = {
                mark: noop$1,
                measure: noop$1
            };
            try {
                if (typeof window !== "undefined") _WINDOW = window;
                if (typeof document !== "undefined") _DOCUMENT = document;
                if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
                if (typeof performance !== "undefined") _PERFORMANCE = performance;
            } catch (e) {}
            const { userAgent = "" } = _WINDOW.navigator || {};
            const WINDOW = _WINDOW;
            const DOCUMENT = _DOCUMENT;
            const MUTATION_OBSERVER = _MUTATION_OBSERVER;
            const PERFORMANCE = _PERFORMANCE;
            !!WINDOW.document;
            const IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
            const IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
            var p = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, g = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
            var S = {
                classic: {
                    fa: "solid",
                    fas: "solid",
                    "fa-solid": "solid",
                    far: "regular",
                    "fa-regular": "regular",
                    fal: "light",
                    "fa-light": "light",
                    fat: "thin",
                    "fa-thin": "thin",
                    fab: "brands",
                    "fa-brands": "brands"
                },
                duotone: {
                    fa: "solid",
                    fad: "solid",
                    "fa-solid": "solid",
                    "fa-duotone": "solid",
                    fadr: "regular",
                    "fa-regular": "regular",
                    fadl: "light",
                    "fa-light": "light",
                    fadt: "thin",
                    "fa-thin": "thin"
                },
                sharp: {
                    fa: "solid",
                    fass: "solid",
                    "fa-solid": "solid",
                    fasr: "regular",
                    "fa-regular": "regular",
                    fasl: "light",
                    "fa-light": "light",
                    fast: "thin",
                    "fa-thin": "thin"
                },
                "sharp-duotone": {
                    fa: "solid",
                    fasds: "solid",
                    "fa-solid": "solid",
                    fasdr: "regular",
                    "fa-regular": "regular",
                    fasdl: "light",
                    "fa-light": "light",
                    fasdt: "thin",
                    "fa-thin": "thin"
                }
            }, A = {
                GROUP: "duotone-group",
                PRIMARY: "primary",
                SECONDARY: "secondary"
            }, P = [
                "fa-classic",
                "fa-duotone",
                "fa-sharp",
                "fa-sharp-duotone"
            ];
            var s = "classic", t = "duotone", r = "sharp", o = "sharp-duotone", L = [
                s,
                t,
                r,
                o
            ];
            var G = {
                classic: {
                    900: "fas",
                    400: "far",
                    normal: "far",
                    300: "fal",
                    100: "fat"
                },
                duotone: {
                    900: "fad",
                    400: "fadr",
                    300: "fadl",
                    100: "fadt"
                },
                sharp: {
                    900: "fass",
                    400: "fasr",
                    300: "fasl",
                    100: "fast"
                },
                "sharp-duotone": {
                    900: "fasds",
                    400: "fasdr",
                    300: "fasdl",
                    100: "fasdt"
                }
            };
            var lt = {
                "Font Awesome 6 Free": {
                    900: "fas",
                    400: "far"
                },
                "Font Awesome 6 Pro": {
                    900: "fas",
                    400: "far",
                    normal: "far",
                    300: "fal",
                    100: "fat"
                },
                "Font Awesome 6 Brands": {
                    400: "fab",
                    normal: "fab"
                },
                "Font Awesome 6 Duotone": {
                    900: "fad",
                    400: "fadr",
                    normal: "fadr",
                    300: "fadl",
                    100: "fadt"
                },
                "Font Awesome 6 Sharp": {
                    900: "fass",
                    400: "fasr",
                    normal: "fasr",
                    300: "fasl",
                    100: "fast"
                },
                "Font Awesome 6 Sharp Duotone": {
                    900: "fasds",
                    400: "fasdr",
                    normal: "fasdr",
                    300: "fasdl",
                    100: "fasdt"
                }
            };
            var pt = new Map([
                [
                    "classic",
                    {
                        defaultShortPrefixId: "fas",
                        defaultStyleId: "solid",
                        styleIds: [
                            "solid",
                            "regular",
                            "light",
                            "thin",
                            "brands"
                        ],
                        futureStyleIds: [],
                        defaultFontWeight: 900
                    }
                ],
                [
                    "sharp",
                    {
                        defaultShortPrefixId: "fass",
                        defaultStyleId: "solid",
                        styleIds: [
                            "solid",
                            "regular",
                            "light",
                            "thin"
                        ],
                        futureStyleIds: [],
                        defaultFontWeight: 900
                    }
                ],
                [
                    "duotone",
                    {
                        defaultShortPrefixId: "fad",
                        defaultStyleId: "solid",
                        styleIds: [
                            "solid",
                            "regular",
                            "light",
                            "thin"
                        ],
                        futureStyleIds: [],
                        defaultFontWeight: 900
                    }
                ],
                [
                    "sharp-duotone",
                    {
                        defaultShortPrefixId: "fasds",
                        defaultStyleId: "solid",
                        styleIds: [
                            "solid",
                            "regular",
                            "light",
                            "thin"
                        ],
                        futureStyleIds: [],
                        defaultFontWeight: 900
                    }
                ]
            ]), xt = {
                classic: {
                    solid: "fas",
                    regular: "far",
                    light: "fal",
                    thin: "fat",
                    brands: "fab"
                },
                duotone: {
                    solid: "fad",
                    regular: "fadr",
                    light: "fadl",
                    thin: "fadt"
                },
                sharp: {
                    solid: "fass",
                    regular: "fasr",
                    light: "fasl",
                    thin: "fast"
                },
                "sharp-duotone": {
                    solid: "fasds",
                    regular: "fasdr",
                    light: "fasdl",
                    thin: "fasdt"
                }
            };
            var Ft = [
                "fak",
                "fa-kit",
                "fakd",
                "fa-kit-duotone"
            ], St = {
                kit: {
                    fak: "kit",
                    "fa-kit": "kit"
                },
                "kit-duotone": {
                    fakd: "kit-duotone",
                    "fa-kit-duotone": "kit-duotone"
                }
            }, At = [
                "kit"
            ];
            var Ct = {
                kit: {
                    "fa-kit": "fak"
                }
            };
            var Lt = [
                "fak",
                "fakd"
            ], Wt = {
                kit: {
                    fak: "fa-kit"
                }
            };
            var Et = {
                kit: {
                    kit: "fak"
                },
                "kit-duotone": {
                    "kit-duotone": "fakd"
                }
            };
            var t$1 = {
                GROUP: "duotone-group",
                SWAP_OPACITY: "swap-opacity",
                PRIMARY: "primary",
                SECONDARY: "secondary"
            }, r$1 = [
                "fa-classic",
                "fa-duotone",
                "fa-sharp",
                "fa-sharp-duotone"
            ];
            var bt$1 = [
                "fak",
                "fa-kit",
                "fakd",
                "fa-kit-duotone"
            ];
            var Yt = {
                "Font Awesome Kit": {
                    400: "fak",
                    normal: "fak"
                },
                "Font Awesome Kit Duotone": {
                    400: "fakd",
                    normal: "fakd"
                }
            };
            var ua = {
                classic: {
                    "fa-brands": "fab",
                    "fa-duotone": "fad",
                    "fa-light": "fal",
                    "fa-regular": "far",
                    "fa-solid": "fas",
                    "fa-thin": "fat"
                },
                duotone: {
                    "fa-regular": "fadr",
                    "fa-light": "fadl",
                    "fa-thin": "fadt"
                },
                sharp: {
                    "fa-solid": "fass",
                    "fa-regular": "fasr",
                    "fa-light": "fasl",
                    "fa-thin": "fast"
                },
                "sharp-duotone": {
                    "fa-solid": "fasds",
                    "fa-regular": "fasdr",
                    "fa-light": "fasdl",
                    "fa-thin": "fasdt"
                }
            }, I$1 = {
                classic: [
                    "fas",
                    "far",
                    "fal",
                    "fat",
                    "fad"
                ],
                duotone: [
                    "fadr",
                    "fadl",
                    "fadt"
                ],
                sharp: [
                    "fass",
                    "fasr",
                    "fasl",
                    "fast"
                ],
                "sharp-duotone": [
                    "fasds",
                    "fasdr",
                    "fasdl",
                    "fasdt"
                ]
            }, ga = {
                classic: {
                    fab: "fa-brands",
                    fad: "fa-duotone",
                    fal: "fa-light",
                    far: "fa-regular",
                    fas: "fa-solid",
                    fat: "fa-thin"
                },
                duotone: {
                    fadr: "fa-regular",
                    fadl: "fa-light",
                    fadt: "fa-thin"
                },
                sharp: {
                    fass: "fa-solid",
                    fasr: "fa-regular",
                    fasl: "fa-light",
                    fast: "fa-thin"
                },
                "sharp-duotone": {
                    fasds: "fa-solid",
                    fasdr: "fa-regular",
                    fasdl: "fa-light",
                    fasdt: "fa-thin"
                }
            }, x = [
                "fa-solid",
                "fa-regular",
                "fa-light",
                "fa-thin",
                "fa-duotone",
                "fa-brands"
            ], Ia = [
                "fa",
                "fas",
                "far",
                "fal",
                "fat",
                "fad",
                "fadr",
                "fadl",
                "fadt",
                "fab",
                "fass",
                "fasr",
                "fasl",
                "fast",
                "fasds",
                "fasdr",
                "fasdl",
                "fasdt",
                ...r$1,
                ...x
            ], m$1 = [
                "solid",
                "regular",
                "light",
                "thin",
                "duotone",
                "brands"
            ], c$1 = [
                1,
                2,
                3,
                4,
                5,
                6,
                7,
                8,
                9,
                10
            ], F$1 = c$1.concat([
                11,
                12,
                13,
                14,
                15,
                16,
                17,
                18,
                19,
                20
            ]), ma = [
                ...Object.keys(I$1),
                ...m$1,
                "2xs",
                "xs",
                "sm",
                "lg",
                "xl",
                "2xl",
                "beat",
                "border",
                "fade",
                "beat-fade",
                "bounce",
                "flip-both",
                "flip-horizontal",
                "flip-vertical",
                "flip",
                "fw",
                "inverse",
                "layers-counter",
                "layers-text",
                "layers",
                "li",
                "pull-left",
                "pull-right",
                "pulse",
                "rotate-180",
                "rotate-270",
                "rotate-90",
                "rotate-by",
                "shake",
                "spin-pulse",
                "spin-reverse",
                "spin",
                "stack-1x",
                "stack-2x",
                "stack",
                "ul",
                t$1.GROUP,
                t$1.SWAP_OPACITY,
                t$1.PRIMARY,
                t$1.SECONDARY
            ].concat(c$1.map((a)=>"".concat(a, "x"))).concat(F$1.map((a)=>"w-".concat(a)));
            var wa = {
                "Font Awesome 5 Free": {
                    900: "fas",
                    400: "far"
                },
                "Font Awesome 5 Pro": {
                    900: "fas",
                    400: "far",
                    normal: "far",
                    300: "fal"
                },
                "Font Awesome 5 Brands": {
                    400: "fab",
                    normal: "fab"
                },
                "Font Awesome 5 Duotone": {
                    900: "fad"
                }
            };
            const NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
            const UNITS_IN_GRID = 16;
            const DEFAULT_CSS_PREFIX = "fa";
            const DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
            const DATA_FA_I2SVG = "data-fa-i2svg";
            const DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
            const DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
            const DATA_PREFIX = "data-prefix";
            const DATA_ICON = "data-icon";
            const HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
            const MUTATION_APPROACH_ASYNC = "async";
            const TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = [
                "HTML",
                "HEAD",
                "STYLE",
                "SCRIPT"
            ];
            const PRODUCTION$1 = (()=>{
                try {
                    return true;
                } catch (e$$1) {
                    return false;
                }
            })();
            function familyProxy(obj) {
                return new Proxy(obj, {
                    get (target, prop) {
                        return prop in target ? target[prop] : target[s];
                    }
                });
            }
            const _PREFIX_TO_STYLE = _objectSpread2$1({}, S);
            _PREFIX_TO_STYLE[s] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
                "fa-duotone": "duotone"
            }), S[s]), St["kit"]), St["kit-duotone"]);
            const PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
            const _STYLE_TO_PREFIX = _objectSpread2$1({}, xt);
            _STYLE_TO_PREFIX[s] = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
                duotone: "fad"
            }), _STYLE_TO_PREFIX[s]), Et["kit"]), Et["kit-duotone"]);
            const STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
            const _PREFIX_TO_LONG_STYLE = _objectSpread2$1({}, ga);
            _PREFIX_TO_LONG_STYLE[s] = _objectSpread2$1(_objectSpread2$1({}, _PREFIX_TO_LONG_STYLE[s]), Wt["kit"]);
            const PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
            const _LONG_STYLE_TO_PREFIX = _objectSpread2$1({}, ua);
            _LONG_STYLE_TO_PREFIX[s] = _objectSpread2$1(_objectSpread2$1({}, _LONG_STYLE_TO_PREFIX[s]), Ct["kit"]);
            familyProxy(_LONG_STYLE_TO_PREFIX);
            const ICON_SELECTION_SYNTAX_PATTERN = p;
            const LAYERS_TEXT_CLASSNAME = "fa-layers-text";
            const FONT_FAMILY_PATTERN = g;
            const _FONT_WEIGHT_TO_PREFIX = _objectSpread2$1({}, G);
            familyProxy(_FONT_WEIGHT_TO_PREFIX);
            const ATTRIBUTES_WATCHED_FOR_MUTATION = [
                "class",
                "data-prefix",
                "data-icon",
                "data-fa-transform",
                "data-fa-mask"
            ];
            const DUOTONE_CLASSES = A;
            const RESERVED_CLASSES = [
                ...At,
                ...ma
            ];
            const initial = WINDOW.FontAwesomeConfig || {};
            function getAttrConfig(attr) {
                var element = DOCUMENT.querySelector("script[" + attr + "]");
                if (element) {
                    return element.getAttribute(attr);
                }
            }
            function coerce(val) {
                if (val === "") return true;
                if (val === "false") return false;
                if (val === "true") return true;
                return val;
            }
            if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
                const attrs = [
                    [
                        "data-family-prefix",
                        "familyPrefix"
                    ],
                    [
                        "data-css-prefix",
                        "cssPrefix"
                    ],
                    [
                        "data-family-default",
                        "familyDefault"
                    ],
                    [
                        "data-style-default",
                        "styleDefault"
                    ],
                    [
                        "data-replacement-class",
                        "replacementClass"
                    ],
                    [
                        "data-auto-replace-svg",
                        "autoReplaceSvg"
                    ],
                    [
                        "data-auto-add-css",
                        "autoAddCss"
                    ],
                    [
                        "data-auto-a11y",
                        "autoA11y"
                    ],
                    [
                        "data-search-pseudo-elements",
                        "searchPseudoElements"
                    ],
                    [
                        "data-observe-mutations",
                        "observeMutations"
                    ],
                    [
                        "data-mutate-approach",
                        "mutateApproach"
                    ],
                    [
                        "data-keep-original-source",
                        "keepOriginalSource"
                    ],
                    [
                        "data-measure-performance",
                        "measurePerformance"
                    ],
                    [
                        "data-show-missing-icons",
                        "showMissingIcons"
                    ]
                ];
                attrs.forEach((_ref)=>{
                    let [attr, key] = _ref;
                    const val = coerce(getAttrConfig(attr));
                    if (val !== void 0 && val !== null) {
                        initial[key] = val;
                    }
                });
            }
            const _default = {
                styleDefault: "solid",
                familyDefault: s,
                cssPrefix: DEFAULT_CSS_PREFIX,
                replacementClass: DEFAULT_REPLACEMENT_CLASS,
                autoReplaceSvg: true,
                autoAddCss: true,
                autoA11y: true,
                searchPseudoElements: false,
                observeMutations: true,
                mutateApproach: "async",
                keepOriginalSource: true,
                measurePerformance: false,
                showMissingIcons: true
            };
            if (initial.familyPrefix) {
                initial.cssPrefix = initial.familyPrefix;
            }
            const _config = _objectSpread2$1(_objectSpread2$1({}, _default), initial);
            if (!_config.autoReplaceSvg) _config.observeMutations = false;
            const config = {};
            Object.keys(_default).forEach((key)=>{
                Object.defineProperty(config, key, {
                    enumerable: true,
                    set: function(val) {
                        _config[key] = val;
                        _onChangeCb.forEach((cb)=>cb(config));
                    },
                    get: function() {
                        return _config[key];
                    }
                });
            });
            Object.defineProperty(config, "familyPrefix", {
                enumerable: true,
                set: function(val) {
                    _config.cssPrefix = val;
                    _onChangeCb.forEach((cb)=>cb(config));
                },
                get: function() {
                    return _config.cssPrefix;
                }
            });
            WINDOW.FontAwesomeConfig = config;
            const _onChangeCb = [];
            function onChange(cb) {
                _onChangeCb.push(cb);
                return ()=>{
                    _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
                };
            }
            const d$2 = UNITS_IN_GRID;
            const meaninglessTransform = {
                size: 16,
                x: 0,
                y: 0,
                rotate: 0,
                flipX: false,
                flipY: false
            };
            function insertCss(css2) {
                if (!css2 || !IS_DOM) {
                    return;
                }
                const style = DOCUMENT.createElement("style");
                style.setAttribute("type", "text/css");
                style.innerHTML = css2;
                const headChildren = DOCUMENT.head.childNodes;
                let beforeChild = null;
                for(let i = headChildren.length - 1; i > -1; i--){
                    const child = headChildren[i];
                    const tagName = (child.tagName || "").toUpperCase();
                    if ([
                        "STYLE",
                        "LINK"
                    ].indexOf(tagName) > -1) {
                        beforeChild = child;
                    }
                }
                DOCUMENT.head.insertBefore(style, beforeChild);
                return css2;
            }
            const idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            function nextUniqueId() {
                let size = 12;
                let id = "";
                while(size-- > 0){
                    id += idPool[Math.random() * 62 | 0];
                }
                return id;
            }
            function toArray$1(obj) {
                const array = [];
                for(let i = (obj || []).length >>> 0; i--;){
                    array[i] = obj[i];
                }
                return array;
            }
            function classArray(node) {
                if (node.classList) {
                    return toArray$1(node.classList);
                } else {
                    return (node.getAttribute("class") || "").split(" ").filter((i)=>i);
                }
            }
            function htmlEscape(str) {
                return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }
            function joinAttributes(attributes) {
                return Object.keys(attributes || {}).reduce((acc, attributeName)=>{
                    return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
                }, "").trim();
            }
            function joinStyles(styles2) {
                return Object.keys(styles2 || {}).reduce((acc, styleName)=>{
                    return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
                }, "");
            }
            function transformIsMeaningful(transform) {
                return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
            }
            function transformForSvg(_ref) {
                let { transform, containerWidth, iconWidth } = _ref;
                const outer = {
                    transform: "translate(".concat(containerWidth / 2, " 256)")
                };
                const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
                const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
                const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
                const inner = {
                    transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
                };
                const path = {
                    transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
                };
                return {
                    outer,
                    inner,
                    path
                };
            }
            function transformForCss(_ref2) {
                let { transform, width = UNITS_IN_GRID, height = UNITS_IN_GRID, startCentered = false } = _ref2;
                let val = "";
                if (startCentered && IS_IE) {
                    val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
                } else if (startCentered) {
                    val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
                } else {
                    val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
                }
                val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
                val += "rotate(".concat(transform.rotate, "deg) ");
                return val;
            }
            var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}';
            function css() {
                const dcp = DEFAULT_CSS_PREFIX;
                const drc = DEFAULT_REPLACEMENT_CLASS;
                const fp = config.cssPrefix;
                const rc = config.replacementClass;
                let s2 = baseStyles;
                if (fp !== dcp || rc !== drc) {
                    const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
                    const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
                    const rPatt = new RegExp("\\.".concat(drc), "g");
                    s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
                }
                return s2;
            }
            let _cssInserted = false;
            function ensureCss() {
                if (config.autoAddCss && !_cssInserted) {
                    insertCss(css());
                    _cssInserted = true;
                }
            }
            var InjectCSS = {
                mixout () {
                    return {
                        dom: {
                            css,
                            insertCss: ensureCss
                        }
                    };
                },
                hooks () {
                    return {
                        beforeDOMElementCreation () {
                            ensureCss();
                        },
                        beforeI2svg () {
                            ensureCss();
                        }
                    };
                }
            };
            const w = WINDOW || {};
            if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
            if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
            if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
            if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
            var namespace = w[NAMESPACE_IDENTIFIER];
            const functions = [];
            const listener = function() {
                DOCUMENT.removeEventListener("DOMContentLoaded", listener);
                loaded = 1;
                functions.map((fn)=>fn());
            };
            let loaded = false;
            if (IS_DOM) {
                loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
                if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener);
            }
            function domready(fn) {
                if (!IS_DOM) return;
                loaded ? setTimeout(fn, 0) : functions.push(fn);
            }
            function toHtml(abstractNodes) {
                const { tag, attributes = {}, children = [] } = abstractNodes;
                if (typeof abstractNodes === "string") {
                    return htmlEscape(abstractNodes);
                } else {
                    return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
                }
            }
            function iconFromMapping(mapping, prefix, iconName) {
                if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
                    return {
                        prefix,
                        iconName,
                        icon: mapping[prefix][iconName]
                    };
                }
            }
            var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
                var keys = Object.keys(subject), length = keys.length, iterator2 = fn, i, key, result;
                if (initialValue === void 0) {
                    i = 1;
                    result = subject[keys[0]];
                } else {
                    i = 0;
                    result = initialValue;
                }
                for(; i < length; i++){
                    key = keys[i];
                    result = iterator2(result, subject[key], key, subject);
                }
                return result;
            };
            function ucs2decode(string) {
                const output = [];
                let counter2 = 0;
                const length = string.length;
                while(counter2 < length){
                    const value = string.charCodeAt(counter2++);
                    if (value >= 55296 && value <= 56319 && counter2 < length) {
                        const extra = string.charCodeAt(counter2++);
                        if ((extra & 64512) == 56320) {
                            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                        } else {
                            output.push(value);
                            counter2--;
                        }
                    } else {
                        output.push(value);
                    }
                }
                return output;
            }
            function toHex(unicode) {
                const decoded = ucs2decode(unicode);
                return decoded.length === 1 ? decoded[0].toString(16) : null;
            }
            function codePointAt(string, index) {
                const size = string.length;
                let first = string.charCodeAt(index);
                let second;
                if (first >= 55296 && first <= 56319 && size > index + 1) {
                    second = string.charCodeAt(index + 1);
                    if (second >= 56320 && second <= 57343) {
                        return (first - 55296) * 1024 + second - 56320 + 65536;
                    }
                }
                return first;
            }
            function normalizeIcons(icons) {
                return Object.keys(icons).reduce((acc, iconName)=>{
                    const icon2 = icons[iconName];
                    const expanded = !!icon2.icon;
                    if (expanded) {
                        acc[icon2.iconName] = icon2.icon;
                    } else {
                        acc[iconName] = icon2;
                    }
                    return acc;
                }, {});
            }
            function defineIcons(prefix, icons) {
                let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                const { skipHooks = false } = params;
                const normalized = normalizeIcons(icons);
                if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
                    namespace.hooks.addPack(prefix, normalizeIcons(icons));
                } else {
                    namespace.styles[prefix] = _objectSpread2$1(_objectSpread2$1({}, namespace.styles[prefix] || {}), normalized);
                }
                if (prefix === "fas") {
                    defineIcons("fa", icons);
                }
            }
            const { styles, shims } = namespace;
            const FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
            const PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId)=>{
                acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
                return acc;
            }, {});
            let _defaultUsablePrefix = null;
            let _byUnicode = {};
            let _byLigature = {};
            let _byOldName = {};
            let _byOldUnicode = {};
            let _byAlias = {};
            function isReserved(name) {
                return ~RESERVED_CLASSES.indexOf(name);
            }
            function getIconName(cssPrefix, cls) {
                const parts = cls.split("-");
                const prefix = parts[0];
                const iconName = parts.slice(1).join("-");
                if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
                    return iconName;
                } else {
                    return null;
                }
            }
            const build = ()=>{
                const lookup = (reducer)=>{
                    return reduce(styles, (o$$1, style, prefix)=>{
                        o$$1[prefix] = reduce(style, reducer, {});
                        return o$$1;
                    }, {});
                };
                _byUnicode = lookup((acc, icon2, iconName)=>{
                    if (icon2[3]) {
                        acc[icon2[3]] = iconName;
                    }
                    if (icon2[2]) {
                        const aliases = icon2[2].filter((a$$1)=>{
                            return typeof a$$1 === "number";
                        });
                        aliases.forEach((alias)=>{
                            acc[alias.toString(16)] = iconName;
                        });
                    }
                    return acc;
                });
                _byLigature = lookup((acc, icon2, iconName)=>{
                    acc[iconName] = iconName;
                    if (icon2[2]) {
                        const aliases = icon2[2].filter((a$$1)=>{
                            return typeof a$$1 === "string";
                        });
                        aliases.forEach((alias)=>{
                            acc[alias] = iconName;
                        });
                    }
                    return acc;
                });
                _byAlias = lookup((acc, icon2, iconName)=>{
                    const aliases = icon2[2];
                    acc[iconName] = iconName;
                    aliases.forEach((alias)=>{
                        acc[alias] = iconName;
                    });
                    return acc;
                });
                const hasRegular = "far" in styles || config.autoFetchSvg;
                const shimLookups = reduce(shims, (acc, shim)=>{
                    const maybeNameMaybeUnicode = shim[0];
                    let prefix = shim[1];
                    const iconName = shim[2];
                    if (prefix === "far" && !hasRegular) {
                        prefix = "fas";
                    }
                    if (typeof maybeNameMaybeUnicode === "string") {
                        acc.names[maybeNameMaybeUnicode] = {
                            prefix,
                            iconName
                        };
                    }
                    if (typeof maybeNameMaybeUnicode === "number") {
                        acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
                            prefix,
                            iconName
                        };
                    }
                    return acc;
                }, {
                    names: {},
                    unicodes: {}
                });
                _byOldName = shimLookups.names;
                _byOldUnicode = shimLookups.unicodes;
                _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
                    family: config.familyDefault
                });
            };
            onChange((c$$1)=>{
                _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
                    family: config.familyDefault
                });
            });
            build();
            function byUnicode(prefix, unicode) {
                return (_byUnicode[prefix] || {})[unicode];
            }
            function byLigature(prefix, ligature) {
                return (_byLigature[prefix] || {})[ligature];
            }
            function byAlias(prefix, alias) {
                return (_byAlias[prefix] || {})[alias];
            }
            function byOldName(name) {
                return _byOldName[name] || {
                    prefix: null,
                    iconName: null
                };
            }
            function byOldUnicode(unicode) {
                const oldUnicode = _byOldUnicode[unicode];
                const newUnicode = byUnicode("fas", unicode);
                return oldUnicode || (newUnicode ? {
                    prefix: "fas",
                    iconName: newUnicode
                } : null) || {
                    prefix: null,
                    iconName: null
                };
            }
            function getDefaultUsablePrefix() {
                return _defaultUsablePrefix;
            }
            const emptyCanonicalIcon = ()=>{
                return {
                    prefix: null,
                    iconName: null,
                    rest: []
                };
            };
            function getFamilyId(values) {
                let family = s;
                const famProps = FAMILY_NAMES.reduce((acc, familyId)=>{
                    acc[familyId] = "".concat(config.cssPrefix, "-").concat(familyId);
                    return acc;
                }, {});
                L.forEach((familyId)=>{
                    if (values.includes(famProps[familyId]) || values.some((v$$1)=>PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
                        family = familyId;
                    }
                });
                return family;
            }
            function getCanonicalPrefix(styleOrPrefix) {
                let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const { family = s } = params;
                const style = PREFIX_TO_STYLE[family][styleOrPrefix];
                if (family === t && !styleOrPrefix) {
                    return "fad";
                }
                const prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
                const defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
                const result = prefix || defined || null;
                return result;
            }
            function moveNonFaClassesToRest(classNames) {
                let rest = [];
                let iconName = null;
                classNames.forEach((cls)=>{
                    const result = getIconName(config.cssPrefix, cls);
                    if (result) {
                        iconName = result;
                    } else if (cls) {
                        rest.push(cls);
                    }
                });
                return {
                    iconName,
                    rest
                };
            }
            function sortedUniqueValues(arr) {
                return arr.sort().filter((value, index, arr2)=>{
                    return arr2.indexOf(value) === index;
                });
            }
            function getCanonicalIcon(values) {
                let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const { skipLookups = false } = params;
                let givenPrefix = null;
                const faCombinedClasses = Ia.concat(bt$1);
                const faStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls)=>faCombinedClasses.includes(cls)));
                const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls)=>!Ia.includes(cls)));
                const faStyles = faStyleOrFamilyClasses.filter((cls)=>{
                    givenPrefix = cls;
                    return !P.includes(cls);
                });
                const [styleFromValues = null] = faStyles;
                const family = getFamilyId(faStyleOrFamilyClasses);
                const canonical = _objectSpread2$1(_objectSpread2$1({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
                    prefix: getCanonicalPrefix(styleFromValues, {
                        family
                    })
                });
                return _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, canonical), getDefaultCanonicalPrefix({
                    values,
                    family,
                    styles,
                    config,
                    canonical,
                    givenPrefix
                })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
            }
            function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
                let { prefix, iconName } = canonical;
                if (skipLookups || !prefix || !iconName) {
                    return {
                        prefix,
                        iconName
                    };
                }
                const shim = givenPrefix === "fa" ? byOldName(iconName) : {};
                const aliasIconName = byAlias(prefix, iconName);
                iconName = shim.iconName || aliasIconName || iconName;
                prefix = shim.prefix || prefix;
                if (prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
                    prefix = "fas";
                }
                return {
                    prefix,
                    iconName
                };
            }
            const newCanonicalFamilies = L.filter((familyId)=>{
                return familyId !== s || familyId !== t;
            });
            const newCanonicalStyles = Object.keys(ga).filter((key)=>key !== s).map((key)=>Object.keys(ga[key])).flat();
            function getDefaultCanonicalPrefix(prefixOptions) {
                const { values, family, canonical, givenPrefix = "", styles: styles2 = {}, config: config$$1 = {} } = prefixOptions;
                const isDuotoneFamily = family === t;
                const valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
                const defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
                const canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
                if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
                    canonical.prefix = "fad";
                }
                if (values.includes("fa-brands") || values.includes("fab")) {
                    canonical.prefix = "fab";
                }
                if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
                    const validPrefix = Object.keys(styles2).find((key)=>newCanonicalStyles.includes(key));
                    if (validPrefix || config$$1.autoFetchSvg) {
                        const defaultPrefix = pt.get(family).defaultShortPrefixId;
                        canonical.prefix = defaultPrefix;
                        canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
                    }
                }
                if (canonical.prefix === "fa" || givenPrefix === "fa") {
                    canonical.prefix = getDefaultUsablePrefix() || "fas";
                }
                return canonical;
            }
            class Library {
                constructor(){
                    this.definitions = {};
                }
                add() {
                    for(var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++){
                        definitions[_key] = arguments[_key];
                    }
                    const additions = definitions.reduce(this._pullDefinitions, {});
                    Object.keys(additions).forEach((key)=>{
                        this.definitions[key] = _objectSpread2$1(_objectSpread2$1({}, this.definitions[key] || {}), additions[key]);
                        defineIcons(key, additions[key]);
                        const longPrefix = PREFIX_TO_LONG_STYLE[s][key];
                        if (longPrefix) defineIcons(longPrefix, additions[key]);
                        build();
                    });
                }
                reset() {
                    this.definitions = {};
                }
                _pullDefinitions(additions, definition) {
                    const normalized = definition.prefix && definition.iconName && definition.icon ? {
                        0: definition
                    } : definition;
                    Object.keys(normalized).map((key)=>{
                        const { prefix, iconName, icon: icon2 } = normalized[key];
                        const aliases = icon2[2];
                        if (!additions[prefix]) additions[prefix] = {};
                        if (aliases.length > 0) {
                            aliases.forEach((alias)=>{
                                if (typeof alias === "string") {
                                    additions[prefix][alias] = icon2;
                                }
                            });
                        }
                        additions[prefix][iconName] = icon2;
                    });
                    return additions;
                }
            }
            let _plugins = [];
            let _hooks = {};
            const providers = {};
            const defaultProviderKeys = Object.keys(providers);
            function registerPlugins(nextPlugins, _ref) {
                let { mixoutsTo: obj } = _ref;
                _plugins = nextPlugins;
                _hooks = {};
                Object.keys(providers).forEach((k)=>{
                    if (defaultProviderKeys.indexOf(k) === -1) {
                        delete providers[k];
                    }
                });
                _plugins.forEach((plugin)=>{
                    const mixout = plugin.mixout ? plugin.mixout() : {};
                    Object.keys(mixout).forEach((tk)=>{
                        if (typeof mixout[tk] === "function") {
                            obj[tk] = mixout[tk];
                        }
                        if (typeof mixout[tk] === "object") {
                            Object.keys(mixout[tk]).forEach((sk)=>{
                                if (!obj[tk]) {
                                    obj[tk] = {};
                                }
                                obj[tk][sk] = mixout[tk][sk];
                            });
                        }
                    });
                    if (plugin.hooks) {
                        const hooks = plugin.hooks();
                        Object.keys(hooks).forEach((hook)=>{
                            if (!_hooks[hook]) {
                                _hooks[hook] = [];
                            }
                            _hooks[hook].push(hooks[hook]);
                        });
                    }
                    if (plugin.provides) {
                        plugin.provides(providers);
                    }
                });
                return obj;
            }
            function chainHooks(hook, accumulator) {
                for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
                    args[_key - 2] = arguments[_key];
                }
                const hookFns = _hooks[hook] || [];
                hookFns.forEach((hookFn)=>{
                    accumulator = hookFn.apply(null, [
                        accumulator,
                        ...args
                    ]);
                });
                return accumulator;
            }
            function callHooks(hook) {
                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                    args[_key2 - 1] = arguments[_key2];
                }
                const hookFns = _hooks[hook] || [];
                hookFns.forEach((hookFn)=>{
                    hookFn.apply(null, args);
                });
                return void 0;
            }
            function callProvided() {
                const hook = arguments[0];
                const args = Array.prototype.slice.call(arguments, 1);
                return providers[hook] ? providers[hook].apply(null, args) : void 0;
            }
            function findIconDefinition(iconLookup) {
                if (iconLookup.prefix === "fa") {
                    iconLookup.prefix = "fas";
                }
                let { iconName } = iconLookup;
                const prefix = iconLookup.prefix || getDefaultUsablePrefix();
                if (!iconName) return;
                iconName = byAlias(prefix, iconName) || iconName;
                return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
            }
            const library = new Library();
            const noAuto = ()=>{
                config.autoReplaceSvg = false;
                config.observeMutations = false;
                callHooks("noAuto");
            };
            const dom = {
                i2svg: function() {
                    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    if (IS_DOM) {
                        callHooks("beforeI2svg", params);
                        callProvided("pseudoElements2svg", params);
                        return callProvided("i2svg", params);
                    } else {
                        return Promise.reject(new Error("Operation requires a DOM of some kind."));
                    }
                },
                watch: function() {
                    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                    const { autoReplaceSvgRoot } = params;
                    if (config.autoReplaceSvg === false) {
                        config.autoReplaceSvg = true;
                    }
                    config.observeMutations = true;
                    domready(()=>{
                        autoReplace({
                            autoReplaceSvgRoot
                        });
                        callHooks("watch", params);
                    });
                }
            };
            const parse = {
                icon: (icon2)=>{
                    if (icon2 === null) {
                        return null;
                    }
                    if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
                        return {
                            prefix: icon2.prefix,
                            iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
                        };
                    }
                    if (Array.isArray(icon2) && icon2.length === 2) {
                        const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
                        const prefix = getCanonicalPrefix(icon2[0]);
                        return {
                            prefix,
                            iconName: byAlias(prefix, iconName) || iconName
                        };
                    }
                    if (typeof icon2 === "string" && (icon2.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
                        const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
                            skipLookups: true
                        });
                        return {
                            prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
                            iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
                        };
                    }
                    if (typeof icon2 === "string") {
                        const prefix = getDefaultUsablePrefix();
                        return {
                            prefix,
                            iconName: byAlias(prefix, icon2) || icon2
                        };
                    }
                }
            };
            const api = {
                noAuto,
                config,
                dom,
                parse,
                library,
                findIconDefinition,
                toHtml
            };
            const autoReplace = function() {
                let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                const { autoReplaceSvgRoot = DOCUMENT } = params;
                if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
                    node: autoReplaceSvgRoot
                });
            };
            function domVariants(val, abstractCreator) {
                Object.defineProperty(val, "abstract", {
                    get: abstractCreator
                });
                Object.defineProperty(val, "html", {
                    get: function() {
                        return val.abstract.map((a)=>toHtml(a));
                    }
                });
                Object.defineProperty(val, "node", {
                    get: function() {
                        if (!IS_DOM) return;
                        const container = DOCUMENT.createElement("div");
                        container.innerHTML = val.html;
                        return container.children;
                    }
                });
                return val;
            }
            function asIcon(_ref) {
                let { children, main: main2, mask, attributes, styles: styles2, transform } = _ref;
                if (transformIsMeaningful(transform) && main2.found && !mask.found) {
                    const { width, height } = main2;
                    const offset2 = {
                        x: width / height / 2,
                        y: 0.5
                    };
                    attributes["style"] = joinStyles(_objectSpread2$1(_objectSpread2$1({}, styles2), {}, {
                        "transform-origin": "".concat(offset2.x + transform.x / 16, "em ").concat(offset2.y + transform.y / 16, "em")
                    }));
                }
                return [
                    {
                        tag: "svg",
                        attributes,
                        children
                    }
                ];
            }
            function asSymbol(_ref) {
                let { prefix, iconName, children, attributes, symbol } = _ref;
                const id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
                return [
                    {
                        tag: "svg",
                        attributes: {
                            style: "display: none;"
                        },
                        children: [
                            {
                                tag: "symbol",
                                attributes: _objectSpread2$1(_objectSpread2$1({}, attributes), {}, {
                                    id
                                }),
                                children
                            }
                        ]
                    }
                ];
            }
            function makeInlineSvgAbstract(params) {
                const { icons: { main: main2, mask }, prefix, iconName, transform, symbol, title, maskId, titleId, extra, watchable = false } = params;
                const { width, height } = mask.found ? mask : main2;
                const isUploadedIcon = Lt.includes(prefix);
                const attrClass = [
                    config.replacementClass,
                    iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""
                ].filter((c$$1)=>extra.classes.indexOf(c$$1) === -1).filter((c$$1)=>c$$1 !== "" || !!c$$1).concat(extra.classes).join(" ");
                let content = {
                    children: [],
                    attributes: _objectSpread2$1(_objectSpread2$1({}, extra.attributes), {}, {
                        "data-prefix": prefix,
                        "data-icon": iconName,
                        "class": attrClass,
                        "role": extra.attributes.role || "img",
                        "xmlns": "http://www.w3.org/2000/svg",
                        "viewBox": "0 0 ".concat(width, " ").concat(height)
                    })
                };
                const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
                    width: "".concat(width / height * 16 * 0.0625, "em")
                } : {};
                if (watchable) {
                    content.attributes[DATA_FA_I2SVG] = "";
                }
                if (title) {
                    content.children.push({
                        tag: "title",
                        attributes: {
                            id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
                        },
                        children: [
                            title
                        ]
                    });
                    delete content.attributes.title;
                }
                const args = _objectSpread2$1(_objectSpread2$1({}, content), {}, {
                    prefix,
                    iconName,
                    main: main2,
                    mask,
                    maskId,
                    transform,
                    symbol,
                    styles: _objectSpread2$1(_objectSpread2$1({}, uploadedIconWidthStyle), extra.styles)
                });
                const { children, attributes } = mask.found && main2.found ? callProvided("generateAbstractMask", args) || {
                    children: [],
                    attributes: {}
                } : callProvided("generateAbstractIcon", args) || {
                    children: [],
                    attributes: {}
                };
                args.children = children;
                args.attributes = attributes;
                if (symbol) {
                    return asSymbol(args);
                } else {
                    return asIcon(args);
                }
            }
            function makeLayersTextAbstract(params) {
                const { content, width, height, transform, title, extra, watchable = false } = params;
                const attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
                    "title": title
                } : {}), {}, {
                    "class": extra.classes.join(" ")
                });
                if (watchable) {
                    attributes[DATA_FA_I2SVG] = "";
                }
                const styles2 = _objectSpread2$1({}, extra.styles);
                if (transformIsMeaningful(transform)) {
                    styles2["transform"] = transformForCss({
                        transform,
                        startCentered: true,
                        width,
                        height
                    });
                    styles2["-webkit-transform"] = styles2["transform"];
                }
                const styleString = joinStyles(styles2);
                if (styleString.length > 0) {
                    attributes["style"] = styleString;
                }
                const val = [];
                val.push({
                    tag: "span",
                    attributes,
                    children: [
                        content
                    ]
                });
                if (title) {
                    val.push({
                        tag: "span",
                        attributes: {
                            class: "sr-only"
                        },
                        children: [
                            title
                        ]
                    });
                }
                return val;
            }
            function makeLayersCounterAbstract(params) {
                const { content, title, extra } = params;
                const attributes = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, extra.attributes), title ? {
                    "title": title
                } : {}), {}, {
                    "class": extra.classes.join(" ")
                });
                const styleString = joinStyles(extra.styles);
                if (styleString.length > 0) {
                    attributes["style"] = styleString;
                }
                const val = [];
                val.push({
                    tag: "span",
                    attributes,
                    children: [
                        content
                    ]
                });
                if (title) {
                    val.push({
                        tag: "span",
                        attributes: {
                            class: "sr-only"
                        },
                        children: [
                            title
                        ]
                    });
                }
                return val;
            }
            const { styles: styles$1 } = namespace;
            function asFoundIcon(icon2) {
                const width = icon2[0];
                const height = icon2[1];
                const [vectorData] = icon2.slice(4);
                let element = null;
                if (Array.isArray(vectorData)) {
                    element = {
                        tag: "g",
                        attributes: {
                            class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
                        },
                        children: [
                            {
                                tag: "path",
                                attributes: {
                                    class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
                                    fill: "currentColor",
                                    d: vectorData[0]
                                }
                            },
                            {
                                tag: "path",
                                attributes: {
                                    class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
                                    fill: "currentColor",
                                    d: vectorData[1]
                                }
                            }
                        ]
                    };
                } else {
                    element = {
                        tag: "path",
                        attributes: {
                            fill: "currentColor",
                            d: vectorData
                        }
                    };
                }
                return {
                    found: true,
                    width,
                    height,
                    icon: element
                };
            }
            const missingIconResolutionMixin = {
                found: false,
                width: 512,
                height: 512
            };
            function maybeNotifyMissing(iconName, prefix) {
                if (!PRODUCTION$1 && !config.showMissingIcons && iconName) {
                    console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
                }
            }
            function findIcon(iconName, prefix) {
                let givenPrefix = prefix;
                if (prefix === "fa" && config.styleDefault !== null) {
                    prefix = getDefaultUsablePrefix();
                }
                return new Promise((resolve2, reject)=>{
                    if (givenPrefix === "fa") {
                        const shim = byOldName(iconName) || {};
                        iconName = shim.iconName || iconName;
                        prefix = shim.prefix || prefix;
                    }
                    if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
                        const icon2 = styles$1[prefix][iconName];
                        return resolve2(asFoundIcon(icon2));
                    }
                    maybeNotifyMissing(iconName, prefix);
                    resolve2(_objectSpread2$1(_objectSpread2$1({}, missingIconResolutionMixin), {}, {
                        icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
                    }));
                });
            }
            const noop$1$1 = ()=>{};
            const p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
                mark: noop$1$1,
                measure: noop$1$1
            };
            const preamble = 'FA "6.7.2"';
            const begin = (name)=>{
                p$2.mark("".concat(preamble, " ").concat(name, " begins"));
                return ()=>end$1(name);
            };
            const end$1 = (name)=>{
                p$2.mark("".concat(preamble, " ").concat(name, " ends"));
                p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
            };
            var perf = {
                begin,
                end: end$1
            };
            const noop$2 = ()=>{};
            function isWatched(node) {
                const i2svg = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
                return typeof i2svg === "string";
            }
            function hasPrefixAndIcon(node) {
                const prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
                const icon2 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
                return prefix && icon2;
            }
            function hasBeenReplaced(node) {
                return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
            }
            function getMutator() {
                if (config.autoReplaceSvg === true) {
                    return mutators.replace;
                }
                const mutator = mutators[config.autoReplaceSvg];
                return mutator || mutators.replace;
            }
            function createElementNS(tag) {
                return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
            }
            function createElement(tag) {
                return DOCUMENT.createElement(tag);
            }
            function convertSVG(abstractObj) {
                let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const { ceFn = abstractObj.tag === "svg" ? createElementNS : createElement } = params;
                if (typeof abstractObj === "string") {
                    return DOCUMENT.createTextNode(abstractObj);
                }
                const tag = ceFn(abstractObj.tag);
                Object.keys(abstractObj.attributes || []).forEach(function(key) {
                    tag.setAttribute(key, abstractObj.attributes[key]);
                });
                const children = abstractObj.children || [];
                children.forEach(function(child) {
                    tag.appendChild(convertSVG(child, {
                        ceFn
                    }));
                });
                return tag;
            }
            function nodeAsComment(node) {
                let comment = " ".concat(node.outerHTML, " ");
                comment = "".concat(comment, "Font Awesome fontawesome.com ");
                return comment;
            }
            const mutators = {
                replace: function(mutation) {
                    const node = mutation[0];
                    if (node.parentNode) {
                        mutation[1].forEach((abstract)=>{
                            node.parentNode.insertBefore(convertSVG(abstract), node);
                        });
                        if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
                            let comment = DOCUMENT.createComment(nodeAsComment(node));
                            node.parentNode.replaceChild(comment, node);
                        } else {
                            node.remove();
                        }
                    }
                },
                nest: function(mutation) {
                    const node = mutation[0];
                    const abstract = mutation[1];
                    if (~classArray(node).indexOf(config.replacementClass)) {
                        return mutators.replace(mutation);
                    }
                    const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
                    delete abstract[0].attributes.id;
                    if (abstract[0].attributes.class) {
                        const splitClasses = abstract[0].attributes.class.split(" ").reduce((acc, cls)=>{
                            if (cls === config.replacementClass || cls.match(forSvg)) {
                                acc.toSvg.push(cls);
                            } else {
                                acc.toNode.push(cls);
                            }
                            return acc;
                        }, {
                            toNode: [],
                            toSvg: []
                        });
                        abstract[0].attributes.class = splitClasses.toSvg.join(" ");
                        if (splitClasses.toNode.length === 0) {
                            node.removeAttribute("class");
                        } else {
                            node.setAttribute("class", splitClasses.toNode.join(" "));
                        }
                    }
                    const newInnerHTML = abstract.map((a)=>toHtml(a)).join("\n");
                    node.setAttribute(DATA_FA_I2SVG, "");
                    node.innerHTML = newInnerHTML;
                }
            };
            function performOperationSync(op) {
                op();
            }
            function perform(mutations, callback) {
                const callbackFunction = typeof callback === "function" ? callback : noop$2;
                if (mutations.length === 0) {
                    callbackFunction();
                } else {
                    let frame = performOperationSync;
                    if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
                        frame = WINDOW.requestAnimationFrame || performOperationSync;
                    }
                    frame(()=>{
                        const mutator = getMutator();
                        const mark = perf.begin("mutate");
                        mutations.map(mutator);
                        mark();
                        callbackFunction();
                    });
                }
            }
            let disabled = false;
            function disableObservation() {
                disabled = true;
            }
            function enableObservation() {
                disabled = false;
            }
            let mo = null;
            function observe(options) {
                if (!MUTATION_OBSERVER) {
                    return;
                }
                if (!config.observeMutations) {
                    return;
                }
                const { treeCallback = noop$2, nodeCallback = noop$2, pseudoElementsCallback = noop$2, observeMutationsRoot = DOCUMENT } = options;
                mo = new MUTATION_OBSERVER((objects)=>{
                    if (disabled) return;
                    const defaultPrefix = getDefaultUsablePrefix();
                    toArray$1(objects).forEach((mutationRecord)=>{
                        if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
                            if (config.searchPseudoElements) {
                                pseudoElementsCallback(mutationRecord.target);
                            }
                            treeCallback(mutationRecord.target);
                        }
                        if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
                            pseudoElementsCallback(mutationRecord.target.parentNode);
                        }
                        if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
                            if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
                                const { prefix, iconName } = getCanonicalIcon(classArray(mutationRecord.target));
                                mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
                                if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
                            } else if (hasBeenReplaced(mutationRecord.target)) {
                                nodeCallback(mutationRecord.target);
                            }
                        }
                    });
                });
                if (!IS_DOM) return;
                mo.observe(observeMutationsRoot, {
                    childList: true,
                    attributes: true,
                    characterData: true,
                    subtree: true
                });
            }
            function disconnect() {
                if (!mo) return;
                mo.disconnect();
            }
            function styleParser(node) {
                const style = node.getAttribute("style");
                let val = [];
                if (style) {
                    val = style.split(";").reduce((acc, style2)=>{
                        const styles2 = style2.split(":");
                        const prop = styles2[0];
                        const value = styles2.slice(1);
                        if (prop && value.length > 0) {
                            acc[prop] = value.join(":").trim();
                        }
                        return acc;
                    }, {});
                }
                return val;
            }
            function classParser(node) {
                const existingPrefix = node.getAttribute("data-prefix");
                const existingIconName = node.getAttribute("data-icon");
                const innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
                let val = getCanonicalIcon(classArray(node));
                if (!val.prefix) {
                    val.prefix = getDefaultUsablePrefix();
                }
                if (existingPrefix && existingIconName) {
                    val.prefix = existingPrefix;
                    val.iconName = existingIconName;
                }
                if (val.iconName && val.prefix) {
                    return val;
                }
                if (val.prefix && innerText.length > 0) {
                    val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
                }
                if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
                    val.iconName = node.firstChild.data;
                }
                return val;
            }
            function attributesParser(node) {
                const extraAttributes = toArray$1(node.attributes).reduce((acc, attr)=>{
                    if (acc.name !== "class" && acc.name !== "style") {
                        acc[attr.name] = attr.value;
                    }
                    return acc;
                }, {});
                const title = node.getAttribute("title");
                const titleId = node.getAttribute("data-fa-title-id");
                if (config.autoA11y) {
                    if (title) {
                        extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
                    } else {
                        extraAttributes["aria-hidden"] = "true";
                        extraAttributes["focusable"] = "false";
                    }
                }
                return extraAttributes;
            }
            function blankMeta() {
                return {
                    iconName: null,
                    title: null,
                    titleId: null,
                    prefix: null,
                    transform: meaninglessTransform,
                    symbol: false,
                    mask: {
                        iconName: null,
                        prefix: null,
                        rest: []
                    },
                    maskId: null,
                    extra: {
                        classes: [],
                        styles: {},
                        attributes: {}
                    }
                };
            }
            function parseMeta(node) {
                let parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                    styleParser: true
                };
                const { iconName, prefix, rest: extraClasses } = classParser(node);
                const extraAttributes = attributesParser(node);
                const pluginMeta = chainHooks("parseNodeAttributes", {}, node);
                let extraStyles = parser.styleParser ? styleParser(node) : [];
                return _objectSpread2$1({
                    iconName,
                    title: node.getAttribute("title"),
                    titleId: node.getAttribute("data-fa-title-id"),
                    prefix,
                    transform: meaninglessTransform,
                    mask: {
                        iconName: null,
                        prefix: null,
                        rest: []
                    },
                    maskId: null,
                    symbol: false,
                    extra: {
                        classes: extraClasses,
                        styles: extraStyles,
                        attributes: extraAttributes
                    }
                }, pluginMeta);
            }
            const { styles: styles$2 } = namespace;
            function generateMutation(node) {
                const nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node, {
                    styleParser: false
                }) : parseMeta(node);
                if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
                    return callProvided("generateLayersText", node, nodeMeta);
                } else {
                    return callProvided("generateSvgReplacementMutation", node, nodeMeta);
                }
            }
            function getKnownPrefixes() {
                return [
                    ...Ft,
                    ...Ia
                ];
            }
            function onTree(root) {
                let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                if (!IS_DOM) return Promise.resolve();
                const htmlClassList = DOCUMENT.documentElement.classList;
                const hclAdd = (suffix)=>htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
                const hclRemove = (suffix)=>htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
                const prefixes2 = config.autoFetchSvg ? getKnownPrefixes() : P.concat(Object.keys(styles$2));
                if (!prefixes2.includes("fa")) {
                    prefixes2.push("fa");
                }
                const prefixesDomQuery = [
                    ".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")
                ].concat(prefixes2.map((p$$1)=>".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
                if (prefixesDomQuery.length === 0) {
                    return Promise.resolve();
                }
                let candidates = [];
                try {
                    candidates = toArray$1(root.querySelectorAll(prefixesDomQuery));
                } catch (e$$1) {}
                if (candidates.length > 0) {
                    hclAdd("pending");
                    hclRemove("complete");
                } else {
                    return Promise.resolve();
                }
                const mark = perf.begin("onTree");
                const mutations = candidates.reduce((acc, node)=>{
                    try {
                        const mutation = generateMutation(node);
                        if (mutation) {
                            acc.push(mutation);
                        }
                    } catch (e$$1) {
                        if (!PRODUCTION$1) {
                            if (e$$1.name === "MissingIcon") {
                                console.error(e$$1);
                            }
                        }
                    }
                    return acc;
                }, []);
                return new Promise((resolve2, reject)=>{
                    Promise.all(mutations).then((resolvedMutations)=>{
                        perform(resolvedMutations, ()=>{
                            hclAdd("active");
                            hclAdd("complete");
                            hclRemove("pending");
                            if (typeof callback === "function") callback();
                            mark();
                            resolve2();
                        });
                    }).catch((e$$1)=>{
                        mark();
                        reject(e$$1);
                    });
                });
            }
            function onNode(node) {
                let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
                generateMutation(node).then((mutation)=>{
                    if (mutation) {
                        perform([
                            mutation
                        ], callback);
                    }
                });
            }
            function resolveIcons(next) {
                return function(maybeIconDefinition) {
                    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                    const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
                    let { mask } = params;
                    if (mask) {
                        mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
                    }
                    return next(iconDefinition, _objectSpread2$1(_objectSpread2$1({}, params), {}, {
                        mask
                    }));
                };
            }
            const render = function(iconDefinition) {
                let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                const { transform = meaninglessTransform, symbol = false, mask = null, maskId = null, title = null, titleId = null, classes = [], attributes = {}, styles: styles2 = {} } = params;
                if (!iconDefinition) return;
                const { prefix, iconName, icon: icon2 } = iconDefinition;
                return domVariants(_objectSpread2$1({
                    type: "icon"
                }, iconDefinition), ()=>{
                    callHooks("beforeDOMElementCreation", {
                        iconDefinition,
                        params
                    });
                    if (config.autoA11y) {
                        if (title) {
                            attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
                        } else {
                            attributes["aria-hidden"] = "true";
                            attributes["focusable"] = "false";
                        }
                    }
                    return makeInlineSvgAbstract({
                        icons: {
                            main: asFoundIcon(icon2),
                            mask: mask ? asFoundIcon(mask.icon) : {
                                found: false,
                                width: null,
                                height: null,
                                icon: {}
                            }
                        },
                        prefix,
                        iconName,
                        transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
                        symbol,
                        title,
                        maskId,
                        titleId,
                        extra: {
                            attributes,
                            styles: styles2,
                            classes
                        }
                    });
                });
            };
            var ReplaceElements = {
                mixout () {
                    return {
                        icon: resolveIcons(render)
                    };
                },
                hooks () {
                    return {
                        mutationObserverCallbacks (accumulator) {
                            accumulator.treeCallback = onTree;
                            accumulator.nodeCallback = onNode;
                            return accumulator;
                        }
                    };
                },
                provides (providers$$1) {
                    providers$$1.i2svg = function(params) {
                        const { node = DOCUMENT, callback = ()=>{} } = params;
                        return onTree(node, callback);
                    };
                    providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
                        const { iconName, title, titleId, prefix, transform, symbol, mask, maskId, extra } = nodeMeta;
                        return new Promise((resolve2, reject)=>{
                            Promise.all([
                                findIcon(iconName, prefix),
                                mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
                                    found: false,
                                    width: 512,
                                    height: 512,
                                    icon: {}
                                })
                            ]).then((_ref)=>{
                                let [main2, mask2] = _ref;
                                resolve2([
                                    node,
                                    makeInlineSvgAbstract({
                                        icons: {
                                            main: main2,
                                            mask: mask2
                                        },
                                        prefix,
                                        iconName,
                                        transform,
                                        symbol,
                                        maskId,
                                        title,
                                        titleId,
                                        extra,
                                        watchable: true
                                    })
                                ]);
                            }).catch(reject);
                        });
                    };
                    providers$$1.generateAbstractIcon = function(_ref2) {
                        let { children, attributes, main: main2, transform, styles: styles2 } = _ref2;
                        const styleString = joinStyles(styles2);
                        if (styleString.length > 0) {
                            attributes["style"] = styleString;
                        }
                        let nextChild;
                        if (transformIsMeaningful(transform)) {
                            nextChild = callProvided("generateAbstractTransformGrouping", {
                                main: main2,
                                transform,
                                containerWidth: main2.width,
                                iconWidth: main2.width
                            });
                        }
                        children.push(nextChild || main2.icon);
                        return {
                            children,
                            attributes
                        };
                    };
                }
            };
            var Layers = {
                mixout () {
                    return {
                        layer (assembler) {
                            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            const { classes = [] } = params;
                            return domVariants({
                                type: "layer"
                            }, ()=>{
                                callHooks("beforeDOMElementCreation", {
                                    assembler,
                                    params
                                });
                                let children = [];
                                assembler((args)=>{
                                    Array.isArray(args) ? args.map((a)=>{
                                        children = children.concat(a.abstract);
                                    }) : children = children.concat(args.abstract);
                                });
                                return [
                                    {
                                        tag: "span",
                                        attributes: {
                                            class: [
                                                "".concat(config.cssPrefix, "-layers"),
                                                ...classes
                                            ].join(" ")
                                        },
                                        children
                                    }
                                ];
                            });
                        }
                    };
                }
            };
            var LayersCounter = {
                mixout () {
                    return {
                        counter (content) {
                            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            const { title = null, classes = [], attributes = {}, styles: styles2 = {} } = params;
                            return domVariants({
                                type: "counter",
                                content
                            }, ()=>{
                                callHooks("beforeDOMElementCreation", {
                                    content,
                                    params
                                });
                                return makeLayersCounterAbstract({
                                    content: content.toString(),
                                    title,
                                    extra: {
                                        attributes,
                                        styles: styles2,
                                        classes: [
                                            "".concat(config.cssPrefix, "-layers-counter"),
                                            ...classes
                                        ]
                                    }
                                });
                            });
                        }
                    };
                }
            };
            var LayersText = {
                mixout () {
                    return {
                        text (content) {
                            let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                            const { transform = meaninglessTransform, title = null, classes = [], attributes = {}, styles: styles2 = {} } = params;
                            return domVariants({
                                type: "text",
                                content
                            }, ()=>{
                                callHooks("beforeDOMElementCreation", {
                                    content,
                                    params
                                });
                                return makeLayersTextAbstract({
                                    content,
                                    transform: _objectSpread2$1(_objectSpread2$1({}, meaninglessTransform), transform),
                                    title,
                                    extra: {
                                        attributes,
                                        styles: styles2,
                                        classes: [
                                            "".concat(config.cssPrefix, "-layers-text"),
                                            ...classes
                                        ]
                                    }
                                });
                            });
                        }
                    };
                },
                provides (providers$$1) {
                    providers$$1.generateLayersText = function(node, nodeMeta) {
                        const { title, transform, extra } = nodeMeta;
                        let width = null;
                        let height = null;
                        if (IS_IE) {
                            const computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
                            const boundingClientRect = node.getBoundingClientRect();
                            width = boundingClientRect.width / computedFontSize;
                            height = boundingClientRect.height / computedFontSize;
                        }
                        if (config.autoA11y && !title) {
                            extra.attributes["aria-hidden"] = "true";
                        }
                        return Promise.resolve([
                            node,
                            makeLayersTextAbstract({
                                content: node.innerHTML,
                                width,
                                height,
                                transform,
                                title,
                                extra,
                                watchable: true
                            })
                        ]);
                    };
                }
            };
            const CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
            const SECONDARY_UNICODE_RANGE = [
                1105920,
                1112319
            ];
            const _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, {
                FontAwesome: {
                    normal: "fas",
                    400: "fas"
                }
            }), lt), wa), Yt);
            const FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key)=>{
                acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
                return acc;
            }, {});
            const FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily)=>{
                const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
                acc[fontFamily] = weights[900] || [
                    ...Object.entries(weights)
                ][0][1];
                return acc;
            }, {});
            function hexValueFromContent(content) {
                const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
                const codePoint = codePointAt(cleaned, 0);
                const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
                const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
                return {
                    value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
                    isSecondary: isPrependTen || isDoubled
                };
            }
            function getPrefix(fontFamily, fontWeight) {
                const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
                const fontWeightInteger = parseInt(fontWeight);
                const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
                return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
            }
            function replaceForPosition(node, position) {
                const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
                return new Promise((resolve2, reject)=>{
                    if (node.getAttribute(pendingAttribute) !== null) {
                        return resolve2();
                    }
                    const children = toArray$1(node.children);
                    const alreadyProcessedPseudoElement = children.filter((c$$1)=>c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position)[0];
                    const styles2 = WINDOW.getComputedStyle(node, position);
                    const fontFamily = styles2.getPropertyValue("font-family");
                    const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
                    const fontWeight = styles2.getPropertyValue("font-weight");
                    const content = styles2.getPropertyValue("content");
                    if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
                        node.removeChild(alreadyProcessedPseudoElement);
                        return resolve2();
                    } else if (fontFamilyMatch && content !== "none" && content !== "") {
                        const content2 = styles2.getPropertyValue("content");
                        let prefix = getPrefix(fontFamily, fontWeight);
                        const { value: hexValue, isSecondary } = hexValueFromContent(content2);
                        const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
                        let iconName = byUnicode(prefix, hexValue);
                        let iconIdentifier = iconName;
                        if (isV4) {
                            const iconName4 = byOldUnicode(hexValue);
                            if (iconName4.iconName && iconName4.prefix) {
                                iconName = iconName4.iconName;
                                prefix = iconName4.prefix;
                            }
                        }
                        if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
                            node.setAttribute(pendingAttribute, iconIdentifier);
                            if (alreadyProcessedPseudoElement) {
                                node.removeChild(alreadyProcessedPseudoElement);
                            }
                            const meta = blankMeta();
                            const { extra } = meta;
                            extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
                            findIcon(iconName, prefix).then((main2)=>{
                                const abstract = makeInlineSvgAbstract(_objectSpread2$1(_objectSpread2$1({}, meta), {}, {
                                    icons: {
                                        main: main2,
                                        mask: emptyCanonicalIcon()
                                    },
                                    prefix,
                                    iconName: iconIdentifier,
                                    extra,
                                    watchable: true
                                }));
                                const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
                                if (position === "::before") {
                                    node.insertBefore(element, node.firstChild);
                                } else {
                                    node.appendChild(element);
                                }
                                element.outerHTML = abstract.map((a$$1)=>toHtml(a$$1)).join("\n");
                                node.removeAttribute(pendingAttribute);
                                resolve2();
                            }).catch(reject);
                        } else {
                            resolve2();
                        }
                    } else {
                        resolve2();
                    }
                });
            }
            function replace(node) {
                return Promise.all([
                    replaceForPosition(node, "::before"),
                    replaceForPosition(node, "::after")
                ]);
            }
            function processable(node) {
                return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
            }
            function searchPseudoElements(root) {
                if (!IS_DOM) return;
                return new Promise((resolve2, reject)=>{
                    const operations = toArray$1(root.querySelectorAll("*")).filter(processable).map(replace);
                    const end2 = perf.begin("searchPseudoElements");
                    disableObservation();
                    Promise.all(operations).then(()=>{
                        end2();
                        enableObservation();
                        resolve2();
                    }).catch(()=>{
                        end2();
                        enableObservation();
                        reject();
                    });
                });
            }
            var PseudoElements = {
                hooks () {
                    return {
                        mutationObserverCallbacks (accumulator) {
                            accumulator.pseudoElementsCallback = searchPseudoElements;
                            return accumulator;
                        }
                    };
                },
                provides (providers2) {
                    providers2.pseudoElements2svg = function(params) {
                        const { node = DOCUMENT } = params;
                        if (config.searchPseudoElements) {
                            searchPseudoElements(node);
                        }
                    };
                }
            };
            let _unwatched = false;
            var MutationObserver$1 = {
                mixout () {
                    return {
                        dom: {
                            unwatch () {
                                disableObservation();
                                _unwatched = true;
                            }
                        }
                    };
                },
                hooks () {
                    return {
                        bootstrap () {
                            observe(chainHooks("mutationObserverCallbacks", {}));
                        },
                        noAuto () {
                            disconnect();
                        },
                        watch (params) {
                            const { observeMutationsRoot } = params;
                            if (_unwatched) {
                                enableObservation();
                            } else {
                                observe(chainHooks("mutationObserverCallbacks", {
                                    observeMutationsRoot
                                }));
                            }
                        }
                    };
                }
            };
            const parseTransformString = (transformString)=>{
                let transform = {
                    size: 16,
                    x: 0,
                    y: 0,
                    flipX: false,
                    flipY: false,
                    rotate: 0
                };
                return transformString.toLowerCase().split(" ").reduce((acc, n)=>{
                    const parts = n.toLowerCase().split("-");
                    const first = parts[0];
                    let rest = parts.slice(1).join("-");
                    if (first && rest === "h") {
                        acc.flipX = true;
                        return acc;
                    }
                    if (first && rest === "v") {
                        acc.flipY = true;
                        return acc;
                    }
                    rest = parseFloat(rest);
                    if (isNaN(rest)) {
                        return acc;
                    }
                    switch(first){
                        case "grow":
                            acc.size = acc.size + rest;
                            break;
                        case "shrink":
                            acc.size = acc.size - rest;
                            break;
                        case "left":
                            acc.x = acc.x - rest;
                            break;
                        case "right":
                            acc.x = acc.x + rest;
                            break;
                        case "up":
                            acc.y = acc.y - rest;
                            break;
                        case "down":
                            acc.y = acc.y + rest;
                            break;
                        case "rotate":
                            acc.rotate = acc.rotate + rest;
                            break;
                    }
                    return acc;
                }, transform);
            };
            var PowerTransforms = {
                mixout () {
                    return {
                        parse: {
                            transform: (transformString)=>{
                                return parseTransformString(transformString);
                            }
                        }
                    };
                },
                hooks () {
                    return {
                        parseNodeAttributes (accumulator, node) {
                            const transformString = node.getAttribute("data-fa-transform");
                            if (transformString) {
                                accumulator.transform = parseTransformString(transformString);
                            }
                            return accumulator;
                        }
                    };
                },
                provides (providers2) {
                    providers2.generateAbstractTransformGrouping = function(_ref) {
                        let { main: main2, transform, containerWidth, iconWidth } = _ref;
                        const outer = {
                            transform: "translate(".concat(containerWidth / 2, " 256)")
                        };
                        const innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
                        const innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
                        const innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
                        const inner = {
                            transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
                        };
                        const path = {
                            transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
                        };
                        const operations = {
                            outer,
                            inner,
                            path
                        };
                        return {
                            tag: "g",
                            attributes: _objectSpread2$1({}, operations.outer),
                            children: [
                                {
                                    tag: "g",
                                    attributes: _objectSpread2$1({}, operations.inner),
                                    children: [
                                        {
                                            tag: main2.icon.tag,
                                            children: main2.icon.children,
                                            attributes: _objectSpread2$1(_objectSpread2$1({}, main2.icon.attributes), operations.path)
                                        }
                                    ]
                                }
                            ]
                        };
                    };
                }
            };
            const ALL_SPACE = {
                x: 0,
                y: 0,
                width: "100%",
                height: "100%"
            };
            function fillBlack(abstract) {
                let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                if (abstract.attributes && (abstract.attributes.fill || force)) {
                    abstract.attributes.fill = "black";
                }
                return abstract;
            }
            function deGroup(abstract) {
                if (abstract.tag === "g") {
                    return abstract.children;
                } else {
                    return [
                        abstract
                    ];
                }
            }
            var Masks = {
                hooks () {
                    return {
                        parseNodeAttributes (accumulator, node) {
                            const maskData = node.getAttribute("data-fa-mask");
                            const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i)=>i.trim()));
                            if (!mask.prefix) {
                                mask.prefix = getDefaultUsablePrefix();
                            }
                            accumulator.mask = mask;
                            accumulator.maskId = node.getAttribute("data-fa-mask-id");
                            return accumulator;
                        }
                    };
                },
                provides (providers2) {
                    providers2.generateAbstractMask = function(_ref) {
                        let { children, attributes, main: main2, mask, maskId: explicitMaskId, transform } = _ref;
                        const { width: mainWidth, icon: mainPath } = main2;
                        const { width: maskWidth, icon: maskPath } = mask;
                        const trans = transformForSvg({
                            transform,
                            containerWidth: maskWidth,
                            iconWidth: mainWidth
                        });
                        const maskRect = {
                            tag: "rect",
                            attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
                                fill: "white"
                            })
                        };
                        const maskInnerGroupChildrenMixin = mainPath.children ? {
                            children: mainPath.children.map(fillBlack)
                        } : {};
                        const maskInnerGroup = {
                            tag: "g",
                            attributes: _objectSpread2$1({}, trans.inner),
                            children: [
                                fillBlack(_objectSpread2$1({
                                    tag: mainPath.tag,
                                    attributes: _objectSpread2$1(_objectSpread2$1({}, mainPath.attributes), trans.path)
                                }, maskInnerGroupChildrenMixin))
                            ]
                        };
                        const maskOuterGroup = {
                            tag: "g",
                            attributes: _objectSpread2$1({}, trans.outer),
                            children: [
                                maskInnerGroup
                            ]
                        };
                        const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
                        const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
                        const maskTag = {
                            tag: "mask",
                            attributes: _objectSpread2$1(_objectSpread2$1({}, ALL_SPACE), {}, {
                                id: maskId,
                                maskUnits: "userSpaceOnUse",
                                maskContentUnits: "userSpaceOnUse"
                            }),
                            children: [
                                maskRect,
                                maskOuterGroup
                            ]
                        };
                        const defs = {
                            tag: "defs",
                            children: [
                                {
                                    tag: "clipPath",
                                    attributes: {
                                        id: clipId
                                    },
                                    children: deGroup(maskPath)
                                },
                                maskTag
                            ]
                        };
                        children.push(defs, {
                            tag: "rect",
                            attributes: _objectSpread2$1({
                                fill: "currentColor",
                                "clip-path": "url(#".concat(clipId, ")"),
                                mask: "url(#".concat(maskId, ")")
                            }, ALL_SPACE)
                        });
                        return {
                            children,
                            attributes
                        };
                    };
                }
            };
            var MissingIconIndicator = {
                provides (providers2) {
                    let reduceMotion = false;
                    if (WINDOW.matchMedia) {
                        reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
                    }
                    providers2.missingIconAbstract = function() {
                        const gChildren = [];
                        const FILL = {
                            fill: "currentColor"
                        };
                        const ANIMATION_BASE = {
                            attributeType: "XML",
                            repeatCount: "indefinite",
                            dur: "2s"
                        };
                        gChildren.push({
                            tag: "path",
                            attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
                                d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
                            })
                        });
                        const OPACITY_ANIMATE = _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
                            attributeName: "opacity"
                        });
                        const dot = {
                            tag: "circle",
                            attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
                                cx: "256",
                                cy: "364",
                                r: "28"
                            }),
                            children: []
                        };
                        if (!reduceMotion) {
                            dot.children.push({
                                tag: "animate",
                                attributes: _objectSpread2$1(_objectSpread2$1({}, ANIMATION_BASE), {}, {
                                    attributeName: "r",
                                    values: "28;14;28;28;14;28;"
                                })
                            }, {
                                tag: "animate",
                                attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
                                    values: "1;0;1;1;0;1;"
                                })
                            });
                        }
                        gChildren.push(dot);
                        gChildren.push({
                            tag: "path",
                            attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
                                opacity: "1",
                                d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
                            }),
                            children: reduceMotion ? [] : [
                                {
                                    tag: "animate",
                                    attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
                                        values: "1;0;0;0;0;1;"
                                    })
                                }
                            ]
                        });
                        if (!reduceMotion) {
                            gChildren.push({
                                tag: "path",
                                attributes: _objectSpread2$1(_objectSpread2$1({}, FILL), {}, {
                                    opacity: "0",
                                    d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
                                }),
                                children: [
                                    {
                                        tag: "animate",
                                        attributes: _objectSpread2$1(_objectSpread2$1({}, OPACITY_ANIMATE), {}, {
                                            values: "0;0;1;1;0;0;"
                                        })
                                    }
                                ]
                            });
                        }
                        return {
                            tag: "g",
                            attributes: {
                                "class": "missing"
                            },
                            children: gChildren
                        };
                    };
                }
            };
            var SvgSymbols = {
                hooks () {
                    return {
                        parseNodeAttributes (accumulator, node) {
                            const symbolData = node.getAttribute("data-fa-symbol");
                            const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
                            accumulator["symbol"] = symbol;
                            return accumulator;
                        }
                    };
                }
            };
            var plugins = [
                InjectCSS,
                ReplaceElements,
                Layers,
                LayersCounter,
                LayersText,
                PseudoElements,
                MutationObserver$1,
                PowerTransforms,
                Masks,
                MissingIconIndicator,
                SvgSymbols
            ];
            registerPlugins(plugins, {
                mixoutsTo: api
            });
            api.noAuto;
            api.config;
            const library$1 = api.library;
            api.dom;
            const parse$1 = api.parse;
            api.findIconDefinition;
            api.toHtml;
            const icon = api.icon;
            api.layer;
            api.text;
            api.counter;
            function _defineProperty(e, r2, t2) {
                return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
                    value: t2,
                    enumerable: true,
                    configurable: true,
                    writable: true
                }) : e[r2] = t2, e;
            }
            function ownKeys(e, r2) {
                var t2 = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var o2 = Object.getOwnPropertySymbols(e);
                    r2 && (o2 = o2.filter(function(r22) {
                        return Object.getOwnPropertyDescriptor(e, r22).enumerable;
                    })), t2.push.apply(t2, o2);
                }
                return t2;
            }
            function _objectSpread2(e) {
                for(var r2 = 1; r2 < arguments.length; r2++){
                    var t2 = null != arguments[r2] ? arguments[r2] : {};
                    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r22) {
                        _defineProperty(e, r22, t2[r22]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r22) {
                        Object.defineProperty(e, r22, Object.getOwnPropertyDescriptor(t2, r22));
                    });
                }
                return e;
            }
            function _objectWithoutProperties(e, t2) {
                if (null == e) return {};
                var o2, r2, i = _objectWithoutPropertiesLoose(e, t2);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    for(r2 = 0; r2 < n.length; r2++)o2 = n[r2], -1 === t2.indexOf(o2) && {}.propertyIsEnumerable.call(e, o2) && (i[o2] = e[o2]);
                }
                return i;
            }
            function _objectWithoutPropertiesLoose(r2, e) {
                if (null == r2) return {};
                var t2 = {};
                for(var n in r2)if ({}.hasOwnProperty.call(r2, n)) {
                    if (-1 !== e.indexOf(n)) continue;
                    t2[n] = r2[n];
                }
                return t2;
            }
            function _toPrimitive(t2, r2) {
                if ("object" != typeof t2 || !t2) return t2;
                var e = t2[Symbol.toPrimitive];
                if (void 0 !== e) {
                    var i = e.call(t2, r2);
                    if ("object" != typeof i) return i;
                    throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === r2 ? String : Number)(t2);
            }
            function _toPropertyKey(t2) {
                var i = _toPrimitive(t2, "string");
                return "symbol" == typeof i ? i : i + "";
            }
            function _typeof(o2) {
                "@babel/helpers - typeof";
                return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o22) {
                    return typeof o22;
                } : function(o22) {
                    return o22 && "function" == typeof Symbol && o22.constructor === Symbol && o22 !== Symbol.prototype ? "symbol" : typeof o22;
                }, _typeof(o2);
            }
            function objectWithKey(key, value) {
                return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty({}, key, value) : {};
            }
            function classList(props) {
                var _classes;
                var classes = (_classes = {
                    "fa-spin": props.spin,
                    "fa-pulse": props.pulse,
                    "fa-fw": props.fixedWidth,
                    "fa-border": props.border,
                    "fa-li": props.listItem,
                    "fa-inverse": props.inverse,
                    "fa-flip": props.flip === true,
                    "fa-flip-horizontal": props.flip === "horizontal" || props.flip === "both",
                    "fa-flip-vertical": props.flip === "vertical" || props.flip === "both"
                }, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_classes, "fa-".concat(props.size), props.size !== null), "fa-rotate-".concat(props.rotation), props.rotation !== null), "fa-rotate-by", props.rotateBy), "fa-pull-".concat(props.pull), props.pull !== null), "fa-swap-opacity", props.swapOpacity), "fa-bounce", props.bounce), "fa-shake", props.shake), "fa-beat", props.beat), "fa-fade", props.fade), "fa-beat-fade", props.beatFade), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_classes, "fa-flash", props.flash), "fa-spin-pulse", props.spinPulse), "fa-spin-reverse", props.spinReverse), "fa-width-auto", props.widthAuto));
                return Object.keys(classes).map(function(key) {
                    return classes[key] ? key : null;
                }).filter(function(key) {
                    return key;
                });
            }
            var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
            var humps$1 = {
                exports: {}
            };
            (function(module2) {
                (function(global2) {
                    var _processKeys = function(convert2, obj, options) {
                        if (!_isObject(obj) || _isDate(obj) || _isRegExp(obj) || _isBoolean(obj) || _isFunction(obj)) {
                            return obj;
                        }
                        var output, i = 0, l = 0;
                        if (_isArray(obj)) {
                            output = [];
                            for(l = obj.length; i < l; i++){
                                output.push(_processKeys(convert2, obj[i], options));
                            }
                        } else {
                            output = {};
                            for(var key in obj){
                                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                                    output[convert2(key, options)] = _processKeys(convert2, obj[key], options);
                                }
                            }
                        }
                        return output;
                    };
                    var separateWords = function(string, options) {
                        options = options || {};
                        var separator = options.separator || "_";
                        var split = options.split || /(?=[A-Z])/;
                        return string.split(split).join(separator);
                    };
                    var camelize2 = function(string) {
                        if (_isNumerical(string)) {
                            return string;
                        }
                        string = string.replace(/[\-_\s]+(.)?/g, function(match, chr) {
                            return chr ? chr.toUpperCase() : "";
                        });
                        return string.substr(0, 1).toLowerCase() + string.substr(1);
                    };
                    var pascalize = function(string) {
                        var camelized = camelize2(string);
                        return camelized.substr(0, 1).toUpperCase() + camelized.substr(1);
                    };
                    var decamelize = function(string, options) {
                        return separateWords(string, options).toLowerCase();
                    };
                    var toString2 = Object.prototype.toString;
                    var _isFunction = function(obj) {
                        return typeof obj === "function";
                    };
                    var _isObject = function(obj) {
                        return obj === Object(obj);
                    };
                    var _isArray = function(obj) {
                        return toString2.call(obj) == "[object Array]";
                    };
                    var _isDate = function(obj) {
                        return toString2.call(obj) == "[object Date]";
                    };
                    var _isRegExp = function(obj) {
                        return toString2.call(obj) == "[object RegExp]";
                    };
                    var _isBoolean = function(obj) {
                        return toString2.call(obj) == "[object Boolean]";
                    };
                    var _isNumerical = function(obj) {
                        obj = obj - 0;
                        return obj === obj;
                    };
                    var _processor = function(convert2, options) {
                        var callback = options && "process" in options ? options.process : options;
                        if (typeof callback !== "function") {
                            return convert2;
                        }
                        return function(string, options2) {
                            return callback(string, convert2, options2);
                        };
                    };
                    var humps2 = {
                        camelize: camelize2,
                        decamelize,
                        pascalize,
                        depascalize: decamelize,
                        camelizeKeys: function(object, options) {
                            return _processKeys(_processor(camelize2, options), object);
                        },
                        decamelizeKeys: function(object, options) {
                            return _processKeys(_processor(decamelize, options), object, options);
                        },
                        pascalizeKeys: function(object, options) {
                            return _processKeys(_processor(pascalize, options), object);
                        },
                        depascalizeKeys: function() {
                            return this.decamelizeKeys.apply(this, arguments);
                        }
                    };
                    if (module2.exports) {
                        module2.exports = humps2;
                    } else {
                        global2.humps = humps2;
                    }
                })(commonjsGlobal);
            })(humps$1);
            var humps = humps$1.exports;
            var _excluded = [
                "class",
                "style"
            ];
            function styleToObject(style) {
                return style.split(";").map(function(s2) {
                    return s2.trim();
                }).filter(function(s2) {
                    return s2;
                }).reduce(function(output, pair) {
                    var idx = pair.indexOf(":");
                    var prop = humps.camelize(pair.slice(0, idx));
                    var value = pair.slice(idx + 1).trim();
                    output[prop] = value;
                    return output;
                }, {});
            }
            function classToObject(classes) {
                return classes.split(/\s+/).reduce(function(output, className) {
                    output[className] = true;
                    return output;
                }, {});
            }
            function convert(abstractElement) {
                var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                if (typeof abstractElement === "string") {
                    return abstractElement;
                }
                var children = (abstractElement.children || []).map(function(child) {
                    return convert(child);
                });
                var mixins = Object.keys(abstractElement.attributes || {}).reduce(function(mixins2, key) {
                    var value = abstractElement.attributes[key];
                    switch(key){
                        case "class":
                            mixins2.class = classToObject(value);
                            break;
                        case "style":
                            mixins2.style = styleToObject(value);
                            break;
                        default:
                            mixins2.attrs[key] = value;
                    }
                    return mixins2;
                }, {
                    attrs: {},
                    class: {},
                    style: {}
                });
                attrs.class;
                var _attrs$style = attrs.style, aStyle = _attrs$style === void 0 ? {} : _attrs$style, otherAttrs = _objectWithoutProperties(attrs, _excluded);
                return h(abstractElement.tag, _objectSpread2(_objectSpread2(_objectSpread2({}, props), {}, {
                    class: mixins.class,
                    style: _objectSpread2(_objectSpread2({}, mixins.style), aStyle)
                }, mixins.attrs), otherAttrs), children);
            }
            var PRODUCTION = false;
            try {
                PRODUCTION = true;
            } catch (e) {}
            function log() {
                if (!PRODUCTION && console && typeof console.error === "function") {
                    var _console;
                    (_console = console).error.apply(_console, arguments);
                }
            }
            function normalizeIconArgs(icon2) {
                if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
                    return icon2;
                }
                if (parse$1.icon) {
                    return parse$1.icon(icon2);
                }
                if (icon2 === null) {
                    return null;
                }
                if (_typeof(icon2) === "object" && icon2.prefix && icon2.iconName) {
                    return icon2;
                }
                if (Array.isArray(icon2) && icon2.length === 2) {
                    return {
                        prefix: icon2[0],
                        iconName: icon2[1]
                    };
                }
                if (typeof icon2 === "string") {
                    return {
                        prefix: "fas",
                        iconName: icon2
                    };
                }
            }
            var FontAwesomeIcon = defineComponent({
                name: "FontAwesomeIcon",
                props: {
                    border: {
                        type: Boolean,
                        default: false
                    },
                    fixedWidth: {
                        type: Boolean,
                        default: false
                    },
                    flip: {
                        type: [
                            Boolean,
                            String
                        ],
                        default: false,
                        validator: function validator2(value) {
                            return [
                                true,
                                false,
                                "horizontal",
                                "vertical",
                                "both"
                            ].indexOf(value) > -1;
                        }
                    },
                    icon: {
                        type: [
                            Object,
                            Array,
                            String
                        ],
                        required: true
                    },
                    mask: {
                        type: [
                            Object,
                            Array,
                            String
                        ],
                        default: null
                    },
                    maskId: {
                        type: String,
                        default: null
                    },
                    listItem: {
                        type: Boolean,
                        default: false
                    },
                    pull: {
                        type: String,
                        default: null,
                        validator: function validator2(value) {
                            return [
                                "right",
                                "left"
                            ].indexOf(value) > -1;
                        }
                    },
                    pulse: {
                        type: Boolean,
                        default: false
                    },
                    rotation: {
                        type: [
                            String,
                            Number
                        ],
                        default: null,
                        validator: function validator3(value) {
                            return [
                                90,
                                180,
                                270
                            ].indexOf(Number.parseInt(value, 10)) > -1;
                        }
                    },
                    rotateBy: {
                        type: Boolean,
                        default: false
                    },
                    swapOpacity: {
                        type: Boolean,
                        default: false
                    },
                    size: {
                        type: String,
                        default: null,
                        validator: function validator4(value) {
                            return [
                                "2xs",
                                "xs",
                                "sm",
                                "lg",
                                "xl",
                                "2xl",
                                "1x",
                                "2x",
                                "3x",
                                "4x",
                                "5x",
                                "6x",
                                "7x",
                                "8x",
                                "9x",
                                "10x"
                            ].indexOf(value) > -1;
                        }
                    },
                    spin: {
                        type: Boolean,
                        default: false
                    },
                    transform: {
                        type: [
                            String,
                            Object
                        ],
                        default: null
                    },
                    symbol: {
                        type: [
                            Boolean,
                            String
                        ],
                        default: false
                    },
                    title: {
                        type: String,
                        default: null
                    },
                    titleId: {
                        type: String,
                        default: null
                    },
                    inverse: {
                        type: Boolean,
                        default: false
                    },
                    bounce: {
                        type: Boolean,
                        default: false
                    },
                    shake: {
                        type: Boolean,
                        default: false
                    },
                    beat: {
                        type: Boolean,
                        default: false
                    },
                    fade: {
                        type: Boolean,
                        default: false
                    },
                    beatFade: {
                        type: Boolean,
                        default: false
                    },
                    flash: {
                        type: Boolean,
                        default: false
                    },
                    spinPulse: {
                        type: Boolean,
                        default: false
                    },
                    spinReverse: {
                        type: Boolean,
                        default: false
                    },
                    widthAuto: {
                        type: Boolean,
                        default: false
                    }
                },
                setup: function setup(props, _ref) {
                    var attrs = _ref.attrs;
                    var icon$1 = computed(function() {
                        return normalizeIconArgs(props.icon);
                    });
                    var classes = computed(function() {
                        return objectWithKey("classes", classList(props));
                    });
                    var transform = computed(function() {
                        return objectWithKey("transform", typeof props.transform === "string" ? parse$1.transform(props.transform) : props.transform);
                    });
                    var mask = computed(function() {
                        return objectWithKey("mask", normalizeIconArgs(props.mask));
                    });
                    var renderedIcon = computed(function() {
                        var iconProps = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, classes.value), transform.value), mask.value), {}, {
                            symbol: props.symbol,
                            maskId: props.maskId
                        });
                        iconProps.title = props.title;
                        iconProps.titleId = props.titleId;
                        return icon(icon$1.value, iconProps);
                    });
                    watch(renderedIcon, function(value) {
                        if (!value) {
                            return log("Could not find one or more icon(s)", icon$1.value, mask.value);
                        }
                    }, {
                        immediate: true
                    });
                    var vnode = computed(function() {
                        return renderedIcon.value ? convert(renderedIcon.value.abstract[0], {}, attrs) : null;
                    });
                    return function() {
                        return vnode.value;
                    };
                }
            });
            function getAugmentedNamespace(n) {
                if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
                var f = n.default;
                if (typeof f == "function") {
                    var a = function a2() {
                        var isInstance = false;
                        try {
                            isInstance = this instanceof a2;
                        } catch  {}
                        if (isInstance) {
                            return Reflect.construct(f, arguments, this.constructor);
                        }
                        return f.apply(this, arguments);
                    };
                    a.prototype = f.prototype;
                } else a = {};
                Object.defineProperty(a, "__esModule", {
                    value: true
                });
                Object.keys(n).forEach(function(k) {
                    var d = Object.getOwnPropertyDescriptor(n, k);
                    Object.defineProperty(a, k, d.get ? d : {
                        enumerable: true,
                        get: function() {
                            return n[k];
                        }
                    });
                });
                return a;
            }
            var faRotateRight = {};
            var hasRequiredFaRotateRight;
            function requireFaRotateRight() {
                if (hasRequiredFaRotateRight) return faRotateRight;
                hasRequiredFaRotateRight = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "rotate-right";
                    var width = 512;
                    var height = 512;
                    var aliases = [
                        "redo-alt",
                        "rotate-forward"
                    ];
                    var unicode = "f2f9";
                    var svgPathData = "M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faRotateRight = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faRotateRight);
                return faRotateRight;
            }
            var faRotateRightExports = requireFaRotateRight();
            var faArrowsRotate = {};
            var hasRequiredFaArrowsRotate;
            function requireFaArrowsRotate() {
                if (hasRequiredFaArrowsRotate) return faArrowsRotate;
                hasRequiredFaArrowsRotate = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "arrows-rotate";
                    var width = 512;
                    var height = 512;
                    var aliases = [
                        128472,
                        "refresh",
                        "sync"
                    ];
                    var unicode = "f021";
                    var svgPathData = "M105.1 202.6c7.7-21.8 20.2-42.3 37.8-59.8c62.5-62.5 163.8-62.5 226.3 0L386.3 160 352 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l111.5 0c0 0 0 0 0 0l.4 0c17.7 0 32-14.3 32-32l0-112c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 35.2L414.4 97.6c-87.5-87.5-229.3-87.5-316.8 0C73.2 122 55.6 150.7 44.8 181.4c-5.9 16.7 2.9 34.9 19.5 40.8s34.9-2.9 40.8-19.5zM39 289.3c-5 1.5-9.8 4.2-13.7 8.2c-4 4-6.7 8.8-8.1 14c-.3 1.2-.6 2.5-.8 3.8c-.3 1.7-.4 3.4-.4 5.1L16 432c0 17.7 14.3 32 32 32s32-14.3 32-32l0-35.1 17.6 17.5c0 0 0 0 0 0c87.5 87.4 229.3 87.4 316.7 0c24.4-24.4 42.1-53.1 52.9-83.8c5.9-16.7-2.9-34.9-19.5-40.8s-34.9 2.9-40.8 19.5c-7.7 21.8-20.2 42.3-37.8 59.8c-62.5 62.5-163.8 62.5-226.3 0l-.1-.1L125.6 352l34.4 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L48.4 288c-1.6 0-3.2 .1-4.8 .3s-3.1 .5-4.6 1z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faArrowsRotate = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faArrowsRotate);
                return faArrowsRotate;
            }
            var faArrowsRotateExports = requireFaArrowsRotate();
            var faClipboard = {};
            var hasRequiredFaClipboard;
            function requireFaClipboard() {
                if (hasRequiredFaClipboard) return faClipboard;
                hasRequiredFaClipboard = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "clipboard";
                    var width = 384;
                    var height = 512;
                    var aliases = [
                        128203
                    ];
                    var unicode = "f328";
                    var svgPathData = "M192 0c-41.8 0-77.4 26.7-90.5 64L64 64C28.7 64 0 92.7 0 128L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64l-37.5 0C269.4 26.7 233.8 0 192 0zm0 64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM112 192l160 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-160 0c-8.8 0-16-7.2-16-16s7.2-16 16-16z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faClipboard = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faClipboard);
                return faClipboard;
            }
            var faClipboardExports = requireFaClipboard();
            var faExternalLink = {};
            var faArrowUpRightFromSquare = {};
            var hasRequiredFaArrowUpRightFromSquare;
            function requireFaArrowUpRightFromSquare() {
                if (hasRequiredFaArrowUpRightFromSquare) return faArrowUpRightFromSquare;
                hasRequiredFaArrowUpRightFromSquare = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "arrow-up-right-from-square";
                    var width = 512;
                    var height = 512;
                    var aliases = [
                        "external-link"
                    ];
                    var unicode = "f08e";
                    var svgPathData = "M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l82.7 0L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3l0 82.7c0 17.7 14.3 32 32 32s32-14.3 32-32l0-160c0-17.7-14.3-32-32-32L320 0zM80 32C35.8 32 0 67.8 0 112L0 432c0 44.2 35.8 80 80 80l320 0c44.2 0 80-35.8 80-80l0-112c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 112c0 8.8-7.2 16-16 16L80 448c-8.8 0-16-7.2-16-16l0-320c0-8.8 7.2-16 16-16l112 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faArrowUpRightFromSquare = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faArrowUpRightFromSquare);
                return faArrowUpRightFromSquare;
            }
            var hasRequiredFaExternalLink;
            function requireFaExternalLink() {
                if (hasRequiredFaExternalLink) return faExternalLink;
                hasRequiredFaExternalLink = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var source = requireFaArrowUpRightFromSquare();
                    exports2.definition = {
                        prefix: source.prefix,
                        iconName: source.iconName,
                        icon: [
                            source.width,
                            source.height,
                            source.aliases,
                            source.unicode,
                            source.svgPathData
                        ]
                    };
                    exports2.faExternalLink = exports2.definition;
                    exports2.prefix = source.prefix;
                    exports2.iconName = source.iconName;
                    exports2.width = source.width;
                    exports2.height = source.height;
                    exports2.ligatures = source.aliases;
                    exports2.unicode = source.unicode;
                    exports2.svgPathData = source.svgPathData;
                    exports2.aliases = source.aliases;
                })(faExternalLink);
                return faExternalLink;
            }
            var faExternalLinkExports = requireFaExternalLink();
            var faEye = {};
            var hasRequiredFaEye;
            function requireFaEye() {
                if (hasRequiredFaEye) return faEye;
                hasRequiredFaEye = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "eye";
                    var width = 576;
                    var height = 512;
                    var aliases = [
                        128065
                    ];
                    var unicode = "f06e";
                    var svgPathData = "M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faEye = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faEye);
                return faEye;
            }
            var faEyeExports = requireFaEye();
            var faLink = {};
            var hasRequiredFaLink;
            function requireFaLink() {
                if (hasRequiredFaLink) return faLink;
                hasRequiredFaLink = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "link";
                    var width = 640;
                    var height = 512;
                    var aliases = [
                        128279,
                        "chain"
                    ];
                    var unicode = "f0c1";
                    var svgPathData = "M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faLink = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faLink);
                return faLink;
            }
            var faLinkExports = requireFaLink();
            var faList = {};
            var hasRequiredFaList;
            function requireFaList() {
                if (hasRequiredFaList) return faList;
                hasRequiredFaList = 1;
                (function(exports2) {
                    Object.defineProperty(exports2, "__esModule", {
                        value: true
                    });
                    var prefix = "fas";
                    var iconName = "list";
                    var width = 512;
                    var height = 512;
                    var aliases = [
                        "list-squares"
                    ];
                    var unicode = "f03a";
                    var svgPathData = "M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z";
                    exports2.definition = {
                        prefix,
                        iconName,
                        icon: [
                            width,
                            height,
                            aliases,
                            unicode,
                            svgPathData
                        ]
                    };
                    exports2.faList = exports2.definition;
                    exports2.prefix = prefix;
                    exports2.iconName = iconName;
                    exports2.width = width;
                    exports2.height = height;
                    exports2.ligatures = aliases;
                    exports2.unicode = unicode;
                    exports2.svgPathData = svgPathData;
                    exports2.aliases = aliases;
                })(faList);
                return faList;
            }
            var faListExports = requireFaList();
            library$1.add(faEyeExports.faEye, faExternalLinkExports.faExternalLink, faListExports.faList, faArrowsRotateExports.faArrowsRotate, faClipboardExports.faClipboard, faLinkExports.faLink, faRotateRightExports.faRotateRight);
            var bootstrap$1 = {
                exports: {}
            };
            var top = "top";
            var bottom = "bottom";
            var right = "right";
            var left = "left";
            var auto = "auto";
            var basePlacements = [
                top,
                bottom,
                right,
                left
            ];
            var start = "start";
            var end = "end";
            var clippingParents = "clippingParents";
            var viewport = "viewport";
            var popper = "popper";
            var reference = "reference";
            var variationPlacements = basePlacements.reduce(function(acc, placement) {
                return acc.concat([
                    placement + "-" + start,
                    placement + "-" + end
                ]);
            }, []);
            var placements = [].concat(basePlacements, [
                auto
            ]).reduce(function(acc, placement) {
                return acc.concat([
                    placement,
                    placement + "-" + start,
                    placement + "-" + end
                ]);
            }, []);
            var beforeRead = "beforeRead";
            var read = "read";
            var afterRead = "afterRead";
            var beforeMain = "beforeMain";
            var main = "main";
            var afterMain = "afterMain";
            var beforeWrite = "beforeWrite";
            var write = "write";
            var afterWrite = "afterWrite";
            var modifierPhases = [
                beforeRead,
                read,
                afterRead,
                beforeMain,
                main,
                afterMain,
                beforeWrite,
                write,
                afterWrite
            ];
            function getNodeName(element) {
                return element ? (element.nodeName || "").toLowerCase() : null;
            }
            function getWindow(node) {
                if (node == null) {
                    return window;
                }
                if (node.toString() !== "[object Window]") {
                    var ownerDocument = node.ownerDocument;
                    return ownerDocument ? ownerDocument.defaultView || window : window;
                }
                return node;
            }
            function isElement(node) {
                var OwnElement = getWindow(node).Element;
                return node instanceof OwnElement || node instanceof Element;
            }
            function isHTMLElement(node) {
                var OwnElement = getWindow(node).HTMLElement;
                return node instanceof OwnElement || node instanceof HTMLElement;
            }
            function isShadowRoot(node) {
                if (typeof ShadowRoot === "undefined") {
                    return false;
                }
                var OwnElement = getWindow(node).ShadowRoot;
                return node instanceof OwnElement || node instanceof ShadowRoot;
            }
            function applyStyles(_ref) {
                var state = _ref.state;
                Object.keys(state.elements).forEach(function(name) {
                    var style = state.styles[name] || {};
                    var attributes = state.attributes[name] || {};
                    var element = state.elements[name];
                    if (!isHTMLElement(element) || !getNodeName(element)) {
                        return;
                    }
                    Object.assign(element.style, style);
                    Object.keys(attributes).forEach(function(name2) {
                        var value = attributes[name2];
                        if (value === false) {
                            element.removeAttribute(name2);
                        } else {
                            element.setAttribute(name2, value === true ? "" : value);
                        }
                    });
                });
            }
            function effect$2(_ref2) {
                var state = _ref2.state;
                var initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                Object.assign(state.elements.popper.style, initialStyles.popper);
                state.styles = initialStyles;
                if (state.elements.arrow) {
                    Object.assign(state.elements.arrow.style, initialStyles.arrow);
                }
                return function() {
                    Object.keys(state.elements).forEach(function(name) {
                        var element = state.elements[name];
                        var attributes = state.attributes[name] || {};
                        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                        var style = styleProperties.reduce(function(style2, property) {
                            style2[property] = "";
                            return style2;
                        }, {});
                        if (!isHTMLElement(element) || !getNodeName(element)) {
                            return;
                        }
                        Object.assign(element.style, style);
                        Object.keys(attributes).forEach(function(attribute) {
                            element.removeAttribute(attribute);
                        });
                    });
                };
            }
            const applyStyles$1 = {
                name: "applyStyles",
                enabled: true,
                phase: "write",
                fn: applyStyles,
                effect: effect$2,
                requires: [
                    "computeStyles"
                ]
            };
            function getBasePlacement(placement) {
                return placement.split("-")[0];
            }
            var max = Math.max;
            var min = Math.min;
            var round = Math.round;
            function getUAString() {
                var uaData = navigator.userAgentData;
                if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
                    return uaData.brands.map(function(item) {
                        return item.brand + "/" + item.version;
                    }).join(" ");
                }
                return navigator.userAgent;
            }
            function isLayoutViewport() {
                return !/^((?!chrome|android).)*safari/i.test(getUAString());
            }
            function getBoundingClientRect(element, includeScale, isFixedStrategy) {
                if (includeScale === void 0) {
                    includeScale = false;
                }
                if (isFixedStrategy === void 0) {
                    isFixedStrategy = false;
                }
                var clientRect = element.getBoundingClientRect();
                var scaleX = 1;
                var scaleY = 1;
                if (includeScale && isHTMLElement(element)) {
                    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
                    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
                }
                var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
                var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
                var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
                var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
                var width = clientRect.width / scaleX;
                var height = clientRect.height / scaleY;
                return {
                    width,
                    height,
                    top: y,
                    right: x2 + width,
                    bottom: y + height,
                    left: x2,
                    x: x2,
                    y
                };
            }
            function getLayoutRect(element) {
                var clientRect = getBoundingClientRect(element);
                var width = element.offsetWidth;
                var height = element.offsetHeight;
                if (Math.abs(clientRect.width - width) <= 1) {
                    width = clientRect.width;
                }
                if (Math.abs(clientRect.height - height) <= 1) {
                    height = clientRect.height;
                }
                return {
                    x: element.offsetLeft,
                    y: element.offsetTop,
                    width,
                    height
                };
            }
            function contains(parent, child) {
                var rootNode = child.getRootNode && child.getRootNode();
                if (parent.contains(child)) {
                    return true;
                } else if (rootNode && isShadowRoot(rootNode)) {
                    var next = child;
                    do {
                        if (next && parent.isSameNode(next)) {
                            return true;
                        }
                        next = next.parentNode || next.host;
                    }while (next)
                }
                return false;
            }
            function getComputedStyle$1(element) {
                return getWindow(element).getComputedStyle(element);
            }
            function isTableElement(element) {
                return [
                    "table",
                    "td",
                    "th"
                ].indexOf(getNodeName(element)) >= 0;
            }
            function getDocumentElement(element) {
                return ((isElement(element) ? element.ownerDocument : (element.document)) || window.document).documentElement;
            }
            function getParentNode(element) {
                if (getNodeName(element) === "html") {
                    return element;
                }
                return (element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element));
            }
            function getTrueOffsetParent(element) {
                if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
                    return null;
                }
                return element.offsetParent;
            }
            function getContainingBlock(element) {
                var isFirefox = /firefox/i.test(getUAString());
                var isIE = /Trident/i.test(getUAString());
                if (isIE && isHTMLElement(element)) {
                    var elementCss = getComputedStyle$1(element);
                    if (elementCss.position === "fixed") {
                        return null;
                    }
                }
                var currentNode = getParentNode(element);
                if (isShadowRoot(currentNode)) {
                    currentNode = currentNode.host;
                }
                while(isHTMLElement(currentNode) && [
                    "html",
                    "body"
                ].indexOf(getNodeName(currentNode)) < 0){
                    var css2 = getComputedStyle$1(currentNode);
                    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || [
                        "transform",
                        "perspective"
                    ].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
                        return currentNode;
                    } else {
                        currentNode = currentNode.parentNode;
                    }
                }
                return null;
            }
            function getOffsetParent(element) {
                var window2 = getWindow(element);
                var offsetParent = getTrueOffsetParent(element);
                while(offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static"){
                    offsetParent = getTrueOffsetParent(offsetParent);
                }
                if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
                    return window2;
                }
                return offsetParent || getContainingBlock(element) || window2;
            }
            function getMainAxisFromPlacement(placement) {
                return [
                    "top",
                    "bottom"
                ].indexOf(placement) >= 0 ? "x" : "y";
            }
            function within(min$1, value, max$1) {
                return max(min$1, min(value, max$1));
            }
            function withinMaxClamp(min2, value, max2) {
                var v = within(min2, value, max2);
                return v > max2 ? max2 : v;
            }
            function getFreshSideObject() {
                return {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                };
            }
            function mergePaddingObject(paddingObject) {
                return Object.assign({}, getFreshSideObject(), paddingObject);
            }
            function expandToHashMap(value, keys) {
                return keys.reduce(function(hashMap, key) {
                    hashMap[key] = value;
                    return hashMap;
                }, {});
            }
            var toPaddingObject = function toPaddingObject2(padding, state) {
                padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
                    placement: state.placement
                })) : padding;
                return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
            };
            function arrow(_ref) {
                var _state$modifiersData$;
                var state = _ref.state, name = _ref.name, options = _ref.options;
                var arrowElement = state.elements.arrow;
                var popperOffsets2 = state.modifiersData.popperOffsets;
                var basePlacement = getBasePlacement(state.placement);
                var axis = getMainAxisFromPlacement(basePlacement);
                var isVertical = [
                    left,
                    right
                ].indexOf(basePlacement) >= 0;
                var len = isVertical ? "height" : "width";
                if (!arrowElement || !popperOffsets2) {
                    return;
                }
                var paddingObject = toPaddingObject(options.padding, state);
                var arrowRect = getLayoutRect(arrowElement);
                var minProp = axis === "y" ? top : left;
                var maxProp = axis === "y" ? bottom : right;
                var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
                var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
                var arrowOffsetParent = getOffsetParent(arrowElement);
                var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
                var centerToReference = endDiff / 2 - startDiff / 2;
                var min2 = paddingObject[minProp];
                var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
                var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
                var offset2 = within(min2, center, max2);
                var axisProp = axis;
                state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
            }
            function effect$1(_ref2) {
                var state = _ref2.state, options = _ref2.options;
                var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
                if (arrowElement == null) {
                    return;
                }
                if (typeof arrowElement === "string") {
                    arrowElement = state.elements.popper.querySelector(arrowElement);
                    if (!arrowElement) {
                        return;
                    }
                }
                if (!contains(state.elements.popper, arrowElement)) {
                    return;
                }
                state.elements.arrow = arrowElement;
            }
            const arrow$1 = {
                name: "arrow",
                enabled: true,
                phase: "main",
                fn: arrow,
                effect: effect$1,
                requires: [
                    "popperOffsets"
                ],
                requiresIfExists: [
                    "preventOverflow"
                ]
            };
            function getVariation(placement) {
                return placement.split("-")[1];
            }
            var unsetSides = {
                top: "auto",
                right: "auto",
                bottom: "auto",
                left: "auto"
            };
            function roundOffsetsByDPR(_ref, win) {
                var x2 = _ref.x, y = _ref.y;
                var dpr = win.devicePixelRatio || 1;
                return {
                    x: round(x2 * dpr) / dpr || 0,
                    y: round(y * dpr) / dpr || 0
                };
            }
            function mapToStyles(_ref2) {
                var _Object$assign2;
                var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
                var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
                var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
                    x: x2,
                    y
                }) : {
                    x: x2,
                    y
                };
                x2 = _ref3.x;
                y = _ref3.y;
                var hasX = offsets.hasOwnProperty("x");
                var hasY = offsets.hasOwnProperty("y");
                var sideX = left;
                var sideY = top;
                var win = window;
                if (adaptive) {
                    var offsetParent = getOffsetParent(popper2);
                    var heightProp = "clientHeight";
                    var widthProp = "clientWidth";
                    if (offsetParent === getWindow(popper2)) {
                        offsetParent = getDocumentElement(popper2);
                        if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
                            heightProp = "scrollHeight";
                            widthProp = "scrollWidth";
                        }
                    }
                    offsetParent = offsetParent;
                    if (placement === top || (placement === left || placement === right) && variation === end) {
                        sideY = bottom;
                        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (offsetParent[heightProp]);
                        y -= offsetY - popperRect.height;
                        y *= gpuAcceleration ? 1 : -1;
                    }
                    if (placement === left || (placement === top || placement === bottom) && variation === end) {
                        sideX = right;
                        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (offsetParent[widthProp]);
                        x2 -= offsetX - popperRect.width;
                        x2 *= gpuAcceleration ? 1 : -1;
                    }
                }
                var commonStyles = Object.assign({
                    position
                }, adaptive && unsetSides);
                var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
                    x: x2,
                    y
                }, getWindow(popper2)) : {
                    x: x2,
                    y
                };
                x2 = _ref4.x;
                y = _ref4.y;
                if (gpuAcceleration) {
                    var _Object$assign;
                    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y + "px)" : "translate3d(" + x2 + "px, " + y + "px, 0)", _Object$assign));
                }
                return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
            }
            function computeStyles(_ref5) {
                var state = _ref5.state, options = _ref5.options;
                var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
                var commonStyles = {
                    placement: getBasePlacement(state.placement),
                    variation: getVariation(state.placement),
                    popper: state.elements.popper,
                    popperRect: state.rects.popper,
                    gpuAcceleration,
                    isFixed: state.options.strategy === "fixed"
                };
                if (state.modifiersData.popperOffsets != null) {
                    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                        offsets: state.modifiersData.popperOffsets,
                        position: state.options.strategy,
                        adaptive,
                        roundOffsets
                    })));
                }
                if (state.modifiersData.arrow != null) {
                    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                        offsets: state.modifiersData.arrow,
                        position: "absolute",
                        adaptive: false,
                        roundOffsets
                    })));
                }
                state.attributes.popper = Object.assign({}, state.attributes.popper, {
                    "data-popper-placement": state.placement
                });
            }
            const computeStyles$1 = {
                name: "computeStyles",
                enabled: true,
                phase: "beforeWrite",
                fn: computeStyles,
                data: {}
            };
            var passive = {
                passive: true
            };
            function effect(_ref) {
                var state = _ref.state, instance = _ref.instance, options = _ref.options;
                var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
                var window2 = getWindow(state.elements.popper);
                var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
                if (scroll) {
                    scrollParents.forEach(function(scrollParent) {
                        scrollParent.addEventListener("scroll", instance.update, passive);
                    });
                }
                if (resize) {
                    window2.addEventListener("resize", instance.update, passive);
                }
                return function() {
                    if (scroll) {
                        scrollParents.forEach(function(scrollParent) {
                            scrollParent.removeEventListener("scroll", instance.update, passive);
                        });
                    }
                    if (resize) {
                        window2.removeEventListener("resize", instance.update, passive);
                    }
                };
            }
            const eventListeners = {
                name: "eventListeners",
                enabled: true,
                phase: "write",
                fn: function fn() {},
                effect,
                data: {}
            };
            var hash$1 = {
                left: "right",
                right: "left",
                bottom: "top",
                top: "bottom"
            };
            function getOppositePlacement(placement) {
                return placement.replace(/left|right|bottom|top/g, function(matched) {
                    return hash$1[matched];
                });
            }
            var hash = {
                start: "end",
                end: "start"
            };
            function getOppositeVariationPlacement(placement) {
                return placement.replace(/start|end/g, function(matched) {
                    return hash[matched];
                });
            }
            function getWindowScroll(node) {
                var win = getWindow(node);
                var scrollLeft = win.pageXOffset;
                var scrollTop = win.pageYOffset;
                return {
                    scrollLeft,
                    scrollTop
                };
            }
            function getWindowScrollBarX(element) {
                return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
            }
            function getViewportRect(element, strategy) {
                var win = getWindow(element);
                var html = getDocumentElement(element);
                var visualViewport = win.visualViewport;
                var width = html.clientWidth;
                var height = html.clientHeight;
                var x2 = 0;
                var y = 0;
                if (visualViewport) {
                    width = visualViewport.width;
                    height = visualViewport.height;
                    var layoutViewport = isLayoutViewport();
                    if (layoutViewport || !layoutViewport && strategy === "fixed") {
                        x2 = visualViewport.offsetLeft;
                        y = visualViewport.offsetTop;
                    }
                }
                return {
                    width,
                    height,
                    x: x2 + getWindowScrollBarX(element),
                    y
                };
            }
            function getDocumentRect(element) {
                var _element$ownerDocumen;
                var html = getDocumentElement(element);
                var winScroll = getWindowScroll(element);
                var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
                var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
                var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
                var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
                var y = -winScroll.scrollTop;
                if (getComputedStyle$1(body || html).direction === "rtl") {
                    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
                }
                return {
                    width,
                    height,
                    x: x2,
                    y
                };
            }
            function isScrollParent(element) {
                var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
                return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
            }
            function getScrollParent(node) {
                if ([
                    "html",
                    "body",
                    "#document"
                ].indexOf(getNodeName(node)) >= 0) {
                    return node.ownerDocument.body;
                }
                if (isHTMLElement(node) && isScrollParent(node)) {
                    return node;
                }
                return getScrollParent(getParentNode(node));
            }
            function listScrollParents(element, list) {
                var _element$ownerDocumen;
                if (list === void 0) {
                    list = [];
                }
                var scrollParent = getScrollParent(element);
                var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
                var win = getWindow(scrollParent);
                var target = isBody ? [
                    win
                ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
                var updatedList = list.concat(target);
                return isBody ? updatedList : (updatedList.concat(listScrollParents(getParentNode(target))));
            }
            function rectToClientRect(rect) {
                return Object.assign({}, rect, {
                    left: rect.x,
                    top: rect.y,
                    right: rect.x + rect.width,
                    bottom: rect.y + rect.height
                });
            }
            function getInnerBoundingClientRect(element, strategy) {
                var rect = getBoundingClientRect(element, false, strategy === "fixed");
                rect.top = rect.top + element.clientTop;
                rect.left = rect.left + element.clientLeft;
                rect.bottom = rect.top + element.clientHeight;
                rect.right = rect.left + element.clientWidth;
                rect.width = element.clientWidth;
                rect.height = element.clientHeight;
                rect.x = rect.left;
                rect.y = rect.top;
                return rect;
            }
            function getClientRectFromMixedType(element, clippingParent, strategy) {
                return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
            }
            function getClippingParents(element) {
                var clippingParents2 = listScrollParents(getParentNode(element));
                var canEscapeClipping = [
                    "absolute",
                    "fixed"
                ].indexOf(getComputedStyle$1(element).position) >= 0;
                var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
                if (!isElement(clipperElement)) {
                    return [];
                }
                return clippingParents2.filter(function(clippingParent) {
                    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
                });
            }
            function getClippingRect(element, boundary, rootBoundary, strategy) {
                var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
                var clippingParents2 = [].concat(mainClippingParents, [
                    rootBoundary
                ]);
                var firstClippingParent = clippingParents2[0];
                var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
                    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
                    accRect.top = max(rect.top, accRect.top);
                    accRect.right = min(rect.right, accRect.right);
                    accRect.bottom = min(rect.bottom, accRect.bottom);
                    accRect.left = max(rect.left, accRect.left);
                    return accRect;
                }, getClientRectFromMixedType(element, firstClippingParent, strategy));
                clippingRect.width = clippingRect.right - clippingRect.left;
                clippingRect.height = clippingRect.bottom - clippingRect.top;
                clippingRect.x = clippingRect.left;
                clippingRect.y = clippingRect.top;
                return clippingRect;
            }
            function computeOffsets(_ref) {
                var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
                var basePlacement = placement ? getBasePlacement(placement) : null;
                var variation = placement ? getVariation(placement) : null;
                var commonX = reference2.x + reference2.width / 2 - element.width / 2;
                var commonY = reference2.y + reference2.height / 2 - element.height / 2;
                var offsets;
                switch(basePlacement){
                    case top:
                        offsets = {
                            x: commonX,
                            y: reference2.y - element.height
                        };
                        break;
                    case bottom:
                        offsets = {
                            x: commonX,
                            y: reference2.y + reference2.height
                        };
                        break;
                    case right:
                        offsets = {
                            x: reference2.x + reference2.width,
                            y: commonY
                        };
                        break;
                    case left:
                        offsets = {
                            x: reference2.x - element.width,
                            y: commonY
                        };
                        break;
                    default:
                        offsets = {
                            x: reference2.x,
                            y: reference2.y
                        };
                }
                var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
                if (mainAxis != null) {
                    var len = mainAxis === "y" ? "height" : "width";
                    switch(variation){
                        case start:
                            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
                            break;
                        case end:
                            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
                            break;
                    }
                }
                return offsets;
            }
            function detectOverflow(state, options) {
                if (options === void 0) {
                    options = {};
                }
                var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
                var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
                var altContext = elementContext === popper ? reference : popper;
                var popperRect = state.rects.popper;
                var element = state.elements[altBoundary ? altContext : elementContext];
                var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
                var referenceClientRect = getBoundingClientRect(state.elements.reference);
                var popperOffsets2 = computeOffsets({
                    reference: referenceClientRect,
                    element: popperRect,
                    placement
                });
                var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
                var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
                var overflowOffsets = {
                    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
                };
                var offsetData = state.modifiersData.offset;
                if (elementContext === popper && offsetData) {
                    var offset2 = offsetData[placement];
                    Object.keys(overflowOffsets).forEach(function(key) {
                        var multiply = [
                            right,
                            bottom
                        ].indexOf(key) >= 0 ? 1 : -1;
                        var axis = [
                            top,
                            bottom
                        ].indexOf(key) >= 0 ? "y" : "x";
                        overflowOffsets[key] += offset2[axis] * multiply;
                    });
                }
                return overflowOffsets;
            }
            function computeAutoPlacement(state, options) {
                if (options === void 0) {
                    options = {};
                }
                var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
                var variation = getVariation(placement);
                var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
                    return getVariation(placement2) === variation;
                }) : basePlacements;
                var allowedPlacements = placements$1.filter(function(placement2) {
                    return allowedAutoPlacements.indexOf(placement2) >= 0;
                });
                if (allowedPlacements.length === 0) {
                    allowedPlacements = placements$1;
                }
                var overflows = allowedPlacements.reduce(function(acc, placement2) {
                    acc[placement2] = detectOverflow(state, {
                        placement: placement2,
                        boundary,
                        rootBoundary,
                        padding
                    })[getBasePlacement(placement2)];
                    return acc;
                }, {});
                return Object.keys(overflows).sort(function(a, b) {
                    return overflows[a] - overflows[b];
                });
            }
            function getExpandedFallbackPlacements(placement) {
                if (getBasePlacement(placement) === auto) {
                    return [];
                }
                var oppositePlacement = getOppositePlacement(placement);
                return [
                    getOppositeVariationPlacement(placement),
                    oppositePlacement,
                    getOppositeVariationPlacement(oppositePlacement)
                ];
            }
            function flip(_ref) {
                var state = _ref.state, options = _ref.options, name = _ref.name;
                if (state.modifiersData[name]._skip) {
                    return;
                }
                var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
                var preferredPlacement = state.options.placement;
                var basePlacement = getBasePlacement(preferredPlacement);
                var isBasePlacement = basePlacement === preferredPlacement;
                var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [
                    getOppositePlacement(preferredPlacement)
                ] : getExpandedFallbackPlacements(preferredPlacement));
                var placements2 = [
                    preferredPlacement
                ].concat(fallbackPlacements).reduce(function(acc, placement2) {
                    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
                        placement: placement2,
                        boundary,
                        rootBoundary,
                        padding,
                        flipVariations,
                        allowedAutoPlacements
                    }) : placement2);
                }, []);
                var referenceRect = state.rects.reference;
                var popperRect = state.rects.popper;
                var checksMap = new Map();
                var makeFallbackChecks = true;
                var firstFittingPlacement = placements2[0];
                for(var i = 0; i < placements2.length; i++){
                    var placement = placements2[i];
                    var _basePlacement = getBasePlacement(placement);
                    var isStartVariation = getVariation(placement) === start;
                    var isVertical = [
                        top,
                        bottom
                    ].indexOf(_basePlacement) >= 0;
                    var len = isVertical ? "width" : "height";
                    var overflow = detectOverflow(state, {
                        placement,
                        boundary,
                        rootBoundary,
                        altBoundary,
                        padding
                    });
                    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
                    if (referenceRect[len] > popperRect[len]) {
                        mainVariationSide = getOppositePlacement(mainVariationSide);
                    }
                    var altVariationSide = getOppositePlacement(mainVariationSide);
                    var checks = [];
                    if (checkMainAxis) {
                        checks.push(overflow[_basePlacement] <= 0);
                    }
                    if (checkAltAxis) {
                        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
                    }
                    if (checks.every(function(check) {
                        return check;
                    })) {
                        firstFittingPlacement = placement;
                        makeFallbackChecks = false;
                        break;
                    }
                    checksMap.set(placement, checks);
                }
                if (makeFallbackChecks) {
                    var numberOfChecks = flipVariations ? 3 : 1;
                    var _loop = function _loop2(_i2) {
                        var fittingPlacement = placements2.find(function(placement2) {
                            var checks2 = checksMap.get(placement2);
                            if (checks2) {
                                return checks2.slice(0, _i2).every(function(check) {
                                    return check;
                                });
                            }
                        });
                        if (fittingPlacement) {
                            firstFittingPlacement = fittingPlacement;
                            return "break";
                        }
                    };
                    for(var _i = numberOfChecks; _i > 0; _i--){
                        var _ret = _loop(_i);
                        if (_ret === "break") break;
                    }
                }
                if (state.placement !== firstFittingPlacement) {
                    state.modifiersData[name]._skip = true;
                    state.placement = firstFittingPlacement;
                    state.reset = true;
                }
            }
            const flip$1 = {
                name: "flip",
                enabled: true,
                phase: "main",
                fn: flip,
                requiresIfExists: [
                    "offset"
                ],
                data: {
                    _skip: false
                }
            };
            function getSideOffsets(overflow, rect, preventedOffsets) {
                if (preventedOffsets === void 0) {
                    preventedOffsets = {
                        x: 0,
                        y: 0
                    };
                }
                return {
                    top: overflow.top - rect.height - preventedOffsets.y,
                    right: overflow.right - rect.width + preventedOffsets.x,
                    bottom: overflow.bottom - rect.height + preventedOffsets.y,
                    left: overflow.left - rect.width - preventedOffsets.x
                };
            }
            function isAnySideFullyClipped(overflow) {
                return [
                    top,
                    right,
                    bottom,
                    left
                ].some(function(side) {
                    return overflow[side] >= 0;
                });
            }
            function hide(_ref) {
                var state = _ref.state, name = _ref.name;
                var referenceRect = state.rects.reference;
                var popperRect = state.rects.popper;
                var preventedOffsets = state.modifiersData.preventOverflow;
                var referenceOverflow = detectOverflow(state, {
                    elementContext: "reference"
                });
                var popperAltOverflow = detectOverflow(state, {
                    altBoundary: true
                });
                var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
                var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
                var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
                var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
                state.modifiersData[name] = {
                    referenceClippingOffsets,
                    popperEscapeOffsets,
                    isReferenceHidden,
                    hasPopperEscaped
                };
                state.attributes.popper = Object.assign({}, state.attributes.popper, {
                    "data-popper-reference-hidden": isReferenceHidden,
                    "data-popper-escaped": hasPopperEscaped
                });
            }
            const hide$1 = {
                name: "hide",
                enabled: true,
                phase: "main",
                requiresIfExists: [
                    "preventOverflow"
                ],
                fn: hide
            };
            function distanceAndSkiddingToXY(placement, rects, offset2) {
                var basePlacement = getBasePlacement(placement);
                var invertDistance = [
                    left,
                    top
                ].indexOf(basePlacement) >= 0 ? -1 : 1;
                var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
                    placement
                })) : offset2, skidding = _ref[0], distance = _ref[1];
                skidding = skidding || 0;
                distance = (distance || 0) * invertDistance;
                return [
                    left,
                    right
                ].indexOf(basePlacement) >= 0 ? {
                    x: distance,
                    y: skidding
                } : {
                    x: skidding,
                    y: distance
                };
            }
            function offset(_ref2) {
                var state = _ref2.state, options = _ref2.options, name = _ref2.name;
                var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [
                    0,
                    0
                ] : _options$offset;
                var data = placements.reduce(function(acc, placement) {
                    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
                    return acc;
                }, {});
                var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y = _data$state$placement.y;
                if (state.modifiersData.popperOffsets != null) {
                    state.modifiersData.popperOffsets.x += x2;
                    state.modifiersData.popperOffsets.y += y;
                }
                state.modifiersData[name] = data;
            }
            const offset$1 = {
                name: "offset",
                enabled: true,
                phase: "main",
                requires: [
                    "popperOffsets"
                ],
                fn: offset
            };
            function popperOffsets(_ref) {
                var state = _ref.state, name = _ref.name;
                state.modifiersData[name] = computeOffsets({
                    reference: state.rects.reference,
                    element: state.rects.popper,
                    placement: state.placement
                });
            }
            const popperOffsets$1 = {
                name: "popperOffsets",
                enabled: true,
                phase: "read",
                fn: popperOffsets,
                data: {}
            };
            function getAltAxis(axis) {
                return axis === "x" ? "y" : "x";
            }
            function preventOverflow(_ref) {
                var state = _ref.state, options = _ref.options, name = _ref.name;
                var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
                var overflow = detectOverflow(state, {
                    boundary,
                    rootBoundary,
                    padding,
                    altBoundary
                });
                var basePlacement = getBasePlacement(state.placement);
                var variation = getVariation(state.placement);
                var isBasePlacement = !variation;
                var mainAxis = getMainAxisFromPlacement(basePlacement);
                var altAxis = getAltAxis(mainAxis);
                var popperOffsets2 = state.modifiersData.popperOffsets;
                var referenceRect = state.rects.reference;
                var popperRect = state.rects.popper;
                var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
                    placement: state.placement
                })) : tetherOffset;
                var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
                    mainAxis: tetherOffsetValue,
                    altAxis: tetherOffsetValue
                } : Object.assign({
                    mainAxis: 0,
                    altAxis: 0
                }, tetherOffsetValue);
                var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
                var data = {
                    x: 0,
                    y: 0
                };
                if (!popperOffsets2) {
                    return;
                }
                if (checkMainAxis) {
                    var _offsetModifierState$;
                    var mainSide = mainAxis === "y" ? top : left;
                    var altSide = mainAxis === "y" ? bottom : right;
                    var len = mainAxis === "y" ? "height" : "width";
                    var offset2 = popperOffsets2[mainAxis];
                    var min$1 = offset2 + overflow[mainSide];
                    var max$1 = offset2 - overflow[altSide];
                    var additive = tether ? -popperRect[len] / 2 : 0;
                    var minLen = variation === start ? referenceRect[len] : popperRect[len];
                    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
                    var arrowElement = state.elements.arrow;
                    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                        width: 0,
                        height: 0
                    };
                    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
                    var arrowPaddingMin = arrowPaddingObject[mainSide];
                    var arrowPaddingMax = arrowPaddingObject[altSide];
                    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
                    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
                    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
                    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
                    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
                    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
                    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
                    var tetherMax = offset2 + maxOffset - offsetModifierValue;
                    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
                    popperOffsets2[mainAxis] = preventedOffset;
                    data[mainAxis] = preventedOffset - offset2;
                }
                if (checkAltAxis) {
                    var _offsetModifierState$2;
                    var _mainSide = mainAxis === "x" ? top : left;
                    var _altSide = mainAxis === "x" ? bottom : right;
                    var _offset = popperOffsets2[altAxis];
                    var _len = altAxis === "y" ? "height" : "width";
                    var _min = _offset + overflow[_mainSide];
                    var _max = _offset - overflow[_altSide];
                    var isOriginSide = [
                        top,
                        left
                    ].indexOf(basePlacement) !== -1;
                    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
                    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
                    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
                    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
                    popperOffsets2[altAxis] = _preventedOffset;
                    data[altAxis] = _preventedOffset - _offset;
                }
                state.modifiersData[name] = data;
            }
            const preventOverflow$1 = {
                name: "preventOverflow",
                enabled: true,
                phase: "main",
                fn: preventOverflow,
                requiresIfExists: [
                    "offset"
                ]
            };
            function getHTMLElementScroll(element) {
                return {
                    scrollLeft: element.scrollLeft,
                    scrollTop: element.scrollTop
                };
            }
            function getNodeScroll(node) {
                if (node === getWindow(node) || !isHTMLElement(node)) {
                    return getWindowScroll(node);
                } else {
                    return getHTMLElementScroll(node);
                }
            }
            function isElementScaled(element) {
                var rect = element.getBoundingClientRect();
                var scaleX = round(rect.width) / element.offsetWidth || 1;
                var scaleY = round(rect.height) / element.offsetHeight || 1;
                return scaleX !== 1 || scaleY !== 1;
            }
            function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
                if (isFixed === void 0) {
                    isFixed = false;
                }
                var isOffsetParentAnElement = isHTMLElement(offsetParent);
                var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
                var documentElement = getDocumentElement(offsetParent);
                var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
                var scroll = {
                    scrollLeft: 0,
                    scrollTop: 0
                };
                var offsets = {
                    x: 0,
                    y: 0
                };
                if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
                    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
                        scroll = getNodeScroll(offsetParent);
                    }
                    if (isHTMLElement(offsetParent)) {
                        offsets = getBoundingClientRect(offsetParent, true);
                        offsets.x += offsetParent.clientLeft;
                        offsets.y += offsetParent.clientTop;
                    } else if (documentElement) {
                        offsets.x = getWindowScrollBarX(documentElement);
                    }
                }
                return {
                    x: rect.left + scroll.scrollLeft - offsets.x,
                    y: rect.top + scroll.scrollTop - offsets.y,
                    width: rect.width,
                    height: rect.height
                };
            }
            function order(modifiers) {
                var map = new Map();
                var visited = new Set();
                var result = [];
                modifiers.forEach(function(modifier) {
                    map.set(modifier.name, modifier);
                });
                function sort(modifier) {
                    visited.add(modifier.name);
                    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
                    requires.forEach(function(dep) {
                        if (!visited.has(dep)) {
                            var depModifier = map.get(dep);
                            if (depModifier) {
                                sort(depModifier);
                            }
                        }
                    });
                    result.push(modifier);
                }
                modifiers.forEach(function(modifier) {
                    if (!visited.has(modifier.name)) {
                        sort(modifier);
                    }
                });
                return result;
            }
            function orderModifiers(modifiers) {
                var orderedModifiers = order(modifiers);
                return modifierPhases.reduce(function(acc, phase) {
                    return acc.concat(orderedModifiers.filter(function(modifier) {
                        return modifier.phase === phase;
                    }));
                }, []);
            }
            function debounce(fn) {
                var pending;
                return function() {
                    if (!pending) {
                        pending = new Promise(function(resolve2) {
                            Promise.resolve().then(function() {
                                pending = void 0;
                                resolve2(fn());
                            });
                        });
                    }
                    return pending;
                };
            }
            function mergeByName(modifiers) {
                var merged = modifiers.reduce(function(merged2, current) {
                    var existing = merged2[current.name];
                    merged2[current.name] = existing ? Object.assign({}, existing, current, {
                        options: Object.assign({}, existing.options, current.options),
                        data: Object.assign({}, existing.data, current.data)
                    }) : current;
                    return merged2;
                }, {});
                return Object.keys(merged).map(function(key) {
                    return merged[key];
                });
            }
            var DEFAULT_OPTIONS = {
                placement: "bottom",
                modifiers: [],
                strategy: "absolute"
            };
            function areValidElements() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return !args.some(function(element) {
                    return !(element && typeof element.getBoundingClientRect === "function");
                });
            }
            function popperGenerator(generatorOptions) {
                if (generatorOptions === void 0) {
                    generatorOptions = {};
                }
                var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
                return function createPopper2(reference2, popper2, options) {
                    if (options === void 0) {
                        options = defaultOptions;
                    }
                    var state = {
                        placement: "bottom",
                        orderedModifiers: [],
                        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                        modifiersData: {},
                        elements: {
                            reference: reference2,
                            popper: popper2
                        },
                        attributes: {},
                        styles: {}
                    };
                    var effectCleanupFns = [];
                    var isDestroyed = false;
                    var instance = {
                        state,
                        setOptions: function setOptions(setOptionsAction) {
                            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                            cleanupModifierEffects();
                            state.options = Object.assign({}, defaultOptions, state.options, options2);
                            state.scrollParents = {
                                reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                                popper: listScrollParents(popper2)
                            };
                            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
                            state.orderedModifiers = orderedModifiers.filter(function(m) {
                                return m.enabled;
                            });
                            runModifierEffects();
                            return instance.update();
                        },
                        forceUpdate: function forceUpdate() {
                            if (isDestroyed) {
                                return;
                            }
                            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
                            if (!areValidElements(reference3, popper3)) {
                                return;
                            }
                            state.rects = {
                                reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
                                popper: getLayoutRect(popper3)
                            };
                            state.reset = false;
                            state.placement = state.options.placement;
                            state.orderedModifiers.forEach(function(modifier) {
                                return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                            });
                            for(var index = 0; index < state.orderedModifiers.length; index++){
                                if (state.reset === true) {
                                    state.reset = false;
                                    index = -1;
                                    continue;
                                }
                                var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                                if (typeof fn === "function") {
                                    state = fn({
                                        state,
                                        options: _options,
                                        name,
                                        instance
                                    }) || state;
                                }
                            }
                        },
                        update: debounce(function() {
                            return new Promise(function(resolve2) {
                                instance.forceUpdate();
                                resolve2(state);
                            });
                        }),
                        destroy: function destroy() {
                            cleanupModifierEffects();
                            isDestroyed = true;
                        }
                    };
                    if (!areValidElements(reference2, popper2)) {
                        return instance;
                    }
                    instance.setOptions(options).then(function(state2) {
                        if (!isDestroyed && options.onFirstUpdate) {
                            options.onFirstUpdate(state2);
                        }
                    });
                    function runModifierEffects() {
                        state.orderedModifiers.forEach(function(_ref) {
                            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
                            if (typeof effect2 === "function") {
                                var cleanupFn = effect2({
                                    state,
                                    name,
                                    instance,
                                    options: options2
                                });
                                var noopFn = function noopFn2() {};
                                effectCleanupFns.push(cleanupFn || noopFn);
                            }
                        });
                    }
                    function cleanupModifierEffects() {
                        effectCleanupFns.forEach(function(fn) {
                            return fn();
                        });
                        effectCleanupFns = [];
                    }
                    return instance;
                };
            }
            var createPopper$2 = popperGenerator();
            var defaultModifiers$1 = [
                eventListeners,
                popperOffsets$1,
                computeStyles$1,
                applyStyles$1
            ];
            var createPopper$1 = popperGenerator({
                defaultModifiers: defaultModifiers$1
            });
            var defaultModifiers = [
                eventListeners,
                popperOffsets$1,
                computeStyles$1,
                applyStyles$1,
                offset$1,
                flip$1,
                preventOverflow$1,
                arrow$1,
                hide$1
            ];
            var createPopper = popperGenerator({
                defaultModifiers
            });
            const lib = Object.freeze(Object.defineProperty({
                __proto__: null,
                afterMain,
                afterRead,
                afterWrite,
                applyStyles: applyStyles$1,
                arrow: arrow$1,
                auto,
                basePlacements,
                beforeMain,
                beforeRead,
                beforeWrite,
                bottom,
                clippingParents,
                computeStyles: computeStyles$1,
                createPopper,
                createPopperBase: createPopper$2,
                createPopperLite: createPopper$1,
                detectOverflow,
                end,
                eventListeners,
                flip: flip$1,
                hide: hide$1,
                left,
                main,
                modifierPhases,
                offset: offset$1,
                placements,
                popper,
                popperGenerator,
                popperOffsets: popperOffsets$1,
                preventOverflow: preventOverflow$1,
                read,
                reference,
                right,
                start,
                top,
                variationPlacements,
                viewport,
                write
            }, Symbol.toStringTag, {
                value: "Module"
            }));
            const require$$0 = getAugmentedNamespace(lib);
            var bootstrap = bootstrap$1.exports;
            var hasRequiredBootstrap;
            function requireBootstrap() {
                if (hasRequiredBootstrap) return bootstrap$1.exports;
                hasRequiredBootstrap = 1;
                (function(module2, exports2) {
                    (function(global2, factory2) {
                        module2.exports = factory2(require$$0);
                    })(bootstrap, (function(Popper) {
                        function _interopNamespaceDefault(e) {
                            const n = Object.create(null, {
                                [Symbol.toStringTag]: {
                                    value: "Module"
                                }
                            });
                            if (e) {
                                for(const k in e){
                                    if (k !== "default") {
                                        const d = Object.getOwnPropertyDescriptor(e, k);
                                        Object.defineProperty(n, k, d.get ? d : {
                                            enumerable: true,
                                            get: ()=>e[k]
                                        });
                                    }
                                }
                            }
                            n.default = e;
                            return Object.freeze(n);
                        }
                        const Popper__namespace = _interopNamespaceDefault(Popper);
                        const elementMap = new Map();
                        const Data = {
                            set (element, key, instance) {
                                if (!elementMap.has(element)) {
                                    elementMap.set(element, new Map());
                                }
                                const instanceMap = elementMap.get(element);
                                if (!instanceMap.has(key) && instanceMap.size !== 0) {
                                    console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
                                    return;
                                }
                                instanceMap.set(key, instance);
                            },
                            get (element, key) {
                                if (elementMap.has(element)) {
                                    return elementMap.get(element).get(key) || null;
                                }
                                return null;
                            },
                            remove (element, key) {
                                if (!elementMap.has(element)) {
                                    return;
                                }
                                const instanceMap = elementMap.get(element);
                                instanceMap.delete(key);
                                if (instanceMap.size === 0) {
                                    elementMap.delete(element);
                                }
                            }
                        };
                        const MAX_UID = 1e6;
                        const MILLISECONDS_MULTIPLIER = 1e3;
                        const TRANSITION_END = "transitionend";
                        const parseSelector = (selector)=>{
                            if (selector && window.CSS && window.CSS.escape) {
                                selector = selector.replace(/#([^\s"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);
                            }
                            return selector;
                        };
                        const toType = (object)=>{
                            if (object === null || object === void 0) {
                                return `${object}`;
                            }
                            return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
                        };
                        const getUID = (prefix)=>{
                            do {
                                prefix += Math.floor(Math.random() * MAX_UID);
                            }while (document.getElementById(prefix))
                            return prefix;
                        };
                        const getTransitionDurationFromElement = (element)=>{
                            if (!element) {
                                return 0;
                            }
                            let { transitionDuration, transitionDelay } = window.getComputedStyle(element);
                            const floatTransitionDuration = Number.parseFloat(transitionDuration);
                            const floatTransitionDelay = Number.parseFloat(transitionDelay);
                            if (!floatTransitionDuration && !floatTransitionDelay) {
                                return 0;
                            }
                            transitionDuration = transitionDuration.split(",")[0];
                            transitionDelay = transitionDelay.split(",")[0];
                            return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
                        };
                        const triggerTransitionEnd = (element)=>{
                            element.dispatchEvent(new Event(TRANSITION_END));
                        };
                        const isElement2 = (object)=>{
                            if (!object || typeof object !== "object") {
                                return false;
                            }
                            if (typeof object.jquery !== "undefined") {
                                object = object[0];
                            }
                            return typeof object.nodeType !== "undefined";
                        };
                        const getElement = (object)=>{
                            if (isElement2(object)) {
                                return object.jquery ? object[0] : object;
                            }
                            if (typeof object === "string" && object.length > 0) {
                                return document.querySelector(parseSelector(object));
                            }
                            return null;
                        };
                        const isVisible = (element)=>{
                            if (!isElement2(element) || element.getClientRects().length === 0) {
                                return false;
                            }
                            const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
                            const closedDetails = element.closest("details:not([open])");
                            if (!closedDetails) {
                                return elementIsVisible;
                            }
                            if (closedDetails !== element) {
                                const summary = element.closest("summary");
                                if (summary && summary.parentNode !== closedDetails) {
                                    return false;
                                }
                                if (summary === null) {
                                    return false;
                                }
                            }
                            return elementIsVisible;
                        };
                        const isDisabled = (element)=>{
                            if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                                return true;
                            }
                            if (element.classList.contains("disabled")) {
                                return true;
                            }
                            if (typeof element.disabled !== "undefined") {
                                return element.disabled;
                            }
                            return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
                        };
                        const findShadowRoot = (element)=>{
                            if (!document.documentElement.attachShadow) {
                                return null;
                            }
                            if (typeof element.getRootNode === "function") {
                                const root = element.getRootNode();
                                return root instanceof ShadowRoot ? root : null;
                            }
                            if (element instanceof ShadowRoot) {
                                return element;
                            }
                            if (!element.parentNode) {
                                return null;
                            }
                            return findShadowRoot(element.parentNode);
                        };
                        const noop2 = ()=>{};
                        const reflow = (element)=>{
                            element.offsetHeight;
                        };
                        const getjQuery = ()=>{
                            if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
                                return window.jQuery;
                            }
                            return null;
                        };
                        const DOMContentLoadedCallbacks = [];
                        const onDOMContentLoaded = (callback)=>{
                            if (document.readyState === "loading") {
                                if (!DOMContentLoadedCallbacks.length) {
                                    document.addEventListener("DOMContentLoaded", ()=>{
                                        for (const callback2 of DOMContentLoadedCallbacks){
                                            callback2();
                                        }
                                    });
                                }
                                DOMContentLoadedCallbacks.push(callback);
                            } else {
                                callback();
                            }
                        };
                        const isRTL = ()=>document.documentElement.dir === "rtl";
                        const defineJQueryPlugin = (plugin)=>{
                            onDOMContentLoaded(()=>{
                                const $ = getjQuery();
                                if ($) {
                                    const name = plugin.NAME;
                                    const JQUERY_NO_CONFLICT = $.fn[name];
                                    $.fn[name] = plugin.jQueryInterface;
                                    $.fn[name].Constructor = plugin;
                                    $.fn[name].noConflict = ()=>{
                                        $.fn[name] = JQUERY_NO_CONFLICT;
                                        return plugin.jQueryInterface;
                                    };
                                }
                            });
                        };
                        const execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{
                            return typeof possibleCallback === "function" ? possibleCallback.call(...args) : defaultValue;
                        };
                        const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{
                            if (!waitForTransition) {
                                execute(callback);
                                return;
                            }
                            const durationPadding = 5;
                            const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
                            let called = false;
                            const handler = ({ target })=>{
                                if (target !== transitionElement) {
                                    return;
                                }
                                called = true;
                                transitionElement.removeEventListener(TRANSITION_END, handler);
                                execute(callback);
                            };
                            transitionElement.addEventListener(TRANSITION_END, handler);
                            setTimeout(()=>{
                                if (!called) {
                                    triggerTransitionEnd(transitionElement);
                                }
                            }, emulatedDuration);
                        };
                        const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{
                            const listLength = list.length;
                            let index = list.indexOf(activeElement);
                            if (index === -1) {
                                return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
                            }
                            index += shouldGetNext ? 1 : -1;
                            if (isCycleAllowed) {
                                index = (index + listLength) % listLength;
                            }
                            return list[Math.max(0, Math.min(index, listLength - 1))];
                        };
                        const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
                        const stripNameRegex = /\..*/;
                        const stripUidRegex = /::\d+$/;
                        const eventRegistry = {};
                        let uidEvent = 1;
                        const customEvents = {
                            mouseenter: "mouseover",
                            mouseleave: "mouseout"
                        };
                        const nativeEvents = new Set([
                            "click",
                            "dblclick",
                            "mouseup",
                            "mousedown",
                            "contextmenu",
                            "mousewheel",
                            "DOMMouseScroll",
                            "mouseover",
                            "mouseout",
                            "mousemove",
                            "selectstart",
                            "selectend",
                            "keydown",
                            "keypress",
                            "keyup",
                            "orientationchange",
                            "touchstart",
                            "touchmove",
                            "touchend",
                            "touchcancel",
                            "pointerdown",
                            "pointermove",
                            "pointerup",
                            "pointerleave",
                            "pointercancel",
                            "gesturestart",
                            "gesturechange",
                            "gestureend",
                            "focus",
                            "blur",
                            "change",
                            "reset",
                            "select",
                            "submit",
                            "focusin",
                            "focusout",
                            "load",
                            "unload",
                            "beforeunload",
                            "resize",
                            "move",
                            "DOMContentLoaded",
                            "readystatechange",
                            "error",
                            "abort",
                            "scroll"
                        ]);
                        function makeEventUid(element, uid2) {
                            return uid2 && `${uid2}::${uidEvent++}` || element.uidEvent || uidEvent++;
                        }
                        function getElementEvents(element) {
                            const uid2 = makeEventUid(element);
                            element.uidEvent = uid2;
                            eventRegistry[uid2] = eventRegistry[uid2] || {};
                            return eventRegistry[uid2];
                        }
                        function bootstrapHandler(element, fn) {
                            return function handler(event) {
                                hydrateObj(event, {
                                    delegateTarget: element
                                });
                                if (handler.oneOff) {
                                    EventHandler.off(element, event.type, fn);
                                }
                                return fn.apply(element, [
                                    event
                                ]);
                            };
                        }
                        function bootstrapDelegationHandler(element, selector, fn) {
                            return function handler(event) {
                                const domElements = element.querySelectorAll(selector);
                                for(let { target } = event; target && target !== this; target = target.parentNode){
                                    for (const domElement of domElements){
                                        if (domElement !== target) {
                                            continue;
                                        }
                                        hydrateObj(event, {
                                            delegateTarget: target
                                        });
                                        if (handler.oneOff) {
                                            EventHandler.off(element, event.type, selector, fn);
                                        }
                                        return fn.apply(target, [
                                            event
                                        ]);
                                    }
                                }
                            };
                        }
                        function findHandler(events, callable, delegationSelector = null) {
                            return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);
                        }
                        function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
                            const isDelegated = typeof handler === "string";
                            const callable = isDelegated ? delegationFunction : handler || delegationFunction;
                            let typeEvent = getTypeEvent(originalTypeEvent);
                            if (!nativeEvents.has(typeEvent)) {
                                typeEvent = originalTypeEvent;
                            }
                            return [
                                isDelegated,
                                callable,
                                typeEvent
                            ];
                        }
                        function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
                            if (typeof originalTypeEvent !== "string" || !element) {
                                return;
                            }
                            let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
                            if (originalTypeEvent in customEvents) {
                                const wrapFunction = (fn2)=>{
                                    return function(event) {
                                        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
                                            return fn2.call(this, event);
                                        }
                                    };
                                };
                                callable = wrapFunction(callable);
                            }
                            const events = getElementEvents(element);
                            const handlers = events[typeEvent] || (events[typeEvent] = {});
                            const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
                            if (previousFunction) {
                                previousFunction.oneOff = previousFunction.oneOff && oneOff;
                                return;
                            }
                            const uid2 = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
                            const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
                            fn.delegationSelector = isDelegated ? handler : null;
                            fn.callable = callable;
                            fn.oneOff = oneOff;
                            fn.uidEvent = uid2;
                            handlers[uid2] = fn;
                            element.addEventListener(typeEvent, fn, isDelegated);
                        }
                        function removeHandler(element, events, typeEvent, handler, delegationSelector) {
                            const fn = findHandler(events[typeEvent], handler, delegationSelector);
                            if (!fn) {
                                return;
                            }
                            element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
                            delete events[typeEvent][fn.uidEvent];
                        }
                        function removeNamespacedHandlers(element, events, typeEvent, namespace2) {
                            const storeElementEvent = events[typeEvent] || {};
                            for (const [handlerKey, event] of Object.entries(storeElementEvent)){
                                if (handlerKey.includes(namespace2)) {
                                    removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
                                }
                            }
                        }
                        function getTypeEvent(event) {
                            event = event.replace(stripNameRegex, "");
                            return customEvents[event] || event;
                        }
                        const EventHandler = {
                            on (element, event, handler, delegationFunction) {
                                addHandler(element, event, handler, delegationFunction, false);
                            },
                            one (element, event, handler, delegationFunction) {
                                addHandler(element, event, handler, delegationFunction, true);
                            },
                            off (element, originalTypeEvent, handler, delegationFunction) {
                                if (typeof originalTypeEvent !== "string" || !element) {
                                    return;
                                }
                                const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
                                const inNamespace = typeEvent !== originalTypeEvent;
                                const events = getElementEvents(element);
                                const storeElementEvent = events[typeEvent] || {};
                                const isNamespace = originalTypeEvent.startsWith(".");
                                if (typeof callable !== "undefined") {
                                    if (!Object.keys(storeElementEvent).length) {
                                        return;
                                    }
                                    removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
                                    return;
                                }
                                if (isNamespace) {
                                    for (const elementEvent of Object.keys(events)){
                                        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
                                    }
                                }
                                for (const [keyHandlers, event] of Object.entries(storeElementEvent)){
                                    const handlerKey = keyHandlers.replace(stripUidRegex, "");
                                    if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
                                        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
                                    }
                                }
                            },
                            trigger (element, event, args) {
                                if (typeof event !== "string" || !element) {
                                    return null;
                                }
                                const $ = getjQuery();
                                const typeEvent = getTypeEvent(event);
                                const inNamespace = event !== typeEvent;
                                let jQueryEvent = null;
                                let bubbles = true;
                                let nativeDispatch = true;
                                let defaultPrevented = false;
                                if (inNamespace && $) {
                                    jQueryEvent = $.Event(event, args);
                                    $(element).trigger(jQueryEvent);
                                    bubbles = !jQueryEvent.isPropagationStopped();
                                    nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
                                    defaultPrevented = jQueryEvent.isDefaultPrevented();
                                }
                                const evt = hydrateObj(new Event(event, {
                                    bubbles,
                                    cancelable: true
                                }), args);
                                if (defaultPrevented) {
                                    evt.preventDefault();
                                }
                                if (nativeDispatch) {
                                    element.dispatchEvent(evt);
                                }
                                if (evt.defaultPrevented && jQueryEvent) {
                                    jQueryEvent.preventDefault();
                                }
                                return evt;
                            }
                        };
                        function hydrateObj(obj, meta = {}) {
                            for (const [key, value] of Object.entries(meta)){
                                try {
                                    obj[key] = value;
                                } catch (_unused) {
                                    Object.defineProperty(obj, key, {
                                        configurable: true,
                                        get () {
                                            return value;
                                        }
                                    });
                                }
                            }
                            return obj;
                        }
                        function normalizeData(value) {
                            if (value === "true") {
                                return true;
                            }
                            if (value === "false") {
                                return false;
                            }
                            if (value === Number(value).toString()) {
                                return Number(value);
                            }
                            if (value === "" || value === "null") {
                                return null;
                            }
                            if (typeof value !== "string") {
                                return value;
                            }
                            try {
                                return JSON.parse(decodeURIComponent(value));
                            } catch (_unused) {
                                return value;
                            }
                        }
                        function normalizeDataKey(key) {
                            return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);
                        }
                        const Manipulator = {
                            setDataAttribute (element, key, value) {
                                element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
                            },
                            removeDataAttribute (element, key) {
                                element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
                            },
                            getDataAttributes (element) {
                                if (!element) {
                                    return {};
                                }
                                const attributes = {};
                                const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith("bs") && !key.startsWith("bsConfig"));
                                for (const key of bsKeys){
                                    let pureKey = key.replace(/^bs/, "");
                                    pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);
                                    attributes[pureKey] = normalizeData(element.dataset[key]);
                                }
                                return attributes;
                            },
                            getDataAttribute (element, key) {
                                return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
                            }
                        };
                        class Config {
                            static get Default() {
                                return {};
                            }
                            static get DefaultType() {
                                return {};
                            }
                            static get NAME() {
                                throw new Error('You have to implement the static method "NAME", for each component!');
                            }
                            _getConfig(config2) {
                                config2 = this._mergeConfigObj(config2);
                                config2 = this._configAfterMerge(config2);
                                this._typeCheckConfig(config2);
                                return config2;
                            }
                            _configAfterMerge(config2) {
                                return config2;
                            }
                            _mergeConfigObj(config2, element) {
                                const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
                                return {
                                    ...this.constructor.Default,
                                    ...typeof jsonConfig === "object" ? jsonConfig : {},
                                    ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
                                    ...typeof config2 === "object" ? config2 : {}
                                };
                            }
                            _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
                                for (const [property, expectedTypes] of Object.entries(configTypes)){
                                    const value = config2[property];
                                    const valueType = isElement2(value) ? "element" : toType(value);
                                    if (!new RegExp(expectedTypes).test(valueType)) {
                                        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
                                    }
                                }
                            }
                        }
                        const VERSION2 = "5.3.8";
                        class BaseComponent extends Config {
                            constructor(element, config2){
                                super();
                                element = getElement(element);
                                if (!element) {
                                    return;
                                }
                                this._element = element;
                                this._config = this._getConfig(config2);
                                Data.set(this._element, this.constructor.DATA_KEY, this);
                            }
                            dispose() {
                                Data.remove(this._element, this.constructor.DATA_KEY);
                                EventHandler.off(this._element, this.constructor.EVENT_KEY);
                                for (const propertyName of Object.getOwnPropertyNames(this)){
                                    this[propertyName] = null;
                                }
                            }
                            _queueCallback(callback, element, isAnimated = true) {
                                executeAfterTransition(callback, element, isAnimated);
                            }
                            _getConfig(config2) {
                                config2 = this._mergeConfigObj(config2, this._element);
                                config2 = this._configAfterMerge(config2);
                                this._typeCheckConfig(config2);
                                return config2;
                            }
                            static getInstance(element) {
                                return Data.get(getElement(element), this.DATA_KEY);
                            }
                            static getOrCreateInstance(element, config2 = {}) {
                                return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
                            }
                            static get VERSION() {
                                return VERSION2;
                            }
                            static get DATA_KEY() {
                                return `bs.${this.NAME}`;
                            }
                            static get EVENT_KEY() {
                                return `.${this.DATA_KEY}`;
                            }
                            static eventName(name) {
                                return `${name}${this.EVENT_KEY}`;
                            }
                        }
                        const getSelector = (element)=>{
                            let selector = element.getAttribute("data-bs-target");
                            if (!selector || selector === "#") {
                                let hrefAttribute = element.getAttribute("href");
                                if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
                                    return null;
                                }
                                if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
                                    hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
                                }
                                selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
                            }
                            return selector ? selector.split(",").map((sel)=>parseSelector(sel)).join(",") : null;
                        };
                        const SelectorEngine = {
                            find (selector, element = document.documentElement) {
                                return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
                            },
                            findOne (selector, element = document.documentElement) {
                                return Element.prototype.querySelector.call(element, selector);
                            },
                            children (element, selector) {
                                return [].concat(...element.children).filter((child)=>child.matches(selector));
                            },
                            parents (element, selector) {
                                const parents = [];
                                let ancestor = element.parentNode.closest(selector);
                                while(ancestor){
                                    parents.push(ancestor);
                                    ancestor = ancestor.parentNode.closest(selector);
                                }
                                return parents;
                            },
                            prev (element, selector) {
                                let previous = element.previousElementSibling;
                                while(previous){
                                    if (previous.matches(selector)) {
                                        return [
                                            previous
                                        ];
                                    }
                                    previous = previous.previousElementSibling;
                                }
                                return [];
                            },
                            next (element, selector) {
                                let next = element.nextElementSibling;
                                while(next){
                                    if (next.matches(selector)) {
                                        return [
                                            next
                                        ];
                                    }
                                    next = next.nextElementSibling;
                                }
                                return [];
                            },
                            focusableChildren (element) {
                                const focusables = [
                                    "a",
                                    "button",
                                    "input",
                                    "textarea",
                                    "select",
                                    "details",
                                    "[tabindex]",
                                    '[contenteditable="true"]'
                                ].map((selector)=>`${selector}:not([tabindex^="-"])`).join(",");
                                return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));
                            },
                            getSelectorFromElement (element) {
                                const selector = getSelector(element);
                                if (selector) {
                                    return SelectorEngine.findOne(selector) ? selector : null;
                                }
                                return null;
                            },
                            getElementFromSelector (element) {
                                const selector = getSelector(element);
                                return selector ? SelectorEngine.findOne(selector) : null;
                            },
                            getMultipleElementsFromSelector (element) {
                                const selector = getSelector(element);
                                return selector ? SelectorEngine.find(selector) : [];
                            }
                        };
                        const enableDismissTrigger = (component, method = "hide")=>{
                            const clickEvent = `click.dismiss${component.EVENT_KEY}`;
                            const name = component.NAME;
                            EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
                                if ([
                                    "A",
                                    "AREA"
                                ].includes(this.tagName)) {
                                    event.preventDefault();
                                }
                                if (isDisabled(this)) {
                                    return;
                                }
                                const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
                                const instance = component.getOrCreateInstance(target);
                                instance[method]();
                            });
                        };
                        const NAME$f = "alert";
                        const DATA_KEY$a = "bs.alert";
                        const EVENT_KEY$b = `.${DATA_KEY$a}`;
                        const EVENT_CLOSE = `close${EVENT_KEY$b}`;
                        const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
                        const CLASS_NAME_FADE$5 = "fade";
                        const CLASS_NAME_SHOW$8 = "show";
                        class Alert extends BaseComponent {
                            static get NAME() {
                                return NAME$f;
                            }
                            close() {
                                const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
                                if (closeEvent.defaultPrevented) {
                                    return;
                                }
                                this._element.classList.remove(CLASS_NAME_SHOW$8);
                                const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
                                this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);
                            }
                            _destroyElement() {
                                this._element.remove();
                                EventHandler.trigger(this._element, EVENT_CLOSED);
                                this.dispose();
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Alert.getOrCreateInstance(this);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2](this);
                                });
                            }
                        }
                        enableDismissTrigger(Alert, "close");
                        defineJQueryPlugin(Alert);
                        const NAME$e = "button";
                        const DATA_KEY$9 = "bs.button";
                        const EVENT_KEY$a = `.${DATA_KEY$9}`;
                        const DATA_API_KEY$6 = ".data-api";
                        const CLASS_NAME_ACTIVE$3 = "active";
                        const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
                        const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
                        class Button extends BaseComponent {
                            static get NAME() {
                                return NAME$e;
                            }
                            toggle() {
                                this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Button.getOrCreateInstance(this);
                                    if (config2 === "toggle") {
                                        data[config2]();
                                    }
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{
                            event.preventDefault();
                            const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
                            const data = Button.getOrCreateInstance(button);
                            data.toggle();
                        });
                        defineJQueryPlugin(Button);
                        const NAME$d = "swipe";
                        const EVENT_KEY$9 = ".bs.swipe";
                        const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
                        const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
                        const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
                        const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
                        const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
                        const POINTER_TYPE_TOUCH = "touch";
                        const POINTER_TYPE_PEN = "pen";
                        const CLASS_NAME_POINTER_EVENT = "pointer-event";
                        const SWIPE_THRESHOLD = 40;
                        const Default$c = {
                            endCallback: null,
                            leftCallback: null,
                            rightCallback: null
                        };
                        const DefaultType$c = {
                            endCallback: "(function|null)",
                            leftCallback: "(function|null)",
                            rightCallback: "(function|null)"
                        };
                        class Swipe extends Config {
                            constructor(element, config2){
                                super();
                                this._element = element;
                                if (!element || !Swipe.isSupported()) {
                                    return;
                                }
                                this._config = this._getConfig(config2);
                                this._deltaX = 0;
                                this._supportPointerEvents = Boolean(window.PointerEvent);
                                this._initEvents();
                            }
                            static get Default() {
                                return Default$c;
                            }
                            static get DefaultType() {
                                return DefaultType$c;
                            }
                            static get NAME() {
                                return NAME$d;
                            }
                            dispose() {
                                EventHandler.off(this._element, EVENT_KEY$9);
                            }
                            _start(event) {
                                if (!this._supportPointerEvents) {
                                    this._deltaX = event.touches[0].clientX;
                                    return;
                                }
                                if (this._eventIsPointerPenTouch(event)) {
                                    this._deltaX = event.clientX;
                                }
                            }
                            _end(event) {
                                if (this._eventIsPointerPenTouch(event)) {
                                    this._deltaX = event.clientX - this._deltaX;
                                }
                                this._handleSwipe();
                                execute(this._config.endCallback);
                            }
                            _move(event) {
                                this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
                            }
                            _handleSwipe() {
                                const absDeltaX = Math.abs(this._deltaX);
                                if (absDeltaX <= SWIPE_THRESHOLD) {
                                    return;
                                }
                                const direction = absDeltaX / this._deltaX;
                                this._deltaX = 0;
                                if (!direction) {
                                    return;
                                }
                                execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
                            }
                            _initEvents() {
                                if (this._supportPointerEvents) {
                                    EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));
                                    EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));
                                    this._element.classList.add(CLASS_NAME_POINTER_EVENT);
                                } else {
                                    EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));
                                    EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));
                                    EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));
                                }
                            }
                            _eventIsPointerPenTouch(event) {
                                return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
                            }
                            static isSupported() {
                                return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
                            }
                        }
                        const NAME$c = "carousel";
                        const DATA_KEY$8 = "bs.carousel";
                        const EVENT_KEY$8 = `.${DATA_KEY$8}`;
                        const DATA_API_KEY$5 = ".data-api";
                        const ARROW_LEFT_KEY$1 = "ArrowLeft";
                        const ARROW_RIGHT_KEY$1 = "ArrowRight";
                        const TOUCHEVENT_COMPAT_WAIT = 500;
                        const ORDER_NEXT = "next";
                        const ORDER_PREV = "prev";
                        const DIRECTION_LEFT = "left";
                        const DIRECTION_RIGHT = "right";
                        const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
                        const EVENT_SLID = `slid${EVENT_KEY$8}`;
                        const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
                        const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
                        const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
                        const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
                        const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
                        const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
                        const CLASS_NAME_CAROUSEL = "carousel";
                        const CLASS_NAME_ACTIVE$2 = "active";
                        const CLASS_NAME_SLIDE = "slide";
                        const CLASS_NAME_END = "carousel-item-end";
                        const CLASS_NAME_START = "carousel-item-start";
                        const CLASS_NAME_NEXT = "carousel-item-next";
                        const CLASS_NAME_PREV = "carousel-item-prev";
                        const SELECTOR_ACTIVE = ".active";
                        const SELECTOR_ITEM = ".carousel-item";
                        const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
                        const SELECTOR_ITEM_IMG = ".carousel-item img";
                        const SELECTOR_INDICATORS = ".carousel-indicators";
                        const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
                        const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
                        const KEY_TO_DIRECTION = {
                            [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
                            [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
                        };
                        const Default$b = {
                            interval: 5e3,
                            keyboard: true,
                            pause: "hover",
                            ride: false,
                            touch: true,
                            wrap: true
                        };
                        const DefaultType$b = {
                            interval: "(number|boolean)",
                            keyboard: "boolean",
                            pause: "(string|boolean)",
                            ride: "(boolean|string)",
                            touch: "boolean",
                            wrap: "boolean"
                        };
                        class Carousel extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._interval = null;
                                this._activeElement = null;
                                this._isSliding = false;
                                this.touchTimeout = null;
                                this._swipeHelper = null;
                                this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
                                this._addEventListeners();
                                if (this._config.ride === CLASS_NAME_CAROUSEL) {
                                    this.cycle();
                                }
                            }
                            static get Default() {
                                return Default$b;
                            }
                            static get DefaultType() {
                                return DefaultType$b;
                            }
                            static get NAME() {
                                return NAME$c;
                            }
                            next() {
                                this._slide(ORDER_NEXT);
                            }
                            nextWhenVisible() {
                                if (!document.hidden && isVisible(this._element)) {
                                    this.next();
                                }
                            }
                            prev() {
                                this._slide(ORDER_PREV);
                            }
                            pause() {
                                if (this._isSliding) {
                                    triggerTransitionEnd(this._element);
                                }
                                this._clearInterval();
                            }
                            cycle() {
                                this._clearInterval();
                                this._updateInterval();
                                this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);
                            }
                            _maybeEnableCycle() {
                                if (!this._config.ride) {
                                    return;
                                }
                                if (this._isSliding) {
                                    EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());
                                    return;
                                }
                                this.cycle();
                            }
                            to(index) {
                                const items = this._getItems();
                                if (index > items.length - 1 || index < 0) {
                                    return;
                                }
                                if (this._isSliding) {
                                    EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));
                                    return;
                                }
                                const activeIndex = this._getItemIndex(this._getActive());
                                if (activeIndex === index) {
                                    return;
                                }
                                const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
                                this._slide(order2, items[index]);
                            }
                            dispose() {
                                if (this._swipeHelper) {
                                    this._swipeHelper.dispose();
                                }
                                super.dispose();
                            }
                            _configAfterMerge(config2) {
                                config2.defaultInterval = config2.interval;
                                return config2;
                            }
                            _addEventListeners() {
                                if (this._config.keyboard) {
                                    EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));
                                }
                                if (this._config.pause === "hover") {
                                    EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());
                                    EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());
                                }
                                if (this._config.touch && Swipe.isSupported()) {
                                    this._addTouchEventListeners();
                                }
                            }
                            _addTouchEventListeners() {
                                for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)){
                                    EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());
                                }
                                const endCallBack = ()=>{
                                    if (this._config.pause !== "hover") {
                                        return;
                                    }
                                    this.pause();
                                    if (this.touchTimeout) {
                                        clearTimeout(this.touchTimeout);
                                    }
                                    this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
                                };
                                const swipeConfig = {
                                    leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),
                                    rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),
                                    endCallback: endCallBack
                                };
                                this._swipeHelper = new Swipe(this._element, swipeConfig);
                            }
                            _keydown(event) {
                                if (/input|textarea/i.test(event.target.tagName)) {
                                    return;
                                }
                                const direction = KEY_TO_DIRECTION[event.key];
                                if (direction) {
                                    event.preventDefault();
                                    this._slide(this._directionToOrder(direction));
                                }
                            }
                            _getItemIndex(element) {
                                return this._getItems().indexOf(element);
                            }
                            _setActiveIndicatorElement(index) {
                                if (!this._indicatorsElement) {
                                    return;
                                }
                                const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
                                activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
                                activeIndicator.removeAttribute("aria-current");
                                const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
                                if (newActiveIndicator) {
                                    newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
                                    newActiveIndicator.setAttribute("aria-current", "true");
                                }
                            }
                            _updateInterval() {
                                const element = this._activeElement || this._getActive();
                                if (!element) {
                                    return;
                                }
                                const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
                                this._config.interval = elementInterval || this._config.defaultInterval;
                            }
                            _slide(order2, element = null) {
                                if (this._isSliding) {
                                    return;
                                }
                                const activeElement = this._getActive();
                                const isNext = order2 === ORDER_NEXT;
                                const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
                                if (nextElement === activeElement) {
                                    return;
                                }
                                const nextElementIndex = this._getItemIndex(nextElement);
                                const triggerEvent2 = (eventName)=>{
                                    return EventHandler.trigger(this._element, eventName, {
                                        relatedTarget: nextElement,
                                        direction: this._orderToDirection(order2),
                                        from: this._getItemIndex(activeElement),
                                        to: nextElementIndex
                                    });
                                };
                                const slideEvent = triggerEvent2(EVENT_SLIDE);
                                if (slideEvent.defaultPrevented) {
                                    return;
                                }
                                if (!activeElement || !nextElement) {
                                    return;
                                }
                                const isCycling = Boolean(this._interval);
                                this.pause();
                                this._isSliding = true;
                                this._setActiveIndicatorElement(nextElementIndex);
                                this._activeElement = nextElement;
                                const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
                                const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
                                nextElement.classList.add(orderClassName);
                                reflow(nextElement);
                                activeElement.classList.add(directionalClassName);
                                nextElement.classList.add(directionalClassName);
                                const completeCallBack = ()=>{
                                    nextElement.classList.remove(directionalClassName, orderClassName);
                                    nextElement.classList.add(CLASS_NAME_ACTIVE$2);
                                    activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
                                    this._isSliding = false;
                                    triggerEvent2(EVENT_SLID);
                                };
                                this._queueCallback(completeCallBack, activeElement, this._isAnimated());
                                if (isCycling) {
                                    this.cycle();
                                }
                            }
                            _isAnimated() {
                                return this._element.classList.contains(CLASS_NAME_SLIDE);
                            }
                            _getActive() {
                                return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
                            }
                            _getItems() {
                                return SelectorEngine.find(SELECTOR_ITEM, this._element);
                            }
                            _clearInterval() {
                                if (this._interval) {
                                    clearInterval(this._interval);
                                    this._interval = null;
                                }
                            }
                            _directionToOrder(direction) {
                                if (isRTL()) {
                                    return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
                                }
                                return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
                            }
                            _orderToDirection(order2) {
                                if (isRTL()) {
                                    return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
                                }
                                return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Carousel.getOrCreateInstance(this, config2);
                                    if (typeof config2 === "number") {
                                        data.to(config2);
                                        return;
                                    }
                                    if (typeof config2 === "string") {
                                        if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
                                            throw new TypeError(`No method named "${config2}"`);
                                        }
                                        data[config2]();
                                    }
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
                            const target = SelectorEngine.getElementFromSelector(this);
                            if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
                                return;
                            }
                            event.preventDefault();
                            const carousel = Carousel.getOrCreateInstance(target);
                            const slideIndex = this.getAttribute("data-bs-slide-to");
                            if (slideIndex) {
                                carousel.to(slideIndex);
                                carousel._maybeEnableCycle();
                                return;
                            }
                            if (Manipulator.getDataAttribute(this, "slide") === "next") {
                                carousel.next();
                                carousel._maybeEnableCycle();
                                return;
                            }
                            carousel.prev();
                            carousel._maybeEnableCycle();
                        });
                        EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{
                            const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
                            for (const carousel of carousels){
                                Carousel.getOrCreateInstance(carousel);
                            }
                        });
                        defineJQueryPlugin(Carousel);
                        const NAME$b = "collapse";
                        const DATA_KEY$7 = "bs.collapse";
                        const EVENT_KEY$7 = `.${DATA_KEY$7}`;
                        const DATA_API_KEY$4 = ".data-api";
                        const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
                        const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
                        const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
                        const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
                        const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
                        const CLASS_NAME_SHOW$7 = "show";
                        const CLASS_NAME_COLLAPSE = "collapse";
                        const CLASS_NAME_COLLAPSING = "collapsing";
                        const CLASS_NAME_COLLAPSED = "collapsed";
                        const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
                        const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
                        const WIDTH = "width";
                        const HEIGHT = "height";
                        const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
                        const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
                        const Default$a = {
                            parent: null,
                            toggle: true
                        };
                        const DefaultType$a = {
                            parent: "(null|element)",
                            toggle: "boolean"
                        };
                        class Collapse extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._isTransitioning = false;
                                this._triggerArray = [];
                                const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
                                for (const elem of toggleList){
                                    const selector = SelectorEngine.getSelectorFromElement(elem);
                                    const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);
                                    if (selector !== null && filterElement.length) {
                                        this._triggerArray.push(elem);
                                    }
                                }
                                this._initializeChildren();
                                if (!this._config.parent) {
                                    this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
                                }
                                if (this._config.toggle) {
                                    this.toggle();
                                }
                            }
                            static get Default() {
                                return Default$a;
                            }
                            static get DefaultType() {
                                return DefaultType$a;
                            }
                            static get NAME() {
                                return NAME$b;
                            }
                            toggle() {
                                if (this._isShown()) {
                                    this.hide();
                                } else {
                                    this.show();
                                }
                            }
                            show() {
                                if (this._isTransitioning || this._isShown()) {
                                    return;
                                }
                                let activeChildren = [];
                                if (this._config.parent) {
                                    activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {
                                            toggle: false
                                        }));
                                }
                                if (activeChildren.length && activeChildren[0]._isTransitioning) {
                                    return;
                                }
                                const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
                                if (startEvent.defaultPrevented) {
                                    return;
                                }
                                for (const activeInstance of activeChildren){
                                    activeInstance.hide();
                                }
                                const dimension = this._getDimension();
                                this._element.classList.remove(CLASS_NAME_COLLAPSE);
                                this._element.classList.add(CLASS_NAME_COLLAPSING);
                                this._element.style[dimension] = 0;
                                this._addAriaAndCollapsedClass(this._triggerArray, true);
                                this._isTransitioning = true;
                                const complete = ()=>{
                                    this._isTransitioning = false;
                                    this._element.classList.remove(CLASS_NAME_COLLAPSING);
                                    this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
                                    this._element.style[dimension] = "";
                                    EventHandler.trigger(this._element, EVENT_SHOWN$6);
                                };
                                const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
                                const scrollSize = `scroll${capitalizedDimension}`;
                                this._queueCallback(complete, this._element, true);
                                this._element.style[dimension] = `${this._element[scrollSize]}px`;
                            }
                            hide() {
                                if (this._isTransitioning || !this._isShown()) {
                                    return;
                                }
                                const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
                                if (startEvent.defaultPrevented) {
                                    return;
                                }
                                const dimension = this._getDimension();
                                this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
                                reflow(this._element);
                                this._element.classList.add(CLASS_NAME_COLLAPSING);
                                this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
                                for (const trigger2 of this._triggerArray){
                                    const element = SelectorEngine.getElementFromSelector(trigger2);
                                    if (element && !this._isShown(element)) {
                                        this._addAriaAndCollapsedClass([
                                            trigger2
                                        ], false);
                                    }
                                }
                                this._isTransitioning = true;
                                const complete = ()=>{
                                    this._isTransitioning = false;
                                    this._element.classList.remove(CLASS_NAME_COLLAPSING);
                                    this._element.classList.add(CLASS_NAME_COLLAPSE);
                                    EventHandler.trigger(this._element, EVENT_HIDDEN$6);
                                };
                                this._element.style[dimension] = "";
                                this._queueCallback(complete, this._element, true);
                            }
                            _isShown(element = this._element) {
                                return element.classList.contains(CLASS_NAME_SHOW$7);
                            }
                            _configAfterMerge(config2) {
                                config2.toggle = Boolean(config2.toggle);
                                config2.parent = getElement(config2.parent);
                                return config2;
                            }
                            _getDimension() {
                                return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
                            }
                            _initializeChildren() {
                                if (!this._config.parent) {
                                    return;
                                }
                                const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
                                for (const element of children){
                                    const selected = SelectorEngine.getElementFromSelector(element);
                                    if (selected) {
                                        this._addAriaAndCollapsedClass([
                                            element
                                        ], this._isShown(selected));
                                    }
                                }
                            }
                            _getFirstLevelChildren(selector) {
                                const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
                                return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));
                            }
                            _addAriaAndCollapsedClass(triggerArray, isOpen) {
                                if (!triggerArray.length) {
                                    return;
                                }
                                for (const element of triggerArray){
                                    element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
                                    element.setAttribute("aria-expanded", isOpen);
                                }
                            }
                            static jQueryInterface(config2) {
                                const _config2 = {};
                                if (typeof config2 === "string" && /show|hide/.test(config2)) {
                                    _config2.toggle = false;
                                }
                                return this.each(function() {
                                    const data = Collapse.getOrCreateInstance(this, _config2);
                                    if (typeof config2 === "string") {
                                        if (typeof data[config2] === "undefined") {
                                            throw new TypeError(`No method named "${config2}"`);
                                        }
                                        data[config2]();
                                    }
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
                            if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
                                event.preventDefault();
                            }
                            for (const element of SelectorEngine.getMultipleElementsFromSelector(this)){
                                Collapse.getOrCreateInstance(element, {
                                    toggle: false
                                }).toggle();
                            }
                        });
                        defineJQueryPlugin(Collapse);
                        const NAME$a = "dropdown";
                        const DATA_KEY$6 = "bs.dropdown";
                        const EVENT_KEY$6 = `.${DATA_KEY$6}`;
                        const DATA_API_KEY$3 = ".data-api";
                        const ESCAPE_KEY$2 = "Escape";
                        const TAB_KEY$1 = "Tab";
                        const ARROW_UP_KEY$1 = "ArrowUp";
                        const ARROW_DOWN_KEY$1 = "ArrowDown";
                        const RIGHT_MOUSE_BUTTON = 2;
                        const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
                        const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
                        const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
                        const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
                        const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
                        const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
                        const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
                        const CLASS_NAME_SHOW$6 = "show";
                        const CLASS_NAME_DROPUP = "dropup";
                        const CLASS_NAME_DROPEND = "dropend";
                        const CLASS_NAME_DROPSTART = "dropstart";
                        const CLASS_NAME_DROPUP_CENTER = "dropup-center";
                        const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
                        const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
                        const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
                        const SELECTOR_MENU = ".dropdown-menu";
                        const SELECTOR_NAVBAR = ".navbar";
                        const SELECTOR_NAVBAR_NAV = ".navbar-nav";
                        const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
                        const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
                        const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
                        const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
                        const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
                        const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
                        const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
                        const PLACEMENT_TOPCENTER = "top";
                        const PLACEMENT_BOTTOMCENTER = "bottom";
                        const Default$9 = {
                            autoClose: true,
                            boundary: "clippingParents",
                            display: "dynamic",
                            offset: [
                                0,
                                2
                            ],
                            popperConfig: null,
                            reference: "toggle"
                        };
                        const DefaultType$9 = {
                            autoClose: "(boolean|string)",
                            boundary: "(string|element)",
                            display: "string",
                            offset: "(array|string|function)",
                            popperConfig: "(null|object|function)",
                            reference: "(string|element|object)"
                        };
                        class Dropdown extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._popper = null;
                                this._parent = this._element.parentNode;
                                this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
                                this._inNavbar = this._detectNavbar();
                            }
                            static get Default() {
                                return Default$9;
                            }
                            static get DefaultType() {
                                return DefaultType$9;
                            }
                            static get NAME() {
                                return NAME$a;
                            }
                            toggle() {
                                return this._isShown() ? this.hide() : this.show();
                            }
                            show() {
                                if (isDisabled(this._element) || this._isShown()) {
                                    return;
                                }
                                const relatedTarget = {
                                    relatedTarget: this._element
                                };
                                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
                                if (showEvent.defaultPrevented) {
                                    return;
                                }
                                this._createPopper();
                                if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
                                    for (const element of [].concat(...document.body.children)){
                                        EventHandler.on(element, "mouseover", noop2);
                                    }
                                }
                                this._element.focus();
                                this._element.setAttribute("aria-expanded", true);
                                this._menu.classList.add(CLASS_NAME_SHOW$6);
                                this._element.classList.add(CLASS_NAME_SHOW$6);
                                EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
                            }
                            hide() {
                                if (isDisabled(this._element) || !this._isShown()) {
                                    return;
                                }
                                const relatedTarget = {
                                    relatedTarget: this._element
                                };
                                this._completeHide(relatedTarget);
                            }
                            dispose() {
                                if (this._popper) {
                                    this._popper.destroy();
                                }
                                super.dispose();
                            }
                            update() {
                                this._inNavbar = this._detectNavbar();
                                if (this._popper) {
                                    this._popper.update();
                                }
                            }
                            _completeHide(relatedTarget) {
                                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                if ("ontouchstart" in document.documentElement) {
                                    for (const element of [].concat(...document.body.children)){
                                        EventHandler.off(element, "mouseover", noop2);
                                    }
                                }
                                if (this._popper) {
                                    this._popper.destroy();
                                }
                                this._menu.classList.remove(CLASS_NAME_SHOW$6);
                                this._element.classList.remove(CLASS_NAME_SHOW$6);
                                this._element.setAttribute("aria-expanded", "false");
                                Manipulator.removeDataAttribute(this._menu, "popper");
                                EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
                            }
                            _getConfig(config2) {
                                config2 = super._getConfig(config2);
                                if (typeof config2.reference === "object" && !isElement2(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
                                    throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
                                }
                                return config2;
                            }
                            _createPopper() {
                                if (typeof Popper__namespace === "undefined") {
                                    throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
                                }
                                let referenceElement = this._element;
                                if (this._config.reference === "parent") {
                                    referenceElement = this._parent;
                                } else if (isElement2(this._config.reference)) {
                                    referenceElement = getElement(this._config.reference);
                                } else if (typeof this._config.reference === "object") {
                                    referenceElement = this._config.reference;
                                }
                                const popperConfig = this._getPopperConfig();
                                this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);
                            }
                            _isShown() {
                                return this._menu.classList.contains(CLASS_NAME_SHOW$6);
                            }
                            _getPlacement() {
                                const parentDropdown = this._parent;
                                if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
                                    return PLACEMENT_RIGHT;
                                }
                                if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
                                    return PLACEMENT_LEFT;
                                }
                                if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
                                    return PLACEMENT_TOPCENTER;
                                }
                                if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
                                    return PLACEMENT_BOTTOMCENTER;
                                }
                                const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
                                if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
                                    return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
                                }
                                return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
                            }
                            _detectNavbar() {
                                return this._element.closest(SELECTOR_NAVBAR) !== null;
                            }
                            _getOffset() {
                                const { offset: offset2 } = this._config;
                                if (typeof offset2 === "string") {
                                    return offset2.split(",").map((value)=>Number.parseInt(value, 10));
                                }
                                if (typeof offset2 === "function") {
                                    return (popperData)=>offset2(popperData, this._element);
                                }
                                return offset2;
                            }
                            _getPopperConfig() {
                                const defaultBsPopperConfig = {
                                    placement: this._getPlacement(),
                                    modifiers: [
                                        {
                                            name: "preventOverflow",
                                            options: {
                                                boundary: this._config.boundary
                                            }
                                        },
                                        {
                                            name: "offset",
                                            options: {
                                                offset: this._getOffset()
                                            }
                                        }
                                    ]
                                };
                                if (this._inNavbar || this._config.display === "static") {
                                    Manipulator.setDataAttribute(this._menu, "popper", "static");
                                    defaultBsPopperConfig.modifiers = [
                                        {
                                            name: "applyStyles",
                                            enabled: false
                                        }
                                    ];
                                }
                                return {
                                    ...defaultBsPopperConfig,
                                    ...execute(this._config.popperConfig, [
                                        void 0,
                                        defaultBsPopperConfig
                                    ])
                                };
                            }
                            _selectMenuItem({ key, target }) {
                                const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));
                                if (!items.length) {
                                    return;
                                }
                                getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Dropdown.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (typeof data[config2] === "undefined") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2]();
                                });
                            }
                            static clearMenus(event) {
                                if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
                                    return;
                                }
                                const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
                                for (const toggle of openToggles){
                                    const context = Dropdown.getInstance(toggle);
                                    if (!context || context._config.autoClose === false) {
                                        continue;
                                    }
                                    const composedPath = event.composedPath();
                                    const isMenuTarget = composedPath.includes(context._menu);
                                    if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
                                        continue;
                                    }
                                    if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
                                        continue;
                                    }
                                    const relatedTarget = {
                                        relatedTarget: context._element
                                    };
                                    if (event.type === "click") {
                                        relatedTarget.clickEvent = event;
                                    }
                                    context._completeHide(relatedTarget);
                                }
                            }
                            static dataApiKeydownHandler(event) {
                                const isInput = /input|textarea/i.test(event.target.tagName);
                                const isEscapeEvent = event.key === ESCAPE_KEY$2;
                                const isUpOrDownEvent = [
                                    ARROW_UP_KEY$1,
                                    ARROW_DOWN_KEY$1
                                ].includes(event.key);
                                if (!isUpOrDownEvent && !isEscapeEvent) {
                                    return;
                                }
                                if (isInput && !isEscapeEvent) {
                                    return;
                                }
                                event.preventDefault();
                                const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
                                const instance = Dropdown.getOrCreateInstance(getToggleButton);
                                if (isUpOrDownEvent) {
                                    event.stopPropagation();
                                    instance.show();
                                    instance._selectMenuItem(event);
                                    return;
                                }
                                if (instance._isShown()) {
                                    event.stopPropagation();
                                    instance.hide();
                                    getToggleButton.focus();
                                }
                            }
                        }
                        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
                        EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
                        EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
                        EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
                        EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
                            event.preventDefault();
                            Dropdown.getOrCreateInstance(this).toggle();
                        });
                        defineJQueryPlugin(Dropdown);
                        const NAME$9 = "backdrop";
                        const CLASS_NAME_FADE$4 = "fade";
                        const CLASS_NAME_SHOW$5 = "show";
                        const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
                        const Default$8 = {
                            className: "modal-backdrop",
                            clickCallback: null,
                            isAnimated: false,
                            isVisible: true,
                            rootElement: "body"
                        };
                        const DefaultType$8 = {
                            className: "string",
                            clickCallback: "(function|null)",
                            isAnimated: "boolean",
                            isVisible: "boolean",
                            rootElement: "(element|string)"
                        };
                        class Backdrop extends Config {
                            constructor(config2){
                                super();
                                this._config = this._getConfig(config2);
                                this._isAppended = false;
                                this._element = null;
                            }
                            static get Default() {
                                return Default$8;
                            }
                            static get DefaultType() {
                                return DefaultType$8;
                            }
                            static get NAME() {
                                return NAME$9;
                            }
                            show(callback) {
                                if (!this._config.isVisible) {
                                    execute(callback);
                                    return;
                                }
                                this._append();
                                const element = this._getElement();
                                if (this._config.isAnimated) {
                                    reflow(element);
                                }
                                element.classList.add(CLASS_NAME_SHOW$5);
                                this._emulateAnimation(()=>{
                                    execute(callback);
                                });
                            }
                            hide(callback) {
                                if (!this._config.isVisible) {
                                    execute(callback);
                                    return;
                                }
                                this._getElement().classList.remove(CLASS_NAME_SHOW$5);
                                this._emulateAnimation(()=>{
                                    this.dispose();
                                    execute(callback);
                                });
                            }
                            dispose() {
                                if (!this._isAppended) {
                                    return;
                                }
                                EventHandler.off(this._element, EVENT_MOUSEDOWN);
                                this._element.remove();
                                this._isAppended = false;
                            }
                            _getElement() {
                                if (!this._element) {
                                    const backdrop = document.createElement("div");
                                    backdrop.className = this._config.className;
                                    if (this._config.isAnimated) {
                                        backdrop.classList.add(CLASS_NAME_FADE$4);
                                    }
                                    this._element = backdrop;
                                }
                                return this._element;
                            }
                            _configAfterMerge(config2) {
                                config2.rootElement = getElement(config2.rootElement);
                                return config2;
                            }
                            _append() {
                                if (this._isAppended) {
                                    return;
                                }
                                const element = this._getElement();
                                this._config.rootElement.append(element);
                                EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{
                                    execute(this._config.clickCallback);
                                });
                                this._isAppended = true;
                            }
                            _emulateAnimation(callback) {
                                executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
                            }
                        }
                        const NAME$8 = "focustrap";
                        const DATA_KEY$5 = "bs.focustrap";
                        const EVENT_KEY$5 = `.${DATA_KEY$5}`;
                        const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
                        const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
                        const TAB_KEY = "Tab";
                        const TAB_NAV_FORWARD = "forward";
                        const TAB_NAV_BACKWARD = "backward";
                        const Default$7 = {
                            autofocus: true,
                            trapElement: null
                        };
                        const DefaultType$7 = {
                            autofocus: "boolean",
                            trapElement: "element"
                        };
                        class FocusTrap extends Config {
                            constructor(config2){
                                super();
                                this._config = this._getConfig(config2);
                                this._isActive = false;
                                this._lastTabNavDirection = null;
                            }
                            static get Default() {
                                return Default$7;
                            }
                            static get DefaultType() {
                                return DefaultType$7;
                            }
                            static get NAME() {
                                return NAME$8;
                            }
                            activate() {
                                if (this._isActive) {
                                    return;
                                }
                                if (this._config.autofocus) {
                                    this._config.trapElement.focus();
                                }
                                EventHandler.off(document, EVENT_KEY$5);
                                EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));
                                EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));
                                this._isActive = true;
                            }
                            deactivate() {
                                if (!this._isActive) {
                                    return;
                                }
                                this._isActive = false;
                                EventHandler.off(document, EVENT_KEY$5);
                            }
                            _handleFocusin(event) {
                                const { trapElement } = this._config;
                                if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
                                    return;
                                }
                                const elements = SelectorEngine.focusableChildren(trapElement);
                                if (elements.length === 0) {
                                    trapElement.focus();
                                } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
                                    elements[elements.length - 1].focus();
                                } else {
                                    elements[0].focus();
                                }
                            }
                            _handleKeydown(event) {
                                if (event.key !== TAB_KEY) {
                                    return;
                                }
                                this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
                            }
                        }
                        const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
                        const SELECTOR_STICKY_CONTENT = ".sticky-top";
                        const PROPERTY_PADDING = "padding-right";
                        const PROPERTY_MARGIN = "margin-right";
                        class ScrollBarHelper {
                            constructor(){
                                this._element = document.body;
                            }
                            getWidth() {
                                const documentWidth = document.documentElement.clientWidth;
                                return Math.abs(window.innerWidth - documentWidth);
                            }
                            hide() {
                                const width = this.getWidth();
                                this._disableOverFlow();
                                this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
                                this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);
                                this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);
                            }
                            reset() {
                                this._resetElementAttributes(this._element, "overflow");
                                this._resetElementAttributes(this._element, PROPERTY_PADDING);
                                this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
                                this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
                            }
                            isOverflowing() {
                                return this.getWidth() > 0;
                            }
                            _disableOverFlow() {
                                this._saveInitialAttribute(this._element, "overflow");
                                this._element.style.overflow = "hidden";
                            }
                            _setElementAttributes(selector, styleProperty, callback) {
                                const scrollbarWidth = this.getWidth();
                                const manipulationCallBack = (element)=>{
                                    if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
                                        return;
                                    }
                                    this._saveInitialAttribute(element, styleProperty);
                                    const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
                                    element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
                                };
                                this._applyManipulationCallback(selector, manipulationCallBack);
                            }
                            _saveInitialAttribute(element, styleProperty) {
                                const actualValue = element.style.getPropertyValue(styleProperty);
                                if (actualValue) {
                                    Manipulator.setDataAttribute(element, styleProperty, actualValue);
                                }
                            }
                            _resetElementAttributes(selector, styleProperty) {
                                const manipulationCallBack = (element)=>{
                                    const value = Manipulator.getDataAttribute(element, styleProperty);
                                    if (value === null) {
                                        element.style.removeProperty(styleProperty);
                                        return;
                                    }
                                    Manipulator.removeDataAttribute(element, styleProperty);
                                    element.style.setProperty(styleProperty, value);
                                };
                                this._applyManipulationCallback(selector, manipulationCallBack);
                            }
                            _applyManipulationCallback(selector, callBack) {
                                if (isElement2(selector)) {
                                    callBack(selector);
                                    return;
                                }
                                for (const sel of SelectorEngine.find(selector, this._element)){
                                    callBack(sel);
                                }
                            }
                        }
                        const NAME$7 = "modal";
                        const DATA_KEY$4 = "bs.modal";
                        const EVENT_KEY$4 = `.${DATA_KEY$4}`;
                        const DATA_API_KEY$2 = ".data-api";
                        const ESCAPE_KEY$1 = "Escape";
                        const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
                        const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
                        const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
                        const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
                        const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
                        const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
                        const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
                        const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
                        const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
                        const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
                        const CLASS_NAME_OPEN = "modal-open";
                        const CLASS_NAME_FADE$3 = "fade";
                        const CLASS_NAME_SHOW$4 = "show";
                        const CLASS_NAME_STATIC = "modal-static";
                        const OPEN_SELECTOR$1 = ".modal.show";
                        const SELECTOR_DIALOG = ".modal-dialog";
                        const SELECTOR_MODAL_BODY = ".modal-body";
                        const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
                        const Default$6 = {
                            backdrop: true,
                            focus: true,
                            keyboard: true
                        };
                        const DefaultType$6 = {
                            backdrop: "(boolean|string)",
                            focus: "boolean",
                            keyboard: "boolean"
                        };
                        class Modal extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
                                this._backdrop = this._initializeBackDrop();
                                this._focustrap = this._initializeFocusTrap();
                                this._isShown = false;
                                this._isTransitioning = false;
                                this._scrollBar = new ScrollBarHelper();
                                this._addEventListeners();
                            }
                            static get Default() {
                                return Default$6;
                            }
                            static get DefaultType() {
                                return DefaultType$6;
                            }
                            static get NAME() {
                                return NAME$7;
                            }
                            toggle(relatedTarget) {
                                return this._isShown ? this.hide() : this.show(relatedTarget);
                            }
                            show(relatedTarget) {
                                if (this._isShown || this._isTransitioning) {
                                    return;
                                }
                                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
                                    relatedTarget
                                });
                                if (showEvent.defaultPrevented) {
                                    return;
                                }
                                this._isShown = true;
                                this._isTransitioning = true;
                                this._scrollBar.hide();
                                document.body.classList.add(CLASS_NAME_OPEN);
                                this._adjustDialog();
                                this._backdrop.show(()=>this._showElement(relatedTarget));
                            }
                            hide() {
                                if (!this._isShown || this._isTransitioning) {
                                    return;
                                }
                                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                this._isShown = false;
                                this._isTransitioning = true;
                                this._focustrap.deactivate();
                                this._element.classList.remove(CLASS_NAME_SHOW$4);
                                this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());
                            }
                            dispose() {
                                EventHandler.off(window, EVENT_KEY$4);
                                EventHandler.off(this._dialog, EVENT_KEY$4);
                                this._backdrop.dispose();
                                this._focustrap.deactivate();
                                super.dispose();
                            }
                            handleUpdate() {
                                this._adjustDialog();
                            }
                            _initializeBackDrop() {
                                return new Backdrop({
                                    isVisible: Boolean(this._config.backdrop),
                                    isAnimated: this._isAnimated()
                                });
                            }
                            _initializeFocusTrap() {
                                return new FocusTrap({
                                    trapElement: this._element
                                });
                            }
                            _showElement(relatedTarget) {
                                if (!document.body.contains(this._element)) {
                                    document.body.append(this._element);
                                }
                                this._element.style.display = "block";
                                this._element.removeAttribute("aria-hidden");
                                this._element.setAttribute("aria-modal", true);
                                this._element.setAttribute("role", "dialog");
                                this._element.scrollTop = 0;
                                const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
                                if (modalBody) {
                                    modalBody.scrollTop = 0;
                                }
                                reflow(this._element);
                                this._element.classList.add(CLASS_NAME_SHOW$4);
                                const transitionComplete = ()=>{
                                    if (this._config.focus) {
                                        this._focustrap.activate();
                                    }
                                    this._isTransitioning = false;
                                    EventHandler.trigger(this._element, EVENT_SHOWN$4, {
                                        relatedTarget
                                    });
                                };
                                this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
                            }
                            _addEventListeners() {
                                EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{
                                    if (event.key !== ESCAPE_KEY$1) {
                                        return;
                                    }
                                    if (this._config.keyboard) {
                                        this.hide();
                                        return;
                                    }
                                    this._triggerBackdropTransition();
                                });
                                EventHandler.on(window, EVENT_RESIZE$1, ()=>{
                                    if (this._isShown && !this._isTransitioning) {
                                        this._adjustDialog();
                                    }
                                });
                                EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{
                                    EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{
                                        if (this._element !== event.target || this._element !== event2.target) {
                                            return;
                                        }
                                        if (this._config.backdrop === "static") {
                                            this._triggerBackdropTransition();
                                            return;
                                        }
                                        if (this._config.backdrop) {
                                            this.hide();
                                        }
                                    });
                                });
                            }
                            _hideModal() {
                                this._element.style.display = "none";
                                this._element.setAttribute("aria-hidden", true);
                                this._element.removeAttribute("aria-modal");
                                this._element.removeAttribute("role");
                                this._isTransitioning = false;
                                this._backdrop.hide(()=>{
                                    document.body.classList.remove(CLASS_NAME_OPEN);
                                    this._resetAdjustments();
                                    this._scrollBar.reset();
                                    EventHandler.trigger(this._element, EVENT_HIDDEN$4);
                                });
                            }
                            _isAnimated() {
                                return this._element.classList.contains(CLASS_NAME_FADE$3);
                            }
                            _triggerBackdropTransition() {
                                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                                const initialOverflowY = this._element.style.overflowY;
                                if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
                                    return;
                                }
                                if (!isModalOverflowing) {
                                    this._element.style.overflowY = "hidden";
                                }
                                this._element.classList.add(CLASS_NAME_STATIC);
                                this._queueCallback(()=>{
                                    this._element.classList.remove(CLASS_NAME_STATIC);
                                    this._queueCallback(()=>{
                                        this._element.style.overflowY = initialOverflowY;
                                    }, this._dialog);
                                }, this._dialog);
                                this._element.focus();
                            }
                            _adjustDialog() {
                                const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
                                const scrollbarWidth = this._scrollBar.getWidth();
                                const isBodyOverflowing = scrollbarWidth > 0;
                                if (isBodyOverflowing && !isModalOverflowing) {
                                    const property = isRTL() ? "paddingLeft" : "paddingRight";
                                    this._element.style[property] = `${scrollbarWidth}px`;
                                }
                                if (!isBodyOverflowing && isModalOverflowing) {
                                    const property = isRTL() ? "paddingRight" : "paddingLeft";
                                    this._element.style[property] = `${scrollbarWidth}px`;
                                }
                            }
                            _resetAdjustments() {
                                this._element.style.paddingLeft = "";
                                this._element.style.paddingRight = "";
                            }
                            static jQueryInterface(config2, relatedTarget) {
                                return this.each(function() {
                                    const data = Modal.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (typeof data[config2] === "undefined") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2](relatedTarget);
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
                            const target = SelectorEngine.getElementFromSelector(this);
                            if ([
                                "A",
                                "AREA"
                            ].includes(this.tagName)) {
                                event.preventDefault();
                            }
                            EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{
                                if (showEvent.defaultPrevented) {
                                    return;
                                }
                                EventHandler.one(target, EVENT_HIDDEN$4, ()=>{
                                    if (isVisible(this)) {
                                        this.focus();
                                    }
                                });
                            });
                            const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
                            if (alreadyOpen) {
                                Modal.getInstance(alreadyOpen).hide();
                            }
                            const data = Modal.getOrCreateInstance(target);
                            data.toggle(this);
                        });
                        enableDismissTrigger(Modal);
                        defineJQueryPlugin(Modal);
                        const NAME$6 = "offcanvas";
                        const DATA_KEY$3 = "bs.offcanvas";
                        const EVENT_KEY$3 = `.${DATA_KEY$3}`;
                        const DATA_API_KEY$1 = ".data-api";
                        const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
                        const ESCAPE_KEY = "Escape";
                        const CLASS_NAME_SHOW$3 = "show";
                        const CLASS_NAME_SHOWING$1 = "showing";
                        const CLASS_NAME_HIDING = "hiding";
                        const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
                        const OPEN_SELECTOR = ".offcanvas.show";
                        const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
                        const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
                        const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
                        const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
                        const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
                        const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
                        const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
                        const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
                        const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
                        const Default$5 = {
                            backdrop: true,
                            keyboard: true,
                            scroll: false
                        };
                        const DefaultType$5 = {
                            backdrop: "(boolean|string)",
                            keyboard: "boolean",
                            scroll: "boolean"
                        };
                        class Offcanvas extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._isShown = false;
                                this._backdrop = this._initializeBackDrop();
                                this._focustrap = this._initializeFocusTrap();
                                this._addEventListeners();
                            }
                            static get Default() {
                                return Default$5;
                            }
                            static get DefaultType() {
                                return DefaultType$5;
                            }
                            static get NAME() {
                                return NAME$6;
                            }
                            toggle(relatedTarget) {
                                return this._isShown ? this.hide() : this.show(relatedTarget);
                            }
                            show(relatedTarget) {
                                if (this._isShown) {
                                    return;
                                }
                                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
                                    relatedTarget
                                });
                                if (showEvent.defaultPrevented) {
                                    return;
                                }
                                this._isShown = true;
                                this._backdrop.show();
                                if (!this._config.scroll) {
                                    new ScrollBarHelper().hide();
                                }
                                this._element.setAttribute("aria-modal", true);
                                this._element.setAttribute("role", "dialog");
                                this._element.classList.add(CLASS_NAME_SHOWING$1);
                                const completeCallBack = ()=>{
                                    if (!this._config.scroll || this._config.backdrop) {
                                        this._focustrap.activate();
                                    }
                                    this._element.classList.add(CLASS_NAME_SHOW$3);
                                    this._element.classList.remove(CLASS_NAME_SHOWING$1);
                                    EventHandler.trigger(this._element, EVENT_SHOWN$3, {
                                        relatedTarget
                                    });
                                };
                                this._queueCallback(completeCallBack, this._element, true);
                            }
                            hide() {
                                if (!this._isShown) {
                                    return;
                                }
                                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                this._focustrap.deactivate();
                                this._element.blur();
                                this._isShown = false;
                                this._element.classList.add(CLASS_NAME_HIDING);
                                this._backdrop.hide();
                                const completeCallback = ()=>{
                                    this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
                                    this._element.removeAttribute("aria-modal");
                                    this._element.removeAttribute("role");
                                    if (!this._config.scroll) {
                                        new ScrollBarHelper().reset();
                                    }
                                    EventHandler.trigger(this._element, EVENT_HIDDEN$3);
                                };
                                this._queueCallback(completeCallback, this._element, true);
                            }
                            dispose() {
                                this._backdrop.dispose();
                                this._focustrap.deactivate();
                                super.dispose();
                            }
                            _initializeBackDrop() {
                                const clickCallback = ()=>{
                                    if (this._config.backdrop === "static") {
                                        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                                        return;
                                    }
                                    this.hide();
                                };
                                const isVisible2 = Boolean(this._config.backdrop);
                                return new Backdrop({
                                    className: CLASS_NAME_BACKDROP,
                                    isVisible: isVisible2,
                                    isAnimated: true,
                                    rootElement: this._element.parentNode,
                                    clickCallback: isVisible2 ? clickCallback : null
                                });
                            }
                            _initializeFocusTrap() {
                                return new FocusTrap({
                                    trapElement: this._element
                                });
                            }
                            _addEventListeners() {
                                EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{
                                    if (event.key !== ESCAPE_KEY) {
                                        return;
                                    }
                                    if (this._config.keyboard) {
                                        this.hide();
                                        return;
                                    }
                                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
                                });
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Offcanvas.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2](this);
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
                            const target = SelectorEngine.getElementFromSelector(this);
                            if ([
                                "A",
                                "AREA"
                            ].includes(this.tagName)) {
                                event.preventDefault();
                            }
                            if (isDisabled(this)) {
                                return;
                            }
                            EventHandler.one(target, EVENT_HIDDEN$3, ()=>{
                                if (isVisible(this)) {
                                    this.focus();
                                }
                            });
                            const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
                            if (alreadyOpen && alreadyOpen !== target) {
                                Offcanvas.getInstance(alreadyOpen).hide();
                            }
                            const data = Offcanvas.getOrCreateInstance(target);
                            data.toggle(this);
                        });
                        EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{
                            for (const selector of SelectorEngine.find(OPEN_SELECTOR)){
                                Offcanvas.getOrCreateInstance(selector).show();
                            }
                        });
                        EventHandler.on(window, EVENT_RESIZE, ()=>{
                            for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")){
                                if (getComputedStyle(element).position !== "fixed") {
                                    Offcanvas.getOrCreateInstance(element).hide();
                                }
                            }
                        });
                        enableDismissTrigger(Offcanvas);
                        defineJQueryPlugin(Offcanvas);
                        const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
                        const DefaultAllowlist = {
                            "*": [
                                "class",
                                "dir",
                                "id",
                                "lang",
                                "role",
                                ARIA_ATTRIBUTE_PATTERN
                            ],
                            a: [
                                "target",
                                "href",
                                "title",
                                "rel"
                            ],
                            area: [],
                            b: [],
                            br: [],
                            col: [],
                            code: [],
                            dd: [],
                            div: [],
                            dl: [],
                            dt: [],
                            em: [],
                            hr: [],
                            h1: [],
                            h2: [],
                            h3: [],
                            h4: [],
                            h5: [],
                            h6: [],
                            i: [],
                            img: [
                                "src",
                                "srcset",
                                "alt",
                                "title",
                                "width",
                                "height"
                            ],
                            li: [],
                            ol: [],
                            p: [],
                            pre: [],
                            s: [],
                            small: [],
                            span: [],
                            sub: [],
                            sup: [],
                            strong: [],
                            u: [],
                            ul: []
                        };
                        const uriAttributes = new Set([
                            "background",
                            "cite",
                            "href",
                            "itemtype",
                            "longdesc",
                            "poster",
                            "src",
                            "xlink:href"
                        ]);
                        const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
                        const allowedAttribute = (attribute, allowedAttributeList)=>{
                            const attributeName = attribute.nodeName.toLowerCase();
                            if (allowedAttributeList.includes(attributeName)) {
                                if (uriAttributes.has(attributeName)) {
                                    return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
                                }
                                return true;
                            }
                            return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));
                        };
                        function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
                            if (!unsafeHtml.length) {
                                return unsafeHtml;
                            }
                            if (sanitizeFunction && typeof sanitizeFunction === "function") {
                                return sanitizeFunction(unsafeHtml);
                            }
                            const domParser = new window.DOMParser();
                            const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
                            const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
                            for (const element of elements){
                                const elementName = element.nodeName.toLowerCase();
                                if (!Object.keys(allowList).includes(elementName)) {
                                    element.remove();
                                    continue;
                                }
                                const attributeList = [].concat(...element.attributes);
                                const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
                                for (const attribute of attributeList){
                                    if (!allowedAttribute(attribute, allowedAttributes)) {
                                        element.removeAttribute(attribute.nodeName);
                                    }
                                }
                            }
                            return createdDocument.body.innerHTML;
                        }
                        const NAME$5 = "TemplateFactory";
                        const Default$4 = {
                            allowList: DefaultAllowlist,
                            content: {},
                            extraClass: "",
                            html: false,
                            sanitize: true,
                            sanitizeFn: null,
                            template: "<div></div>"
                        };
                        const DefaultType$4 = {
                            allowList: "object",
                            content: "object",
                            extraClass: "(string|function)",
                            html: "boolean",
                            sanitize: "boolean",
                            sanitizeFn: "(null|function)",
                            template: "string"
                        };
                        const DefaultContentType = {
                            entry: "(string|element|function|null)",
                            selector: "(string|element)"
                        };
                        class TemplateFactory extends Config {
                            constructor(config2){
                                super();
                                this._config = this._getConfig(config2);
                            }
                            static get Default() {
                                return Default$4;
                            }
                            static get DefaultType() {
                                return DefaultType$4;
                            }
                            static get NAME() {
                                return NAME$5;
                            }
                            getContent() {
                                return Object.values(this._config.content).map((config2)=>this._resolvePossibleFunction(config2)).filter(Boolean);
                            }
                            hasContent() {
                                return this.getContent().length > 0;
                            }
                            changeContent(content) {
                                this._checkContent(content);
                                this._config.content = {
                                    ...this._config.content,
                                    ...content
                                };
                                return this;
                            }
                            toHtml() {
                                const templateWrapper = document.createElement("div");
                                templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
                                for (const [selector, text] of Object.entries(this._config.content)){
                                    this._setContent(templateWrapper, text, selector);
                                }
                                const template = templateWrapper.children[0];
                                const extraClass = this._resolvePossibleFunction(this._config.extraClass);
                                if (extraClass) {
                                    template.classList.add(...extraClass.split(" "));
                                }
                                return template;
                            }
                            _typeCheckConfig(config2) {
                                super._typeCheckConfig(config2);
                                this._checkContent(config2.content);
                            }
                            _checkContent(arg) {
                                for (const [selector, content] of Object.entries(arg)){
                                    super._typeCheckConfig({
                                        selector,
                                        entry: content
                                    }, DefaultContentType);
                                }
                            }
                            _setContent(template, content, selector) {
                                const templateElement = SelectorEngine.findOne(selector, template);
                                if (!templateElement) {
                                    return;
                                }
                                content = this._resolvePossibleFunction(content);
                                if (!content) {
                                    templateElement.remove();
                                    return;
                                }
                                if (isElement2(content)) {
                                    this._putElementInTemplate(getElement(content), templateElement);
                                    return;
                                }
                                if (this._config.html) {
                                    templateElement.innerHTML = this._maybeSanitize(content);
                                    return;
                                }
                                templateElement.textContent = content;
                            }
                            _maybeSanitize(arg) {
                                return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
                            }
                            _resolvePossibleFunction(arg) {
                                return execute(arg, [
                                    void 0,
                                    this
                                ]);
                            }
                            _putElementInTemplate(element, templateElement) {
                                if (this._config.html) {
                                    templateElement.innerHTML = "";
                                    templateElement.append(element);
                                    return;
                                }
                                templateElement.textContent = element.textContent;
                            }
                        }
                        const NAME$4 = "tooltip";
                        const DISALLOWED_ATTRIBUTES = new Set([
                            "sanitize",
                            "allowList",
                            "sanitizeFn"
                        ]);
                        const CLASS_NAME_FADE$2 = "fade";
                        const CLASS_NAME_MODAL = "modal";
                        const CLASS_NAME_SHOW$2 = "show";
                        const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
                        const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
                        const EVENT_MODAL_HIDE = "hide.bs.modal";
                        const TRIGGER_HOVER = "hover";
                        const TRIGGER_FOCUS = "focus";
                        const TRIGGER_CLICK = "click";
                        const TRIGGER_MANUAL = "manual";
                        const EVENT_HIDE$2 = "hide";
                        const EVENT_HIDDEN$2 = "hidden";
                        const EVENT_SHOW$2 = "show";
                        const EVENT_SHOWN$2 = "shown";
                        const EVENT_INSERTED = "inserted";
                        const EVENT_CLICK$1 = "click";
                        const EVENT_FOCUSIN$1 = "focusin";
                        const EVENT_FOCUSOUT$1 = "focusout";
                        const EVENT_MOUSEENTER = "mouseenter";
                        const EVENT_MOUSELEAVE = "mouseleave";
                        const AttachmentMap = {
                            AUTO: "auto",
                            TOP: "top",
                            RIGHT: isRTL() ? "left" : "right",
                            BOTTOM: "bottom",
                            LEFT: isRTL() ? "right" : "left"
                        };
                        const Default$3 = {
                            allowList: DefaultAllowlist,
                            animation: true,
                            boundary: "clippingParents",
                            container: false,
                            customClass: "",
                            delay: 0,
                            fallbackPlacements: [
                                "top",
                                "right",
                                "bottom",
                                "left"
                            ],
                            html: false,
                            offset: [
                                0,
                                6
                            ],
                            placement: "top",
                            popperConfig: null,
                            sanitize: true,
                            sanitizeFn: null,
                            selector: false,
                            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                            title: "",
                            trigger: "hover focus"
                        };
                        const DefaultType$3 = {
                            allowList: "object",
                            animation: "boolean",
                            boundary: "(string|element)",
                            container: "(string|element|boolean)",
                            customClass: "(string|function)",
                            delay: "(number|object)",
                            fallbackPlacements: "array",
                            html: "boolean",
                            offset: "(array|string|function)",
                            placement: "(string|function)",
                            popperConfig: "(null|object|function)",
                            sanitize: "boolean",
                            sanitizeFn: "(null|function)",
                            selector: "(string|boolean)",
                            template: "string",
                            title: "(string|element|function)",
                            trigger: "string"
                        };
                        class Tooltip extends BaseComponent {
                            constructor(element, config2){
                                if (typeof Popper__namespace === "undefined") {
                                    throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
                                }
                                super(element, config2);
                                this._isEnabled = true;
                                this._timeout = 0;
                                this._isHovered = null;
                                this._activeTrigger = {};
                                this._popper = null;
                                this._templateFactory = null;
                                this._newContent = null;
                                this.tip = null;
                                this._setListeners();
                                if (!this._config.selector) {
                                    this._fixTitle();
                                }
                            }
                            static get Default() {
                                return Default$3;
                            }
                            static get DefaultType() {
                                return DefaultType$3;
                            }
                            static get NAME() {
                                return NAME$4;
                            }
                            enable() {
                                this._isEnabled = true;
                            }
                            disable() {
                                this._isEnabled = false;
                            }
                            toggleEnabled() {
                                this._isEnabled = !this._isEnabled;
                            }
                            toggle() {
                                if (!this._isEnabled) {
                                    return;
                                }
                                if (this._isShown()) {
                                    this._leave();
                                    return;
                                }
                                this._enter();
                            }
                            dispose() {
                                clearTimeout(this._timeout);
                                EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
                                if (this._element.getAttribute("data-bs-original-title")) {
                                    this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
                                }
                                this._disposePopper();
                                super.dispose();
                            }
                            show() {
                                if (this._element.style.display === "none") {
                                    throw new Error("Please use show on visible elements");
                                }
                                if (!(this._isWithContent() && this._isEnabled)) {
                                    return;
                                }
                                const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
                                const shadowRoot = findShadowRoot(this._element);
                                const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
                                if (showEvent.defaultPrevented || !isInTheDom) {
                                    return;
                                }
                                this._disposePopper();
                                const tip = this._getTipElement();
                                this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
                                const { container } = this._config;
                                if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
                                    container.append(tip);
                                    EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
                                }
                                this._popper = this._createPopper(tip);
                                tip.classList.add(CLASS_NAME_SHOW$2);
                                if ("ontouchstart" in document.documentElement) {
                                    for (const element of [].concat(...document.body.children)){
                                        EventHandler.on(element, "mouseover", noop2);
                                    }
                                }
                                const complete = ()=>{
                                    EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
                                    if (this._isHovered === false) {
                                        this._leave();
                                    }
                                    this._isHovered = false;
                                };
                                this._queueCallback(complete, this.tip, this._isAnimated());
                            }
                            hide() {
                                if (!this._isShown()) {
                                    return;
                                }
                                const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                const tip = this._getTipElement();
                                tip.classList.remove(CLASS_NAME_SHOW$2);
                                if ("ontouchstart" in document.documentElement) {
                                    for (const element of [].concat(...document.body.children)){
                                        EventHandler.off(element, "mouseover", noop2);
                                    }
                                }
                                this._activeTrigger[TRIGGER_CLICK] = false;
                                this._activeTrigger[TRIGGER_FOCUS] = false;
                                this._activeTrigger[TRIGGER_HOVER] = false;
                                this._isHovered = null;
                                const complete = ()=>{
                                    if (this._isWithActiveTrigger()) {
                                        return;
                                    }
                                    if (!this._isHovered) {
                                        this._disposePopper();
                                    }
                                    this._element.removeAttribute("aria-describedby");
                                    EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
                                };
                                this._queueCallback(complete, this.tip, this._isAnimated());
                            }
                            update() {
                                if (this._popper) {
                                    this._popper.update();
                                }
                            }
                            _isWithContent() {
                                return Boolean(this._getTitle());
                            }
                            _getTipElement() {
                                if (!this.tip) {
                                    this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
                                }
                                return this.tip;
                            }
                            _createTipElement(content) {
                                const tip = this._getTemplateFactory(content).toHtml();
                                if (!tip) {
                                    return null;
                                }
                                tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
                                tip.classList.add(`bs-${this.constructor.NAME}-auto`);
                                const tipId = getUID(this.constructor.NAME).toString();
                                tip.setAttribute("id", tipId);
                                if (this._isAnimated()) {
                                    tip.classList.add(CLASS_NAME_FADE$2);
                                }
                                return tip;
                            }
                            setContent(content) {
                                this._newContent = content;
                                if (this._isShown()) {
                                    this._disposePopper();
                                    this.show();
                                }
                            }
                            _getTemplateFactory(content) {
                                if (this._templateFactory) {
                                    this._templateFactory.changeContent(content);
                                } else {
                                    this._templateFactory = new TemplateFactory({
                                        ...this._config,
                                        content,
                                        extraClass: this._resolvePossibleFunction(this._config.customClass)
                                    });
                                }
                                return this._templateFactory;
                            }
                            _getContentForTemplate() {
                                return {
                                    [SELECTOR_TOOLTIP_INNER]: this._getTitle()
                                };
                            }
                            _getTitle() {
                                return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
                            }
                            _initializeOnDelegatedTarget(event) {
                                return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
                            }
                            _isAnimated() {
                                return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
                            }
                            _isShown() {
                                return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
                            }
                            _createPopper(tip) {
                                const placement = execute(this._config.placement, [
                                    this,
                                    tip,
                                    this._element
                                ]);
                                const attachment = AttachmentMap[placement.toUpperCase()];
                                return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));
                            }
                            _getOffset() {
                                const { offset: offset2 } = this._config;
                                if (typeof offset2 === "string") {
                                    return offset2.split(",").map((value)=>Number.parseInt(value, 10));
                                }
                                if (typeof offset2 === "function") {
                                    return (popperData)=>offset2(popperData, this._element);
                                }
                                return offset2;
                            }
                            _resolvePossibleFunction(arg) {
                                return execute(arg, [
                                    this._element,
                                    this._element
                                ]);
                            }
                            _getPopperConfig(attachment) {
                                const defaultBsPopperConfig = {
                                    placement: attachment,
                                    modifiers: [
                                        {
                                            name: "flip",
                                            options: {
                                                fallbackPlacements: this._config.fallbackPlacements
                                            }
                                        },
                                        {
                                            name: "offset",
                                            options: {
                                                offset: this._getOffset()
                                            }
                                        },
                                        {
                                            name: "preventOverflow",
                                            options: {
                                                boundary: this._config.boundary
                                            }
                                        },
                                        {
                                            name: "arrow",
                                            options: {
                                                element: `.${this.constructor.NAME}-arrow`
                                            }
                                        },
                                        {
                                            name: "preSetPlacement",
                                            enabled: true,
                                            phase: "beforeMain",
                                            fn: (data)=>{
                                                this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
                                            }
                                        }
                                    ]
                                };
                                return {
                                    ...defaultBsPopperConfig,
                                    ...execute(this._config.popperConfig, [
                                        void 0,
                                        defaultBsPopperConfig
                                    ])
                                };
                            }
                            _setListeners() {
                                const triggers = this._config.trigger.split(" ");
                                for (const trigger2 of triggers){
                                    if (trigger2 === "click") {
                                        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{
                                            const context = this._initializeOnDelegatedTarget(event);
                                            context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);
                                            context.toggle();
                                        });
                                    } else if (trigger2 !== TRIGGER_MANUAL) {
                                        const eventIn = trigger2 === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
                                        const eventOut = trigger2 === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
                                        EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{
                                            const context = this._initializeOnDelegatedTarget(event);
                                            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
                                            context._enter();
                                        });
                                        EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{
                                            const context = this._initializeOnDelegatedTarget(event);
                                            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
                                            context._leave();
                                        });
                                    }
                                }
                                this._hideModalHandler = ()=>{
                                    if (this._element) {
                                        this.hide();
                                    }
                                };
                                EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
                            }
                            _fixTitle() {
                                const title = this._element.getAttribute("title");
                                if (!title) {
                                    return;
                                }
                                if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
                                    this._element.setAttribute("aria-label", title);
                                }
                                this._element.setAttribute("data-bs-original-title", title);
                                this._element.removeAttribute("title");
                            }
                            _enter() {
                                if (this._isShown() || this._isHovered) {
                                    this._isHovered = true;
                                    return;
                                }
                                this._isHovered = true;
                                this._setTimeout(()=>{
                                    if (this._isHovered) {
                                        this.show();
                                    }
                                }, this._config.delay.show);
                            }
                            _leave() {
                                if (this._isWithActiveTrigger()) {
                                    return;
                                }
                                this._isHovered = false;
                                this._setTimeout(()=>{
                                    if (!this._isHovered) {
                                        this.hide();
                                    }
                                }, this._config.delay.hide);
                            }
                            _setTimeout(handler, timeout) {
                                clearTimeout(this._timeout);
                                this._timeout = setTimeout(handler, timeout);
                            }
                            _isWithActiveTrigger() {
                                return Object.values(this._activeTrigger).includes(true);
                            }
                            _getConfig(config2) {
                                const dataAttributes = Manipulator.getDataAttributes(this._element);
                                for (const dataAttribute of Object.keys(dataAttributes)){
                                    if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
                                        delete dataAttributes[dataAttribute];
                                    }
                                }
                                config2 = {
                                    ...dataAttributes,
                                    ...typeof config2 === "object" && config2 ? config2 : {}
                                };
                                config2 = this._mergeConfigObj(config2);
                                config2 = this._configAfterMerge(config2);
                                this._typeCheckConfig(config2);
                                return config2;
                            }
                            _configAfterMerge(config2) {
                                config2.container = config2.container === false ? document.body : getElement(config2.container);
                                if (typeof config2.delay === "number") {
                                    config2.delay = {
                                        show: config2.delay,
                                        hide: config2.delay
                                    };
                                }
                                if (typeof config2.title === "number") {
                                    config2.title = config2.title.toString();
                                }
                                if (typeof config2.content === "number") {
                                    config2.content = config2.content.toString();
                                }
                                return config2;
                            }
                            _getDelegateConfig() {
                                const config2 = {};
                                for (const [key, value] of Object.entries(this._config)){
                                    if (this.constructor.Default[key] !== value) {
                                        config2[key] = value;
                                    }
                                }
                                config2.selector = false;
                                config2.trigger = "manual";
                                return config2;
                            }
                            _disposePopper() {
                                if (this._popper) {
                                    this._popper.destroy();
                                    this._popper = null;
                                }
                                if (this.tip) {
                                    this.tip.remove();
                                    this.tip = null;
                                }
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Tooltip.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (typeof data[config2] === "undefined") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2]();
                                });
                            }
                        }
                        defineJQueryPlugin(Tooltip);
                        const NAME$3 = "popover";
                        const SELECTOR_TITLE = ".popover-header";
                        const SELECTOR_CONTENT = ".popover-body";
                        const Default$2 = {
                            ...Tooltip.Default,
                            content: "",
                            offset: [
                                0,
                                8
                            ],
                            placement: "right",
                            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
                            trigger: "click"
                        };
                        const DefaultType$2 = {
                            ...Tooltip.DefaultType,
                            content: "(null|string|element|function)"
                        };
                        class Popover extends Tooltip {
                            static get Default() {
                                return Default$2;
                            }
                            static get DefaultType() {
                                return DefaultType$2;
                            }
                            static get NAME() {
                                return NAME$3;
                            }
                            _isWithContent() {
                                return this._getTitle() || this._getContent();
                            }
                            _getContentForTemplate() {
                                return {
                                    [SELECTOR_TITLE]: this._getTitle(),
                                    [SELECTOR_CONTENT]: this._getContent()
                                };
                            }
                            _getContent() {
                                return this._resolvePossibleFunction(this._config.content);
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Popover.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (typeof data[config2] === "undefined") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2]();
                                });
                            }
                        }
                        defineJQueryPlugin(Popover);
                        const NAME$2 = "scrollspy";
                        const DATA_KEY$2 = "bs.scrollspy";
                        const EVENT_KEY$2 = `.${DATA_KEY$2}`;
                        const DATA_API_KEY = ".data-api";
                        const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
                        const EVENT_CLICK = `click${EVENT_KEY$2}`;
                        const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
                        const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
                        const CLASS_NAME_ACTIVE$1 = "active";
                        const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
                        const SELECTOR_TARGET_LINKS = "[href]";
                        const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
                        const SELECTOR_NAV_LINKS = ".nav-link";
                        const SELECTOR_NAV_ITEMS = ".nav-item";
                        const SELECTOR_LIST_ITEMS = ".list-group-item";
                        const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
                        const SELECTOR_DROPDOWN = ".dropdown";
                        const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
                        const Default$1 = {
                            offset: null,
                            rootMargin: "0px 0px -25%",
                            smoothScroll: false,
                            target: null,
                            threshold: [
                                0.1,
                                0.5,
                                1
                            ]
                        };
                        const DefaultType$1 = {
                            offset: "(number|null)",
                            rootMargin: "string",
                            smoothScroll: "boolean",
                            target: "element",
                            threshold: "array"
                        };
                        class ScrollSpy extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._targetLinks = new Map();
                                this._observableSections = new Map();
                                this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
                                this._activeTarget = null;
                                this._observer = null;
                                this._previousScrollData = {
                                    visibleEntryTop: 0,
                                    parentScrollTop: 0
                                };
                                this.refresh();
                            }
                            static get Default() {
                                return Default$1;
                            }
                            static get DefaultType() {
                                return DefaultType$1;
                            }
                            static get NAME() {
                                return NAME$2;
                            }
                            refresh() {
                                this._initializeTargetsAndObservables();
                                this._maybeEnableSmoothScroll();
                                if (this._observer) {
                                    this._observer.disconnect();
                                } else {
                                    this._observer = this._getNewObserver();
                                }
                                for (const section of this._observableSections.values()){
                                    this._observer.observe(section);
                                }
                            }
                            dispose() {
                                this._observer.disconnect();
                                super.dispose();
                            }
                            _configAfterMerge(config2) {
                                config2.target = getElement(config2.target) || document.body;
                                config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
                                if (typeof config2.threshold === "string") {
                                    config2.threshold = config2.threshold.split(",").map((value)=>Number.parseFloat(value));
                                }
                                return config2;
                            }
                            _maybeEnableSmoothScroll() {
                                if (!this._config.smoothScroll) {
                                    return;
                                }
                                EventHandler.off(this._config.target, EVENT_CLICK);
                                EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{
                                    const observableSection = this._observableSections.get(event.target.hash);
                                    if (observableSection) {
                                        event.preventDefault();
                                        const root = this._rootElement || window;
                                        const height = observableSection.offsetTop - this._element.offsetTop;
                                        if (root.scrollTo) {
                                            root.scrollTo({
                                                top: height,
                                                behavior: "smooth"
                                            });
                                            return;
                                        }
                                        root.scrollTop = height;
                                    }
                                });
                            }
                            _getNewObserver() {
                                const options = {
                                    root: this._rootElement,
                                    threshold: this._config.threshold,
                                    rootMargin: this._config.rootMargin
                                };
                                return new IntersectionObserver((entries)=>this._observerCallback(entries), options);
                            }
                            _observerCallback(entries) {
                                const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);
                                const activate = (entry)=>{
                                    this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
                                    this._process(targetElement(entry));
                                };
                                const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
                                const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
                                this._previousScrollData.parentScrollTop = parentScrollTop;
                                for (const entry of entries){
                                    if (!entry.isIntersecting) {
                                        this._activeTarget = null;
                                        this._clearActiveClass(targetElement(entry));
                                        continue;
                                    }
                                    const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
                                    if (userScrollsDown && entryIsLowerThanPrevious) {
                                        activate(entry);
                                        if (!parentScrollTop) {
                                            return;
                                        }
                                        continue;
                                    }
                                    if (!userScrollsDown && !entryIsLowerThanPrevious) {
                                        activate(entry);
                                    }
                                }
                            }
                            _initializeTargetsAndObservables() {
                                this._targetLinks = new Map();
                                this._observableSections = new Map();
                                const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
                                for (const anchor of targetLinks){
                                    if (!anchor.hash || isDisabled(anchor)) {
                                        continue;
                                    }
                                    const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
                                    if (isVisible(observableSection)) {
                                        this._targetLinks.set(decodeURI(anchor.hash), anchor);
                                        this._observableSections.set(anchor.hash, observableSection);
                                    }
                                }
                            }
                            _process(target) {
                                if (this._activeTarget === target) {
                                    return;
                                }
                                this._clearActiveClass(this._config.target);
                                this._activeTarget = target;
                                target.classList.add(CLASS_NAME_ACTIVE$1);
                                this._activateParents(target);
                                EventHandler.trigger(this._element, EVENT_ACTIVATE, {
                                    relatedTarget: target
                                });
                            }
                            _activateParents(target) {
                                if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
                                    SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
                                    return;
                                }
                                for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)){
                                    for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)){
                                        item.classList.add(CLASS_NAME_ACTIVE$1);
                                    }
                                }
                            }
                            _clearActiveClass(parent) {
                                parent.classList.remove(CLASS_NAME_ACTIVE$1);
                                const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
                                for (const node of activeNodes){
                                    node.classList.remove(CLASS_NAME_ACTIVE$1);
                                }
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = ScrollSpy.getOrCreateInstance(this, config2);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2]();
                                });
                            }
                        }
                        EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{
                            for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)){
                                ScrollSpy.getOrCreateInstance(spy);
                            }
                        });
                        defineJQueryPlugin(ScrollSpy);
                        const NAME$1 = "tab";
                        const DATA_KEY$1 = "bs.tab";
                        const EVENT_KEY$1 = `.${DATA_KEY$1}`;
                        const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
                        const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
                        const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
                        const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
                        const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
                        const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
                        const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
                        const ARROW_LEFT_KEY = "ArrowLeft";
                        const ARROW_RIGHT_KEY = "ArrowRight";
                        const ARROW_UP_KEY = "ArrowUp";
                        const ARROW_DOWN_KEY = "ArrowDown";
                        const HOME_KEY = "Home";
                        const END_KEY = "End";
                        const CLASS_NAME_ACTIVE = "active";
                        const CLASS_NAME_FADE$1 = "fade";
                        const CLASS_NAME_SHOW$1 = "show";
                        const CLASS_DROPDOWN = "dropdown";
                        const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
                        const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
                        const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
                        const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
                        const SELECTOR_OUTER = ".nav-item, .list-group-item";
                        const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
                        const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
                        const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
                        const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
                        class Tab extends BaseComponent {
                            constructor(element){
                                super(element);
                                this._parent = this._element.closest(SELECTOR_TAB_PANEL);
                                if (!this._parent) {
                                    return;
                                }
                                this._setInitialAttributes(this._parent, this._getChildren());
                                EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));
                            }
                            static get NAME() {
                                return NAME$1;
                            }
                            show() {
                                const innerElem = this._element;
                                if (this._elemIsActive(innerElem)) {
                                    return;
                                }
                                const active = this._getActiveElem();
                                const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
                                    relatedTarget: innerElem
                                }) : null;
                                const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
                                    relatedTarget: active
                                });
                                if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
                                    return;
                                }
                                this._deactivate(active, innerElem);
                                this._activate(innerElem, active);
                            }
                            _activate(element, relatedElem) {
                                if (!element) {
                                    return;
                                }
                                element.classList.add(CLASS_NAME_ACTIVE);
                                this._activate(SelectorEngine.getElementFromSelector(element));
                                const complete = ()=>{
                                    if (element.getAttribute("role") !== "tab") {
                                        element.classList.add(CLASS_NAME_SHOW$1);
                                        return;
                                    }
                                    element.removeAttribute("tabindex");
                                    element.setAttribute("aria-selected", true);
                                    this._toggleDropDown(element, true);
                                    EventHandler.trigger(element, EVENT_SHOWN$1, {
                                        relatedTarget: relatedElem
                                    });
                                };
                                this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
                            }
                            _deactivate(element, relatedElem) {
                                if (!element) {
                                    return;
                                }
                                element.classList.remove(CLASS_NAME_ACTIVE);
                                element.blur();
                                this._deactivate(SelectorEngine.getElementFromSelector(element));
                                const complete = ()=>{
                                    if (element.getAttribute("role") !== "tab") {
                                        element.classList.remove(CLASS_NAME_SHOW$1);
                                        return;
                                    }
                                    element.setAttribute("aria-selected", false);
                                    element.setAttribute("tabindex", "-1");
                                    this._toggleDropDown(element, false);
                                    EventHandler.trigger(element, EVENT_HIDDEN$1, {
                                        relatedTarget: relatedElem
                                    });
                                };
                                this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
                            }
                            _keydown(event) {
                                if (![
                                    ARROW_LEFT_KEY,
                                    ARROW_RIGHT_KEY,
                                    ARROW_UP_KEY,
                                    ARROW_DOWN_KEY,
                                    HOME_KEY,
                                    END_KEY
                                ].includes(event.key)) {
                                    return;
                                }
                                event.stopPropagation();
                                event.preventDefault();
                                const children = this._getChildren().filter((element)=>!isDisabled(element));
                                let nextActiveElement;
                                if ([
                                    HOME_KEY,
                                    END_KEY
                                ].includes(event.key)) {
                                    nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
                                } else {
                                    const isNext = [
                                        ARROW_RIGHT_KEY,
                                        ARROW_DOWN_KEY
                                    ].includes(event.key);
                                    nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
                                }
                                if (nextActiveElement) {
                                    nextActiveElement.focus({
                                        preventScroll: true
                                    });
                                    Tab.getOrCreateInstance(nextActiveElement).show();
                                }
                            }
                            _getChildren() {
                                return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
                            }
                            _getActiveElem() {
                                return this._getChildren().find((child)=>this._elemIsActive(child)) || null;
                            }
                            _setInitialAttributes(parent, children) {
                                this._setAttributeIfNotExists(parent, "role", "tablist");
                                for (const child of children){
                                    this._setInitialAttributesOnChild(child);
                                }
                            }
                            _setInitialAttributesOnChild(child) {
                                child = this._getInnerElement(child);
                                const isActive = this._elemIsActive(child);
                                const outerElem = this._getOuterElement(child);
                                child.setAttribute("aria-selected", isActive);
                                if (outerElem !== child) {
                                    this._setAttributeIfNotExists(outerElem, "role", "presentation");
                                }
                                if (!isActive) {
                                    child.setAttribute("tabindex", "-1");
                                }
                                this._setAttributeIfNotExists(child, "role", "tab");
                                this._setInitialAttributesOnTargetPanel(child);
                            }
                            _setInitialAttributesOnTargetPanel(child) {
                                const target = SelectorEngine.getElementFromSelector(child);
                                if (!target) {
                                    return;
                                }
                                this._setAttributeIfNotExists(target, "role", "tabpanel");
                                if (child.id) {
                                    this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
                                }
                            }
                            _toggleDropDown(element, open) {
                                const outerElem = this._getOuterElement(element);
                                if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
                                    return;
                                }
                                const toggle = (selector, className)=>{
                                    const element2 = SelectorEngine.findOne(selector, outerElem);
                                    if (element2) {
                                        element2.classList.toggle(className, open);
                                    }
                                };
                                toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
                                toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
                                outerElem.setAttribute("aria-expanded", open);
                            }
                            _setAttributeIfNotExists(element, attribute, value) {
                                if (!element.hasAttribute(attribute)) {
                                    element.setAttribute(attribute, value);
                                }
                            }
                            _elemIsActive(elem) {
                                return elem.classList.contains(CLASS_NAME_ACTIVE);
                            }
                            _getInnerElement(elem) {
                                return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
                            }
                            _getOuterElement(elem) {
                                return elem.closest(SELECTOR_OUTER) || elem;
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Tab.getOrCreateInstance(this);
                                    if (typeof config2 !== "string") {
                                        return;
                                    }
                                    if (data[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
                                        throw new TypeError(`No method named "${config2}"`);
                                    }
                                    data[config2]();
                                });
                            }
                        }
                        EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
                            if ([
                                "A",
                                "AREA"
                            ].includes(this.tagName)) {
                                event.preventDefault();
                            }
                            if (isDisabled(this)) {
                                return;
                            }
                            Tab.getOrCreateInstance(this).show();
                        });
                        EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{
                            for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)){
                                Tab.getOrCreateInstance(element);
                            }
                        });
                        defineJQueryPlugin(Tab);
                        const NAME = "toast";
                        const DATA_KEY = "bs.toast";
                        const EVENT_KEY = `.${DATA_KEY}`;
                        const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
                        const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
                        const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
                        const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
                        const EVENT_HIDE = `hide${EVENT_KEY}`;
                        const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
                        const EVENT_SHOW = `show${EVENT_KEY}`;
                        const EVENT_SHOWN = `shown${EVENT_KEY}`;
                        const CLASS_NAME_FADE = "fade";
                        const CLASS_NAME_HIDE = "hide";
                        const CLASS_NAME_SHOW = "show";
                        const CLASS_NAME_SHOWING = "showing";
                        const DefaultType = {
                            animation: "boolean",
                            autohide: "boolean",
                            delay: "number"
                        };
                        const Default = {
                            animation: true,
                            autohide: true,
                            delay: 5e3
                        };
                        class Toast extends BaseComponent {
                            constructor(element, config2){
                                super(element, config2);
                                this._timeout = null;
                                this._hasMouseInteraction = false;
                                this._hasKeyboardInteraction = false;
                                this._setListeners();
                            }
                            static get Default() {
                                return Default;
                            }
                            static get DefaultType() {
                                return DefaultType;
                            }
                            static get NAME() {
                                return NAME;
                            }
                            show() {
                                const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
                                if (showEvent.defaultPrevented) {
                                    return;
                                }
                                this._clearTimeout();
                                if (this._config.animation) {
                                    this._element.classList.add(CLASS_NAME_FADE);
                                }
                                const complete = ()=>{
                                    this._element.classList.remove(CLASS_NAME_SHOWING);
                                    EventHandler.trigger(this._element, EVENT_SHOWN);
                                    this._maybeScheduleHide();
                                };
                                this._element.classList.remove(CLASS_NAME_HIDE);
                                reflow(this._element);
                                this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
                                this._queueCallback(complete, this._element, this._config.animation);
                            }
                            hide() {
                                if (!this.isShown()) {
                                    return;
                                }
                                const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
                                if (hideEvent.defaultPrevented) {
                                    return;
                                }
                                const complete = ()=>{
                                    this._element.classList.add(CLASS_NAME_HIDE);
                                    this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
                                    EventHandler.trigger(this._element, EVENT_HIDDEN);
                                };
                                this._element.classList.add(CLASS_NAME_SHOWING);
                                this._queueCallback(complete, this._element, this._config.animation);
                            }
                            dispose() {
                                this._clearTimeout();
                                if (this.isShown()) {
                                    this._element.classList.remove(CLASS_NAME_SHOW);
                                }
                                super.dispose();
                            }
                            isShown() {
                                return this._element.classList.contains(CLASS_NAME_SHOW);
                            }
                            _maybeScheduleHide() {
                                if (!this._config.autohide) {
                                    return;
                                }
                                if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
                                    return;
                                }
                                this._timeout = setTimeout(()=>{
                                    this.hide();
                                }, this._config.delay);
                            }
                            _onInteraction(event, isInteracting) {
                                switch(event.type){
                                    case "mouseover":
                                    case "mouseout":
                                        {
                                            this._hasMouseInteraction = isInteracting;
                                            break;
                                        }
                                    case "focusin":
                                    case "focusout":
                                        {
                                            this._hasKeyboardInteraction = isInteracting;
                                            break;
                                        }
                                }
                                if (isInteracting) {
                                    this._clearTimeout();
                                    return;
                                }
                                const nextElement = event.relatedTarget;
                                if (this._element === nextElement || this._element.contains(nextElement)) {
                                    return;
                                }
                                this._maybeScheduleHide();
                            }
                            _setListeners() {
                                EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));
                                EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));
                                EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));
                                EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));
                            }
                            _clearTimeout() {
                                clearTimeout(this._timeout);
                                this._timeout = null;
                            }
                            static jQueryInterface(config2) {
                                return this.each(function() {
                                    const data = Toast.getOrCreateInstance(this, config2);
                                    if (typeof config2 === "string") {
                                        if (typeof data[config2] === "undefined") {
                                            throw new TypeError(`No method named "${config2}"`);
                                        }
                                        data[config2](this);
                                    }
                                });
                            }
                        }
                        enableDismissTrigger(Toast);
                        defineJQueryPlugin(Toast);
                        const index_umd = {
                            Alert,
                            Button,
                            Carousel,
                            Collapse,
                            Dropdown,
                            Modal,
                            Offcanvas,
                            Popover,
                            ScrollSpy,
                            Tab,
                            Toast,
                            Tooltip
                        };
                        return index_umd;
                    }));
                })(bootstrap$1);
                return bootstrap$1.exports;
            }
            requireBootstrap();
            function bind(fn, thisArg) {
                return function wrap() {
                    return fn.apply(thisArg, arguments);
                };
            }
            const { toString } = Object.prototype;
            const { getPrototypeOf } = Object;
            const { iterator, toStringTag } = Symbol;
            const kindOf = ((cache)=>(thing)=>{
                    const str = toString.call(thing);
                    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
                })(Object.create(null));
            const kindOfTest = (type)=>{
                type = type.toLowerCase();
                return (thing)=>kindOf(thing) === type;
            };
            const typeOfTest = (type)=>(thing)=>typeof thing === type;
            const { isArray } = Array;
            const isUndefined = typeOfTest("undefined");
            function isBuffer(val) {
                return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
            }
            const isArrayBuffer = kindOfTest("ArrayBuffer");
            function isArrayBufferView(val) {
                let result;
                if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                    result = ArrayBuffer.isView(val);
                } else {
                    result = val && val.buffer && isArrayBuffer(val.buffer);
                }
                return result;
            }
            const isString = typeOfTest("string");
            const isFunction$1 = typeOfTest("function");
            const isNumber = typeOfTest("number");
            const isObject = (thing)=>thing !== null && typeof thing === "object";
            const isBoolean = (thing)=>thing === true || thing === false;
            const isPlainObject = (val)=>{
                if (kindOf(val) !== "object") {
                    return false;
                }
                const prototype2 = getPrototypeOf(val);
                return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
            };
            const isEmptyObject = (val)=>{
                if (!isObject(val) || isBuffer(val)) {
                    return false;
                }
                try {
                    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
                } catch (e) {
                    return false;
                }
            };
            const isDate = kindOfTest("Date");
            const isFile = kindOfTest("File");
            const isBlob = kindOfTest("Blob");
            const isFileList = kindOfTest("FileList");
            const isStream = (val)=>isObject(val) && isFunction$1(val.pipe);
            const isFormData = (thing)=>{
                let kind;
                return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
            };
            const isURLSearchParams = kindOfTest("URLSearchParams");
            const [isReadableStream, isRequest, isResponse, isHeaders] = [
                "ReadableStream",
                "Request",
                "Response",
                "Headers"
            ].map(kindOfTest);
            const trim = (str)=>str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
            function forEach(obj, fn, { allOwnKeys = false } = {}) {
                if (obj === null || typeof obj === "undefined") {
                    return;
                }
                let i;
                let l;
                if (typeof obj !== "object") {
                    obj = [
                        obj
                    ];
                }
                if (isArray(obj)) {
                    for(i = 0, l = obj.length; i < l; i++){
                        fn.call(null, obj[i], i, obj);
                    }
                } else {
                    if (isBuffer(obj)) {
                        return;
                    }
                    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
                    const len = keys.length;
                    let key;
                    for(i = 0; i < len; i++){
                        key = keys[i];
                        fn.call(null, obj[key], key, obj);
                    }
                }
            }
            function findKey(obj, key) {
                if (isBuffer(obj)) {
                    return null;
                }
                key = key.toLowerCase();
                const keys = Object.keys(obj);
                let i = keys.length;
                let _key;
                while(i-- > 0){
                    _key = keys[i];
                    if (key === _key.toLowerCase()) {
                        return _key;
                    }
                }
                return null;
            }
            const _global = (()=>{
                if (typeof globalThis !== "undefined") return globalThis;
                return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
            })();
            const isContextDefined = (context)=>!isUndefined(context) && context !== _global;
            function merge() {
                const { caseless, skipUndefined } = isContextDefined(this) && this || {};
                const result = {};
                const assignValue = (val, key)=>{
                    const targetKey = caseless && findKey(result, key) || key;
                    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
                        result[targetKey] = merge(result[targetKey], val);
                    } else if (isPlainObject(val)) {
                        result[targetKey] = merge({}, val);
                    } else if (isArray(val)) {
                        result[targetKey] = val.slice();
                    } else if (!skipUndefined || !isUndefined(val)) {
                        result[targetKey] = val;
                    }
                };
                for(let i = 0, l = arguments.length; i < l; i++){
                    arguments[i] && forEach(arguments[i], assignValue);
                }
                return result;
            }
            const extend = (a, b, thisArg, { allOwnKeys } = {})=>{
                forEach(b, (val, key)=>{
                    if (thisArg && isFunction$1(val)) {
                        a[key] = bind(val, thisArg);
                    } else {
                        a[key] = val;
                    }
                }, {
                    allOwnKeys
                });
                return a;
            };
            const stripBOM = (content)=>{
                if (content.charCodeAt(0) === 65279) {
                    content = content.slice(1);
                }
                return content;
            };
            const inherits = (constructor, superConstructor, props, descriptors2)=>{
                constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
                constructor.prototype.constructor = constructor;
                Object.defineProperty(constructor, "super", {
                    value: superConstructor.prototype
                });
                props && Object.assign(constructor.prototype, props);
            };
            const toFlatObject = (sourceObj, destObj, filter, propFilter)=>{
                let props;
                let i;
                let prop;
                const merged = {};
                destObj = destObj || {};
                if (sourceObj == null) return destObj;
                do {
                    props = Object.getOwnPropertyNames(sourceObj);
                    i = props.length;
                    while(i-- > 0){
                        prop = props[i];
                        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                            destObj[prop] = sourceObj[prop];
                            merged[prop] = true;
                        }
                    }
                    sourceObj = filter !== false && getPrototypeOf(sourceObj);
                }while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype)
                return destObj;
            };
            const endsWith = (str, searchString, position)=>{
                str = String(str);
                if (position === void 0 || position > str.length) {
                    position = str.length;
                }
                position -= searchString.length;
                const lastIndex = str.indexOf(searchString, position);
                return lastIndex !== -1 && lastIndex === position;
            };
            const toArray = (thing)=>{
                if (!thing) return null;
                if (isArray(thing)) return thing;
                let i = thing.length;
                if (!isNumber(i)) return null;
                const arr = new Array(i);
                while(i-- > 0){
                    arr[i] = thing[i];
                }
                return arr;
            };
            const isTypedArray = ((TypedArray)=>{
                return (thing)=>{
                    return TypedArray && thing instanceof TypedArray;
                };
            })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
            const forEachEntry = (obj, fn)=>{
                const generator = obj && obj[iterator];
                const _iterator = generator.call(obj);
                let result;
                while((result = _iterator.next()) && !result.done){
                    const pair = result.value;
                    fn.call(obj, pair[0], pair[1]);
                }
            };
            const matchAll = (regExp, str)=>{
                let matches;
                const arr = [];
                while((matches = regExp.exec(str)) !== null){
                    arr.push(matches);
                }
                return arr;
            };
            const isHTMLForm = kindOfTest("HTMLFormElement");
            const toCamelCase = (str)=>{
                return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer2(m, p1, p2) {
                    return p1.toUpperCase() + p2;
                });
            };
            const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 })=>(obj, prop)=>hasOwnProperty2.call(obj, prop))(Object.prototype);
            const isRegExp = kindOfTest("RegExp");
            const reduceDescriptors = (obj, reducer)=>{
                const descriptors2 = Object.getOwnPropertyDescriptors(obj);
                const reducedDescriptors = {};
                forEach(descriptors2, (descriptor, name)=>{
                    let ret;
                    if ((ret = reducer(descriptor, name, obj)) !== false) {
                        reducedDescriptors[name] = ret || descriptor;
                    }
                });
                Object.defineProperties(obj, reducedDescriptors);
            };
            const freezeMethods = (obj)=>{
                reduceDescriptors(obj, (descriptor, name)=>{
                    if (isFunction$1(obj) && [
                        "arguments",
                        "caller",
                        "callee"
                    ].indexOf(name) !== -1) {
                        return false;
                    }
                    const value = obj[name];
                    if (!isFunction$1(value)) return;
                    descriptor.enumerable = false;
                    if ("writable" in descriptor) {
                        descriptor.writable = false;
                        return;
                    }
                    if (!descriptor.set) {
                        descriptor.set = ()=>{
                            throw Error("Can not rewrite read-only method '" + name + "'");
                        };
                    }
                });
            };
            const toObjectSet = (arrayOrString, delimiter)=>{
                const obj = {};
                const define = (arr)=>{
                    arr.forEach((value)=>{
                        obj[value] = true;
                    });
                };
                isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
                return obj;
            };
            const noop = ()=>{};
            const toFiniteNumber = (value, defaultValue)=>{
                return value != null && Number.isFinite(value = +value) ? value : defaultValue;
            };
            function isSpecCompliantForm(thing) {
                return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
            }
            const toJSONObject = (obj)=>{
                const stack2 = new Array(10);
                const visit = (source, i)=>{
                    if (isObject(source)) {
                        if (stack2.indexOf(source) >= 0) {
                            return;
                        }
                        if (isBuffer(source)) {
                            return source;
                        }
                        if (!("toJSON" in source)) {
                            stack2[i] = source;
                            const target = isArray(source) ? [] : {};
                            forEach(source, (value, key)=>{
                                const reducedValue = visit(value, i + 1);
                                !isUndefined(reducedValue) && (target[key] = reducedValue);
                            });
                            stack2[i] = void 0;
                            return target;
                        }
                    }
                    return source;
                };
                return visit(obj, 0);
            };
            const isAsyncFn = kindOfTest("AsyncFunction");
            const isThenable = (thing)=>thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
            const _setImmediate = ((setImmediateSupported, postMessageSupported)=>{
                if (setImmediateSupported) {
                    return setImmediate;
                }
                return postMessageSupported ? ((token, callbacks)=>{
                    _global.addEventListener("message", ({ source, data })=>{
                        if (source === _global && data === token) {
                            callbacks.length && callbacks.shift()();
                        }
                    }, false);
                    return (cb)=>{
                        callbacks.push(cb);
                        _global.postMessage(token, "*");
                    };
                })(`axios@${Math.random()}`, []) : (cb)=>setTimeout(cb);
            })(typeof setImmediate === "function", isFunction$1(_global.postMessage));
            const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
            const isIterable = (thing)=>thing != null && isFunction$1(thing[iterator]);
            const utils$1 = {
                isArray,
                isArrayBuffer,
                isBuffer,
                isFormData,
                isArrayBufferView,
                isString,
                isNumber,
                isBoolean,
                isObject,
                isPlainObject,
                isEmptyObject,
                isReadableStream,
                isRequest,
                isResponse,
                isHeaders,
                isUndefined,
                isDate,
                isFile,
                isBlob,
                isRegExp,
                isFunction: isFunction$1,
                isStream,
                isURLSearchParams,
                isTypedArray,
                isFileList,
                forEach,
                merge,
                extend,
                trim,
                stripBOM,
                inherits,
                toFlatObject,
                kindOf,
                kindOfTest,
                endsWith,
                toArray,
                forEachEntry,
                matchAll,
                isHTMLForm,
                hasOwnProperty,
                hasOwnProp: hasOwnProperty,
                reduceDescriptors,
                freezeMethods,
                toObjectSet,
                toCamelCase,
                noop,
                toFiniteNumber,
                findKey,
                global: _global,
                isContextDefined,
                isSpecCompliantForm,
                toJSONObject,
                isAsyncFn,
                isThenable,
                setImmediate: _setImmediate,
                asap,
                isIterable
            };
            function AxiosError$1(message, code, config2, request, response) {
                Error.call(this);
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, this.constructor);
                } else {
                    this.stack = new Error().stack;
                }
                this.message = message;
                this.name = "AxiosError";
                code && (this.code = code);
                config2 && (this.config = config2);
                request && (this.request = request);
                if (response) {
                    this.response = response;
                    this.status = response.status ? response.status : null;
                }
            }
            utils$1.inherits(AxiosError$1, Error, {
                toJSON: function toJSON() {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: utils$1.toJSONObject(this.config),
                        code: this.code,
                        status: this.status
                    };
                }
            });
            const prototype$1 = AxiosError$1.prototype;
            const descriptors = {};
            [
                "ERR_BAD_OPTION_VALUE",
                "ERR_BAD_OPTION",
                "ECONNABORTED",
                "ETIMEDOUT",
                "ERR_NETWORK",
                "ERR_FR_TOO_MANY_REDIRECTS",
                "ERR_DEPRECATED",
                "ERR_BAD_RESPONSE",
                "ERR_BAD_REQUEST",
                "ERR_CANCELED",
                "ERR_NOT_SUPPORT",
                "ERR_INVALID_URL"
            ].forEach((code)=>{
                descriptors[code] = {
                    value: code
                };
            });
            Object.defineProperties(AxiosError$1, descriptors);
            Object.defineProperty(prototype$1, "isAxiosError", {
                value: true
            });
            AxiosError$1.from = (error, code, config2, request, response, customProps)=>{
                const axiosError = Object.create(prototype$1);
                utils$1.toFlatObject(error, axiosError, function filter(obj) {
                    return obj !== Error.prototype;
                }, (prop)=>{
                    return prop !== "isAxiosError";
                });
                const msg = error && error.message ? error.message : "Error";
                const errCode = code == null && error ? error.code : code;
                AxiosError$1.call(axiosError, msg, errCode, config2, request, response);
                if (error && axiosError.cause == null) {
                    Object.defineProperty(axiosError, "cause", {
                        value: error,
                        configurable: true
                    });
                }
                axiosError.name = error && error.name || "Error";
                customProps && Object.assign(axiosError, customProps);
                return axiosError;
            };
            const httpAdapter = null;
            function isVisitable(thing) {
                return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
            }
            function removeBrackets(key) {
                return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
            }
            function renderKey(path, key, dots) {
                if (!path) return key;
                return path.concat(key).map(function each(token, i) {
                    token = removeBrackets(token);
                    return !dots && i ? "[" + token + "]" : token;
                }).join(dots ? "." : "");
            }
            function isFlatArray(arr) {
                return utils$1.isArray(arr) && !arr.some(isVisitable);
            }
            const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
                return /^is[A-Z]/.test(prop);
            });
            function toFormData$1(obj, formData, options) {
                if (!utils$1.isObject(obj)) {
                    throw new TypeError("target must be an object");
                }
                formData = formData || new FormData();
                options = utils$1.toFlatObject(options, {
                    metaTokens: true,
                    dots: false,
                    indexes: false
                }, false, function defined(option, source) {
                    return !utils$1.isUndefined(source[option]);
                });
                const metaTokens = options.metaTokens;
                const visitor = options.visitor || defaultVisitor;
                const dots = options.dots;
                const indexes = options.indexes;
                const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
                const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
                if (!utils$1.isFunction(visitor)) {
                    throw new TypeError("visitor must be a function");
                }
                function convertValue(value) {
                    if (value === null) return "";
                    if (utils$1.isDate(value)) {
                        return value.toISOString();
                    }
                    if (utils$1.isBoolean(value)) {
                        return value.toString();
                    }
                    if (!useBlob && utils$1.isBlob(value)) {
                        throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
                    }
                    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
                        return useBlob && typeof Blob === "function" ? new Blob([
                            value
                        ]) : Buffer.from(value);
                    }
                    return value;
                }
                function defaultVisitor(value, key, path) {
                    let arr = value;
                    if (value && !path && typeof value === "object") {
                        if (utils$1.endsWith(key, "{}")) {
                            key = metaTokens ? key : key.slice(0, -2);
                            value = JSON.stringify(value);
                        } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
                            key = removeBrackets(key);
                            arr.forEach(function each(el, index) {
                                !(utils$1.isUndefined(el) || el === null) && formData.append(indexes === true ? renderKey([
                                    key
                                ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                            });
                            return false;
                        }
                    }
                    if (isVisitable(value)) {
                        return true;
                    }
                    formData.append(renderKey(path, key, dots), convertValue(value));
                    return false;
                }
                const stack2 = [];
                const exposedHelpers = Object.assign(predicates, {
                    defaultVisitor,
                    convertValue,
                    isVisitable
                });
                function build2(value, path) {
                    if (utils$1.isUndefined(value)) return;
                    if (stack2.indexOf(value) !== -1) {
                        throw Error("Circular reference detected in " + path.join("."));
                    }
                    stack2.push(value);
                    utils$1.forEach(value, function each(el, key) {
                        const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers);
                        if (result === true) {
                            build2(el, path ? path.concat(key) : [
                                key
                            ]);
                        }
                    });
                    stack2.pop();
                }
                if (!utils$1.isObject(obj)) {
                    throw new TypeError("data must be an object");
                }
                build2(obj);
                return formData;
            }
            function encode$1(str) {
                const charMap = {
                    "!": "%21",
                    "'": "%27",
                    "(": "%28",
                    ")": "%29",
                    "~": "%7E",
                    "%20": "+",
                    "%00": "\0"
                };
                return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
                    return charMap[match];
                });
            }
            function AxiosURLSearchParams(params, options) {
                this._pairs = [];
                params && toFormData$1(params, this, options);
            }
            const prototype = AxiosURLSearchParams.prototype;
            prototype.append = function append(name, value) {
                this._pairs.push([
                    name,
                    value
                ]);
            };
            prototype.toString = function toString2(encoder) {
                const _encode = encoder ? function(value) {
                    return encoder.call(this, value, encode$1);
                } : encode$1;
                return this._pairs.map(function each(pair) {
                    return _encode(pair[0]) + "=" + _encode(pair[1]);
                }, "").join("&");
            };
            function encode(val) {
                return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
            }
            function buildURL(url, params, options) {
                if (!params) {
                    return url;
                }
                const _encode = options && options.encode || encode;
                if (utils$1.isFunction(options)) {
                    options = {
                        serialize: options
                    };
                }
                const serializeFn = options && options.serialize;
                let serializedParams;
                if (serializeFn) {
                    serializedParams = serializeFn(params, options);
                } else {
                    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
                }
                if (serializedParams) {
                    const hashmarkIndex = url.indexOf("#");
                    if (hashmarkIndex !== -1) {
                        url = url.slice(0, hashmarkIndex);
                    }
                    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
                }
                return url;
            }
            class InterceptorManager {
                constructor(){
                    this.handlers = [];
                }
                use(fulfilled, rejected, options) {
                    this.handlers.push({
                        fulfilled,
                        rejected,
                        synchronous: options ? options.synchronous : false,
                        runWhen: options ? options.runWhen : null
                    });
                    return this.handlers.length - 1;
                }
                eject(id) {
                    if (this.handlers[id]) {
                        this.handlers[id] = null;
                    }
                }
                clear() {
                    if (this.handlers) {
                        this.handlers = [];
                    }
                }
                forEach(fn) {
                    utils$1.forEach(this.handlers, function forEachHandler(h2) {
                        if (h2 !== null) {
                            fn(h2);
                        }
                    });
                }
            }
            const transitionalDefaults = {
                silentJSONParsing: true,
                forcedJSONParsing: true,
                clarifyTimeoutError: false
            };
            const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
            const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
            const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
            const platform$1 = {
                isBrowser: true,
                classes: {
                    URLSearchParams: URLSearchParams$1,
                    FormData: FormData$1,
                    Blob: Blob$1
                },
                protocols: [
                    "http",
                    "https",
                    "file",
                    "blob",
                    "url",
                    "data"
                ]
            };
            const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
            const _navigator = typeof navigator === "object" && navigator || void 0;
            const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [
                "ReactNative",
                "NativeScript",
                "NS"
            ].indexOf(_navigator.product) < 0);
            const hasStandardBrowserWebWorkerEnv = (()=>{
                return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
            })();
            const origin = hasBrowserEnv && window.location.href || "http://localhost";
            const utils = Object.freeze(Object.defineProperty({
                __proto__: null,
                hasBrowserEnv,
                hasStandardBrowserEnv,
                hasStandardBrowserWebWorkerEnv,
                navigator: _navigator,
                origin
            }, Symbol.toStringTag, {
                value: "Module"
            }));
            const platform = {
                ...utils,
                ...platform$1
            };
            function toURLEncodedForm(data, options) {
                return toFormData$1(data, new platform.classes.URLSearchParams(), {
                    visitor: function(value, key, path, helpers) {
                        if (platform.isNode && utils$1.isBuffer(value)) {
                            this.append(key, value.toString("base64"));
                            return false;
                        }
                        return helpers.defaultVisitor.apply(this, arguments);
                    },
                    ...options
                });
            }
            function parsePropPath(name) {
                return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match)=>{
                    return match[0] === "[]" ? "" : match[1] || match[0];
                });
            }
            function arrayToObject(arr) {
                const obj = {};
                const keys = Object.keys(arr);
                let i;
                const len = keys.length;
                let key;
                for(i = 0; i < len; i++){
                    key = keys[i];
                    obj[key] = arr[key];
                }
                return obj;
            }
            function formDataToJSON(formData) {
                function buildPath(path, value, target, index) {
                    let name = path[index++];
                    if (name === "__proto__") return true;
                    const isNumericKey = Number.isFinite(+name);
                    const isLast = index >= path.length;
                    name = !name && utils$1.isArray(target) ? target.length : name;
                    if (isLast) {
                        if (utils$1.hasOwnProp(target, name)) {
                            target[name] = [
                                target[name],
                                value
                            ];
                        } else {
                            target[name] = value;
                        }
                        return !isNumericKey;
                    }
                    if (!target[name] || !utils$1.isObject(target[name])) {
                        target[name] = [];
                    }
                    const result = buildPath(path, value, target[name], index);
                    if (result && utils$1.isArray(target[name])) {
                        target[name] = arrayToObject(target[name]);
                    }
                    return !isNumericKey;
                }
                if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
                    const obj = {};
                    utils$1.forEachEntry(formData, (name, value)=>{
                        buildPath(parsePropPath(name), value, obj, 0);
                    });
                    return obj;
                }
                return null;
            }
            function stringifySafely(rawValue, parser, encoder) {
                if (utils$1.isString(rawValue)) {
                    try {
                        (parser || JSON.parse)(rawValue);
                        return utils$1.trim(rawValue);
                    } catch (e) {
                        if (e.name !== "SyntaxError") {
                            throw e;
                        }
                    }
                }
                return (encoder || JSON.stringify)(rawValue);
            }
            const defaults = {
                transitional: transitionalDefaults,
                adapter: [
                    "xhr",
                    "http",
                    "fetch"
                ],
                transformRequest: [
                    function transformRequest(data, headers) {
                        const contentType = headers.getContentType() || "";
                        const hasJSONContentType = contentType.indexOf("application/json") > -1;
                        const isObjectPayload = utils$1.isObject(data);
                        if (isObjectPayload && utils$1.isHTMLForm(data)) {
                            data = new FormData(data);
                        }
                        const isFormData2 = utils$1.isFormData(data);
                        if (isFormData2) {
                            return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
                        }
                        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
                            return data;
                        }
                        if (utils$1.isArrayBufferView(data)) {
                            return data.buffer;
                        }
                        if (utils$1.isURLSearchParams(data)) {
                            headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                            return data.toString();
                        }
                        let isFileList2;
                        if (isObjectPayload) {
                            if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
                                return toURLEncodedForm(data, this.formSerializer).toString();
                            }
                            if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                                const _FormData = this.env && this.env.FormData;
                                return toFormData$1(isFileList2 ? {
                                    "files[]": data
                                } : data, _FormData && new _FormData(), this.formSerializer);
                            }
                        }
                        if (isObjectPayload || hasJSONContentType) {
                            headers.setContentType("application/json", false);
                            return stringifySafely(data);
                        }
                        return data;
                    }
                ],
                transformResponse: [
                    function transformResponse(data) {
                        const transitional = this.transitional || defaults.transitional;
                        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
                        const JSONRequested = this.responseType === "json";
                        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
                            return data;
                        }
                        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                            const silentJSONParsing = transitional && transitional.silentJSONParsing;
                            const strictJSONParsing = !silentJSONParsing && JSONRequested;
                            try {
                                return JSON.parse(data, this.parseReviver);
                            } catch (e) {
                                if (strictJSONParsing) {
                                    if (e.name === "SyntaxError") {
                                        throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
                                    }
                                    throw e;
                                }
                            }
                        }
                        return data;
                    }
                ],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {
                    FormData: platform.classes.FormData,
                    Blob: platform.classes.Blob
                },
                validateStatus: function validateStatus(status) {
                    return status >= 200 && status < 300;
                },
                headers: {
                    common: {
                        "Accept": "application/json, text/plain, */*",
                        "Content-Type": void 0
                    }
                }
            };
            utils$1.forEach([
                "delete",
                "get",
                "head",
                "post",
                "put",
                "patch"
            ], (method)=>{
                defaults.headers[method] = {};
            });
            const ignoreDuplicateOf = utils$1.toObjectSet([
                "age",
                "authorization",
                "content-length",
                "content-type",
                "etag",
                "expires",
                "from",
                "host",
                "if-modified-since",
                "if-unmodified-since",
                "last-modified",
                "location",
                "max-forwards",
                "proxy-authorization",
                "referer",
                "retry-after",
                "user-agent"
            ]);
            const parseHeaders = (rawHeaders)=>{
                const parsed = {};
                let key;
                let val;
                let i;
                rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
                    i = line.indexOf(":");
                    key = line.substring(0, i).trim().toLowerCase();
                    val = line.substring(i + 1).trim();
                    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
                        return;
                    }
                    if (key === "set-cookie") {
                        if (parsed[key]) {
                            parsed[key].push(val);
                        } else {
                            parsed[key] = [
                                val
                            ];
                        }
                    } else {
                        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                    }
                });
                return parsed;
            };
            const $internals = Symbol("internals");
            function normalizeHeader(header) {
                return header && String(header).trim().toLowerCase();
            }
            function normalizeValue(value) {
                if (value === false || value == null) {
                    return value;
                }
                return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
            }
            function parseTokens(str) {
                const tokens = Object.create(null);
                const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                let match;
                while(match = tokensRE.exec(str)){
                    tokens[match[1]] = match[2];
                }
                return tokens;
            }
            const isValidHeaderName = (str)=>/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
            function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
                if (utils$1.isFunction(filter)) {
                    return filter.call(this, value, header);
                }
                if (isHeaderNameFilter) {
                    value = header;
                }
                if (!utils$1.isString(value)) return;
                if (utils$1.isString(filter)) {
                    return value.indexOf(filter) !== -1;
                }
                if (utils$1.isRegExp(filter)) {
                    return filter.test(value);
                }
            }
            function formatHeader(header) {
                return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str)=>{
                    return char.toUpperCase() + str;
                });
            }
            function buildAccessors(obj, header) {
                const accessorName = utils$1.toCamelCase(" " + header);
                [
                    "get",
                    "set",
                    "has"
                ].forEach((methodName)=>{
                    Object.defineProperty(obj, methodName + accessorName, {
                        value: function(arg1, arg2, arg3) {
                            return this[methodName].call(this, header, arg1, arg2, arg3);
                        },
                        configurable: true
                    });
                });
            }
            let AxiosHeaders$1 = class AxiosHeaders {
                constructor(headers){
                    headers && this.set(headers);
                }
                set(header, valueOrRewrite, rewrite) {
                    const self2 = this;
                    function setHeader(_value, _header, _rewrite) {
                        const lHeader = normalizeHeader(_header);
                        if (!lHeader) {
                            throw new Error("header name must be a non-empty string");
                        }
                        const key = utils$1.findKey(self2, lHeader);
                        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
                            self2[key || _header] = normalizeValue(_value);
                        }
                    }
                    const setHeaders = (headers, _rewrite)=>utils$1.forEach(headers, (_value, _header)=>setHeader(_value, _header, _rewrite));
                    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
                        setHeaders(header, valueOrRewrite);
                    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
                        setHeaders(parseHeaders(header), valueOrRewrite);
                    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
                        let obj = {}, dest, key;
                        for (const entry of header){
                            if (!utils$1.isArray(entry)) {
                                throw TypeError("Object iterator must return a key-value pair");
                            }
                            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [
                                ...dest,
                                entry[1]
                            ] : [
                                dest,
                                entry[1]
                            ] : entry[1];
                        }
                        setHeaders(obj, valueOrRewrite);
                    } else {
                        header != null && setHeader(valueOrRewrite, header, rewrite);
                    }
                    return this;
                }
                get(header, parser) {
                    header = normalizeHeader(header);
                    if (header) {
                        const key = utils$1.findKey(this, header);
                        if (key) {
                            const value = this[key];
                            if (!parser) {
                                return value;
                            }
                            if (parser === true) {
                                return parseTokens(value);
                            }
                            if (utils$1.isFunction(parser)) {
                                return parser.call(this, value, key);
                            }
                            if (utils$1.isRegExp(parser)) {
                                return parser.exec(value);
                            }
                            throw new TypeError("parser must be boolean|regexp|function");
                        }
                    }
                }
                has(header, matcher) {
                    header = normalizeHeader(header);
                    if (header) {
                        const key = utils$1.findKey(this, header);
                        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
                    }
                    return false;
                }
                delete(header, matcher) {
                    const self2 = this;
                    let deleted = false;
                    function deleteHeader(_header) {
                        _header = normalizeHeader(_header);
                        if (_header) {
                            const key = utils$1.findKey(self2, _header);
                            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                                delete self2[key];
                                deleted = true;
                            }
                        }
                    }
                    if (utils$1.isArray(header)) {
                        header.forEach(deleteHeader);
                    } else {
                        deleteHeader(header);
                    }
                    return deleted;
                }
                clear(matcher) {
                    const keys = Object.keys(this);
                    let i = keys.length;
                    let deleted = false;
                    while(i--){
                        const key = keys[i];
                        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                            delete this[key];
                            deleted = true;
                        }
                    }
                    return deleted;
                }
                normalize(format) {
                    const self2 = this;
                    const headers = {};
                    utils$1.forEach(this, (value, header)=>{
                        const key = utils$1.findKey(headers, header);
                        if (key) {
                            self2[key] = normalizeValue(value);
                            delete self2[header];
                            return;
                        }
                        const normalized = format ? formatHeader(header) : String(header).trim();
                        if (normalized !== header) {
                            delete self2[header];
                        }
                        self2[normalized] = normalizeValue(value);
                        headers[normalized] = true;
                    });
                    return this;
                }
                concat(...targets) {
                    return this.constructor.concat(this, ...targets);
                }
                toJSON(asStrings) {
                    const obj = Object.create(null);
                    utils$1.forEach(this, (value, header)=>{
                        value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
                    });
                    return obj;
                }
                [Symbol.iterator]() {
                    return Object.entries(this.toJSON())[Symbol.iterator]();
                }
                toString() {
                    return Object.entries(this.toJSON()).map(([header, value])=>header + ": " + value).join("\n");
                }
                getSetCookie() {
                    return this.get("set-cookie") || [];
                }
                get [Symbol.toStringTag]() {
                    return "AxiosHeaders";
                }
                static from(thing) {
                    return thing instanceof this ? thing : new this(thing);
                }
                static concat(first, ...targets) {
                    const computed2 = new this(first);
                    targets.forEach((target)=>computed2.set(target));
                    return computed2;
                }
                static accessor(header) {
                    const internals = this[$internals] = this[$internals] = {
                        accessors: {}
                    };
                    const accessors = internals.accessors;
                    const prototype2 = this.prototype;
                    function defineAccessor(_header) {
                        const lHeader = normalizeHeader(_header);
                        if (!accessors[lHeader]) {
                            buildAccessors(prototype2, _header);
                            accessors[lHeader] = true;
                        }
                    }
                    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
                    return this;
                }
            };
            AxiosHeaders$1.accessor([
                "Content-Type",
                "Content-Length",
                "Accept",
                "Accept-Encoding",
                "User-Agent",
                "Authorization"
            ]);
            utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key)=>{
                let mapped = key[0].toUpperCase() + key.slice(1);
                return {
                    get: ()=>value,
                    set (headerValue) {
                        this[mapped] = headerValue;
                    }
                };
            });
            utils$1.freezeMethods(AxiosHeaders$1);
            function transformData(fns, response) {
                const config2 = this || defaults;
                const context = response || config2;
                const headers = AxiosHeaders$1.from(context.headers);
                let data = context.data;
                utils$1.forEach(fns, function transform(fn) {
                    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
                });
                headers.normalize();
                return data;
            }
            function isCancel$1(value) {
                return !!(value && value.__CANCEL__);
            }
            function CanceledError$1(message, config2, request) {
                AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request);
                this.name = "CanceledError";
            }
            utils$1.inherits(CanceledError$1, AxiosError$1, {
                __CANCEL__: true
            });
            function settle(resolve2, reject, response) {
                const validateStatus = response.config.validateStatus;
                if (!response.status || !validateStatus || validateStatus(response.status)) {
                    resolve2(response);
                } else {
                    reject(new AxiosError$1("Request failed with status code " + response.status, [
                        AxiosError$1.ERR_BAD_REQUEST,
                        AxiosError$1.ERR_BAD_RESPONSE
                    ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
                }
            }
            function parseProtocol(url) {
                const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
                return match && match[1] || "";
            }
            function speedometer(samplesCount, min2) {
                samplesCount = samplesCount || 10;
                const bytes = new Array(samplesCount);
                const timestamps = new Array(samplesCount);
                let head = 0;
                let tail = 0;
                let firstSampleTS;
                min2 = min2 !== void 0 ? min2 : 1e3;
                return function push(chunkLength) {
                    const now = Date.now();
                    const startedAt = timestamps[tail];
                    if (!firstSampleTS) {
                        firstSampleTS = now;
                    }
                    bytes[head] = chunkLength;
                    timestamps[head] = now;
                    let i = tail;
                    let bytesCount = 0;
                    while(i !== head){
                        bytesCount += bytes[i++];
                        i = i % samplesCount;
                    }
                    head = (head + 1) % samplesCount;
                    if (head === tail) {
                        tail = (tail + 1) % samplesCount;
                    }
                    if (now - firstSampleTS < min2) {
                        return;
                    }
                    const passed = startedAt && now - startedAt;
                    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
                };
            }
            function throttle(fn, freq) {
                let timestamp = 0;
                let threshold = 1e3 / freq;
                let lastArgs;
                let timer;
                const invoke = (args, now = Date.now())=>{
                    timestamp = now;
                    lastArgs = null;
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    fn(...args);
                };
                const throttled = (...args)=>{
                    const now = Date.now();
                    const passed = now - timestamp;
                    if (passed >= threshold) {
                        invoke(args, now);
                    } else {
                        lastArgs = args;
                        if (!timer) {
                            timer = setTimeout(()=>{
                                timer = null;
                                invoke(lastArgs);
                            }, threshold - passed);
                        }
                    }
                };
                const flush = ()=>lastArgs && invoke(lastArgs);
                return [
                    throttled,
                    flush
                ];
            }
            const progressEventReducer = (listener2, isDownloadStream, freq = 3)=>{
                let bytesNotified = 0;
                const _speedometer = speedometer(50, 250);
                return throttle((e)=>{
                    const loaded2 = e.loaded;
                    const total = e.lengthComputable ? e.total : void 0;
                    const progressBytes = loaded2 - bytesNotified;
                    const rate = _speedometer(progressBytes);
                    const inRange = loaded2 <= total;
                    bytesNotified = loaded2;
                    const data = {
                        loaded: loaded2,
                        total,
                        progress: total ? loaded2 / total : void 0,
                        bytes: progressBytes,
                        rate: rate ? rate : void 0,
                        estimated: rate && total && inRange ? (total - loaded2) / rate : void 0,
                        event: e,
                        lengthComputable: total != null,
                        [isDownloadStream ? "download" : "upload"]: true
                    };
                    listener2(data);
                }, freq);
            };
            const progressEventDecorator = (total, throttled)=>{
                const lengthComputable = total != null;
                return [
                    (loaded2)=>throttled[0]({
                            lengthComputable,
                            total,
                            loaded: loaded2
                        }),
                    throttled[1]
                ];
            };
            const asyncDecorator = (fn)=>(...args)=>utils$1.asap(()=>fn(...args));
            const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE)=>(url)=>{
                    url = new URL(url, platform.origin);
                    return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
                })(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : ()=>true;
            const cookies = platform.hasStandardBrowserEnv ? ({
                write (name, value, expires, path, domain, secure) {
                    const cookie = [
                        name + "=" + encodeURIComponent(value)
                    ];
                    utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
                    utils$1.isString(path) && cookie.push("path=" + path);
                    utils$1.isString(domain) && cookie.push("domain=" + domain);
                    secure === true && cookie.push("secure");
                    document.cookie = cookie.join("; ");
                },
                read (name) {
                    const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
                    return match ? decodeURIComponent(match[3]) : null;
                },
                remove (name) {
                    this.write(name, "", Date.now() - 864e5);
                }
            }) : ({
                write () {},
                read () {
                    return null;
                },
                remove () {}
            });
            function isAbsoluteURL(url) {
                return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
            }
            function combineURLs(baseURL, relativeURL) {
                return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
            }
            function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
                let isRelativeUrl = !isAbsoluteURL(requestedURL);
                if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
                    return combineURLs(baseURL, requestedURL);
                }
                return requestedURL;
            }
            const headersToObject = (thing)=>thing instanceof AxiosHeaders$1 ? {
                    ...thing
                } : thing;
            function mergeConfig$1(config1, config2) {
                config2 = config2 || {};
                const config3 = {};
                function getMergedValue(target, source, prop, caseless) {
                    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
                        return utils$1.merge.call({
                            caseless
                        }, target, source);
                    } else if (utils$1.isPlainObject(source)) {
                        return utils$1.merge({}, source);
                    } else if (utils$1.isArray(source)) {
                        return source.slice();
                    }
                    return source;
                }
                function mergeDeepProperties(a, b, prop, caseless) {
                    if (!utils$1.isUndefined(b)) {
                        return getMergedValue(a, b, prop, caseless);
                    } else if (!utils$1.isUndefined(a)) {
                        return getMergedValue(void 0, a, prop, caseless);
                    }
                }
                function valueFromConfig2(a, b) {
                    if (!utils$1.isUndefined(b)) {
                        return getMergedValue(void 0, b);
                    }
                }
                function defaultToConfig2(a, b) {
                    if (!utils$1.isUndefined(b)) {
                        return getMergedValue(void 0, b);
                    } else if (!utils$1.isUndefined(a)) {
                        return getMergedValue(void 0, a);
                    }
                }
                function mergeDirectKeys(a, b, prop) {
                    if (prop in config2) {
                        return getMergedValue(a, b);
                    } else if (prop in config1) {
                        return getMergedValue(void 0, a);
                    }
                }
                const mergeMap = {
                    url: valueFromConfig2,
                    method: valueFromConfig2,
                    data: valueFromConfig2,
                    baseURL: defaultToConfig2,
                    transformRequest: defaultToConfig2,
                    transformResponse: defaultToConfig2,
                    paramsSerializer: defaultToConfig2,
                    timeout: defaultToConfig2,
                    timeoutMessage: defaultToConfig2,
                    withCredentials: defaultToConfig2,
                    withXSRFToken: defaultToConfig2,
                    adapter: defaultToConfig2,
                    responseType: defaultToConfig2,
                    xsrfCookieName: defaultToConfig2,
                    xsrfHeaderName: defaultToConfig2,
                    onUploadProgress: defaultToConfig2,
                    onDownloadProgress: defaultToConfig2,
                    decompress: defaultToConfig2,
                    maxContentLength: defaultToConfig2,
                    maxBodyLength: defaultToConfig2,
                    beforeRedirect: defaultToConfig2,
                    transport: defaultToConfig2,
                    httpAgent: defaultToConfig2,
                    httpsAgent: defaultToConfig2,
                    cancelToken: defaultToConfig2,
                    socketPath: defaultToConfig2,
                    responseEncoding: defaultToConfig2,
                    validateStatus: mergeDirectKeys,
                    headers: (a, b, prop)=>mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
                };
                utils$1.forEach(Object.keys({
                    ...config1,
                    ...config2
                }), function computeConfigValue(prop) {
                    const merge2 = mergeMap[prop] || mergeDeepProperties;
                    const configValue = merge2(config1[prop], config2[prop], prop);
                    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
                });
                return config3;
            }
            const resolveConfig = (config2)=>{
                const newConfig = mergeConfig$1({}, config2);
                let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
                newConfig.headers = headers = AxiosHeaders$1.from(headers);
                newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
                if (auth) {
                    headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
                }
                if (utils$1.isFormData(data)) {
                    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
                        headers.setContentType(void 0);
                    } else if (utils$1.isFunction(data.getHeaders)) {
                        const formHeaders = data.getHeaders();
                        const allowedHeaders = [
                            "content-type",
                            "content-length"
                        ];
                        Object.entries(formHeaders).forEach(([key, val])=>{
                            if (allowedHeaders.includes(key.toLowerCase())) {
                                headers.set(key, val);
                            }
                        });
                    }
                }
                if (platform.hasStandardBrowserEnv) {
                    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
                    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
                        const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
                        if (xsrfValue) {
                            headers.set(xsrfHeaderName, xsrfValue);
                        }
                    }
                }
                return newConfig;
            };
            const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
            const xhrAdapter = isXHRAdapterSupported && function(config2) {
                return new Promise(function dispatchXhrRequest(resolve2, reject) {
                    const _config2 = resolveConfig(config2);
                    let requestData = _config2.data;
                    const requestHeaders = AxiosHeaders$1.from(_config2.headers).normalize();
                    let { responseType, onUploadProgress, onDownloadProgress } = _config2;
                    let onCanceled;
                    let uploadThrottled, downloadThrottled;
                    let flushUpload, flushDownload;
                    function done() {
                        flushUpload && flushUpload();
                        flushDownload && flushDownload();
                        _config2.cancelToken && _config2.cancelToken.unsubscribe(onCanceled);
                        _config2.signal && _config2.signal.removeEventListener("abort", onCanceled);
                    }
                    let request = new XMLHttpRequest();
                    request.open(_config2.method.toUpperCase(), _config2.url, true);
                    request.timeout = _config2.timeout;
                    function onloadend() {
                        if (!request) {
                            return;
                        }
                        const responseHeaders = AxiosHeaders$1.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
                        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
                        const response = {
                            data: responseData,
                            status: request.status,
                            statusText: request.statusText,
                            headers: responseHeaders,
                            config: config2,
                            request
                        };
                        settle(function _resolve(value) {
                            resolve2(value);
                            done();
                        }, function _reject(err) {
                            reject(err);
                            done();
                        }, response);
                        request = null;
                    }
                    if ("onloadend" in request) {
                        request.onloadend = onloadend;
                    } else {
                        request.onreadystatechange = function handleLoad() {
                            if (!request || request.readyState !== 4) {
                                return;
                            }
                            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                                return;
                            }
                            setTimeout(onloadend);
                        };
                    }
                    request.onabort = function handleAbort() {
                        if (!request) {
                            return;
                        }
                        reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request));
                        request = null;
                    };
                    request.onerror = function handleError2(event) {
                        const msg = event && event.message ? event.message : "Network Error";
                        const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config2, request);
                        err.event = event || null;
                        reject(err);
                        request = null;
                    };
                    request.ontimeout = function handleTimeout() {
                        let timeoutErrorMessage = _config2.timeout ? "timeout of " + _config2.timeout + "ms exceeded" : "timeout exceeded";
                        const transitional = _config2.transitional || transitionalDefaults;
                        if (_config2.timeoutErrorMessage) {
                            timeoutErrorMessage = _config2.timeoutErrorMessage;
                        }
                        reject(new AxiosError$1(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config2, request));
                        request = null;
                    };
                    requestData === void 0 && requestHeaders.setContentType(null);
                    if ("setRequestHeader" in request) {
                        utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
                            request.setRequestHeader(key, val);
                        });
                    }
                    if (!utils$1.isUndefined(_config2.withCredentials)) {
                        request.withCredentials = !!_config2.withCredentials;
                    }
                    if (responseType && responseType !== "json") {
                        request.responseType = _config2.responseType;
                    }
                    if (onDownloadProgress) {
                        [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
                        request.addEventListener("progress", downloadThrottled);
                    }
                    if (onUploadProgress && request.upload) {
                        [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
                        request.upload.addEventListener("progress", uploadThrottled);
                        request.upload.addEventListener("loadend", flushUpload);
                    }
                    if (_config2.cancelToken || _config2.signal) {
                        onCanceled = (cancel)=>{
                            if (!request) {
                                return;
                            }
                            reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request) : cancel);
                            request.abort();
                            request = null;
                        };
                        _config2.cancelToken && _config2.cancelToken.subscribe(onCanceled);
                        if (_config2.signal) {
                            _config2.signal.aborted ? onCanceled() : _config2.signal.addEventListener("abort", onCanceled);
                        }
                    }
                    const protocol = parseProtocol(_config2.url);
                    if (protocol && platform.protocols.indexOf(protocol) === -1) {
                        reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
                        return;
                    }
                    request.send(requestData || null);
                });
            };
            const composeSignals = (signals, timeout)=>{
                const { length } = signals = signals ? signals.filter(Boolean) : [];
                if (timeout || length) {
                    let controller = new AbortController();
                    let aborted;
                    const onabort = function(reason) {
                        if (!aborted) {
                            aborted = true;
                            unsubscribe();
                            const err = reason instanceof Error ? reason : this.reason;
                            controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
                        }
                    };
                    let timer = timeout && setTimeout(()=>{
                        timer = null;
                        onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
                    }, timeout);
                    const unsubscribe = ()=>{
                        if (signals) {
                            timer && clearTimeout(timer);
                            timer = null;
                            signals.forEach((signal2)=>{
                                signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
                            });
                            signals = null;
                        }
                    };
                    signals.forEach((signal2)=>signal2.addEventListener("abort", onabort));
                    const { signal } = controller;
                    signal.unsubscribe = ()=>utils$1.asap(unsubscribe);
                    return signal;
                }
            };
            const streamChunk = function*(chunk, chunkSize) {
                let len = chunk.byteLength;
                if (len < chunkSize) {
                    yield chunk;
                    return;
                }
                let pos = 0;
                let end2;
                while(pos < len){
                    end2 = pos + chunkSize;
                    yield chunk.slice(pos, end2);
                    pos = end2;
                }
            };
            const readBytes = async function*(iterable, chunkSize) {
                for await (const chunk of readStream(iterable)){
                    yield* streamChunk(chunk, chunkSize);
                }
            };
            const readStream = async function*(stream) {
                if (stream[Symbol.asyncIterator]) {
                    yield* stream;
                    return;
                }
                const reader = stream.getReader();
                try {
                    for(;;){
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        yield value;
                    }
                } finally{
                    await reader.cancel();
                }
            };
            const trackStream = (stream, chunkSize, onProgress, onFinish)=>{
                const iterator2 = readBytes(stream, chunkSize);
                let bytes = 0;
                let done;
                let _onFinish = (e)=>{
                    if (!done) {
                        done = true;
                        onFinish && onFinish(e);
                    }
                };
                return new ReadableStream({
                    async pull (controller) {
                        try {
                            const { done: done2, value } = await iterator2.next();
                            if (done2) {
                                _onFinish();
                                controller.close();
                                return;
                            }
                            let len = value.byteLength;
                            if (onProgress) {
                                let loadedBytes = bytes += len;
                                onProgress(loadedBytes);
                            }
                            controller.enqueue(new Uint8Array(value));
                        } catch (err) {
                            _onFinish(err);
                            throw err;
                        }
                    },
                    cancel (reason) {
                        _onFinish(reason);
                        return iterator2.return();
                    }
                }, {
                    highWaterMark: 2
                });
            };
            const DEFAULT_CHUNK_SIZE = 64 * 1024;
            const { isFunction } = utils$1;
            const globalFetchAPI = (({ Request, Response })=>({
                    Request,
                    Response
                }))(utils$1.global);
            const { ReadableStream: ReadableStream$1, TextEncoder } = utils$1.global;
            const test = (fn, ...args)=>{
                try {
                    return !!fn(...args);
                } catch (e) {
                    return false;
                }
            };
            const factory = (env)=>{
                env = utils$1.merge.call({
                    skipUndefined: true
                }, globalFetchAPI, env);
                const { fetch: envFetch, Request, Response } = env;
                const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
                const isRequestSupported = isFunction(Request);
                const isResponseSupported = isFunction(Response);
                if (!isFetchSupported) {
                    return false;
                }
                const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
                const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder)=>(str)=>encoder.encode(str))(new TextEncoder()) : async (str)=>new Uint8Array(await new Request(str).arrayBuffer()));
                const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(()=>{
                    let duplexAccessed = false;
                    const hasContentType = new Request(platform.origin, {
                        body: new ReadableStream$1(),
                        method: "POST",
                        get duplex () {
                            duplexAccessed = true;
                            return "half";
                        }
                    }).headers.has("Content-Type");
                    return duplexAccessed && !hasContentType;
                });
                const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(()=>utils$1.isReadableStream(new Response("").body));
                const resolvers = {
                    stream: supportsResponseStream && ((res)=>res.body)
                };
                isFetchSupported && (()=>{
                    [
                        "text",
                        "arrayBuffer",
                        "blob",
                        "formData",
                        "stream"
                    ].forEach((type)=>{
                        !resolvers[type] && (resolvers[type] = (res, config2)=>{
                            let method = res && res[type];
                            if (method) {
                                return method.call(res);
                            }
                            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config2);
                        });
                    });
                })();
                const getBodyLength = async (body)=>{
                    if (body == null) {
                        return 0;
                    }
                    if (utils$1.isBlob(body)) {
                        return body.size;
                    }
                    if (utils$1.isSpecCompliantForm(body)) {
                        const _request = new Request(platform.origin, {
                            method: "POST",
                            body
                        });
                        return (await _request.arrayBuffer()).byteLength;
                    }
                    if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
                        return body.byteLength;
                    }
                    if (utils$1.isURLSearchParams(body)) {
                        body = body + "";
                    }
                    if (utils$1.isString(body)) {
                        return (await encodeText(body)).byteLength;
                    }
                };
                const resolveBodyLength = async (headers, body)=>{
                    const length = utils$1.toFiniteNumber(headers.getContentLength());
                    return length == null ? getBodyLength(body) : length;
                };
                return async (config2)=>{
                    let { url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, withCredentials = "same-origin", fetchOptions } = resolveConfig(config2);
                    let _fetch = envFetch || fetch;
                    responseType = responseType ? (responseType + "").toLowerCase() : "text";
                    let composedSignal = composeSignals([
                        signal,
                        cancelToken && cancelToken.toAbortSignal()
                    ], timeout);
                    let request = null;
                    const unsubscribe = composedSignal && composedSignal.unsubscribe && (()=>{
                        composedSignal.unsubscribe();
                    });
                    let requestContentLength;
                    try {
                        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
                            let _request = new Request(url, {
                                method: "POST",
                                body: data,
                                duplex: "half"
                            });
                            let contentTypeHeader;
                            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
                                headers.setContentType(contentTypeHeader);
                            }
                            if (_request.body) {
                                const [onProgress, flush] = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress)));
                                data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
                            }
                        }
                        if (!utils$1.isString(withCredentials)) {
                            withCredentials = withCredentials ? "include" : "omit";
                        }
                        const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
                        const resolvedOptions = {
                            ...fetchOptions,
                            signal: composedSignal,
                            method: method.toUpperCase(),
                            headers: headers.normalize().toJSON(),
                            body: data,
                            duplex: "half",
                            credentials: isCredentialsSupported ? withCredentials : void 0
                        };
                        request = isRequestSupported && new Request(url, resolvedOptions);
                        let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
                        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
                        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
                            const options = {};
                            [
                                "status",
                                "statusText",
                                "headers"
                            ].forEach((prop)=>{
                                options[prop] = response[prop];
                            });
                            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
                            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [];
                            response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, ()=>{
                                flush && flush();
                                unsubscribe && unsubscribe();
                            }), options);
                        }
                        responseType = responseType || "text";
                        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config2);
                        !isStreamResponse && unsubscribe && unsubscribe();
                        return await new Promise((resolve2, reject)=>{
                            settle(resolve2, reject, {
                                data: responseData,
                                headers: AxiosHeaders$1.from(response.headers),
                                status: response.status,
                                statusText: response.statusText,
                                config: config2,
                                request
                            });
                        });
                    } catch (err) {
                        unsubscribe && unsubscribe();
                        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
                            throw Object.assign(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request), {
                                cause: err.cause || err
                            });
                        }
                        throw AxiosError$1.from(err, err && err.code, config2, request);
                    }
                };
            };
            const seedCache = new Map();
            const getFetch = (config2)=>{
                let env = config2 ? config2.env : {};
                const { fetch: fetch2, Request, Response } = env;
                const seeds = [
                    Request,
                    Response,
                    fetch2
                ];
                let len = seeds.length, i = len, seed, target, map = seedCache;
                while(i--){
                    seed = seeds[i];
                    target = map.get(seed);
                    target === void 0 && map.set(seed, target = i ? new Map() : factory(env));
                    map = target;
                }
                return target;
            };
            getFetch();
            const knownAdapters = {
                http: httpAdapter,
                xhr: xhrAdapter,
                fetch: {
                    get: getFetch
                }
            };
            utils$1.forEach(knownAdapters, (fn, value)=>{
                if (fn) {
                    try {
                        Object.defineProperty(fn, "name", {
                            value
                        });
                    } catch (e) {}
                    Object.defineProperty(fn, "adapterName", {
                        value
                    });
                }
            });
            const renderReason = (reason)=>`- ${reason}`;
            const isResolvedHandle = (adapter)=>utils$1.isFunction(adapter) || adapter === null || adapter === false;
            const adapters = {
                getAdapter: (adapters2, config2)=>{
                    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [
                        adapters2
                    ];
                    const { length } = adapters2;
                    let nameOrAdapter;
                    let adapter;
                    const rejectedReasons = {};
                    for(let i = 0; i < length; i++){
                        nameOrAdapter = adapters2[i];
                        let id;
                        adapter = nameOrAdapter;
                        if (!isResolvedHandle(nameOrAdapter)) {
                            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                            if (adapter === void 0) {
                                throw new AxiosError$1(`Unknown adapter '${id}'`);
                            }
                        }
                        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config2)))) {
                            break;
                        }
                        rejectedReasons[id || "#" + i] = adapter;
                    }
                    if (!adapter) {
                        const reasons = Object.entries(rejectedReasons).map(([id, state])=>`adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build"));
                        let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
                        throw new AxiosError$1(`There is no suitable adapter to dispatch the request ` + s2, "ERR_NOT_SUPPORT");
                    }
                    return adapter;
                },
                adapters: knownAdapters
            };
            function throwIfCancellationRequested(config2) {
                if (config2.cancelToken) {
                    config2.cancelToken.throwIfRequested();
                }
                if (config2.signal && config2.signal.aborted) {
                    throw new CanceledError$1(null, config2);
                }
            }
            function dispatchRequest(config2) {
                throwIfCancellationRequested(config2);
                config2.headers = AxiosHeaders$1.from(config2.headers);
                config2.data = transformData.call(config2, config2.transformRequest);
                if ([
                    "post",
                    "put",
                    "patch"
                ].indexOf(config2.method) !== -1) {
                    config2.headers.setContentType("application/x-www-form-urlencoded", false);
                }
                const adapter = adapters.getAdapter(config2.adapter || defaults.adapter, config2);
                return adapter(config2).then(function onAdapterResolution(response) {
                    throwIfCancellationRequested(config2);
                    response.data = transformData.call(config2, config2.transformResponse, response);
                    response.headers = AxiosHeaders$1.from(response.headers);
                    return response;
                }, function onAdapterRejection(reason) {
                    if (!isCancel$1(reason)) {
                        throwIfCancellationRequested(config2);
                        if (reason && reason.response) {
                            reason.response.data = transformData.call(config2, config2.transformResponse, reason.response);
                            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
                        }
                    }
                    return Promise.reject(reason);
                });
            }
            const VERSION$1 = "1.12.2";
            const validators$1 = {};
            [
                "object",
                "boolean",
                "number",
                "function",
                "string",
                "symbol"
            ].forEach((type, i)=>{
                validators$1[type] = function validator2(thing) {
                    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
                };
            });
            const deprecatedWarnings = {};
            validators$1.transitional = function transitional(validator2, version2, message) {
                function formatMessage(opt, desc) {
                    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
                }
                return (value, opt, opts)=>{
                    if (validator2 === false) {
                        throw new AxiosError$1(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")), AxiosError$1.ERR_DEPRECATED);
                    }
                    if (version2 && !deprecatedWarnings[opt]) {
                        deprecatedWarnings[opt] = true;
                        console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
                    }
                    return validator2 ? validator2(value, opt, opts) : true;
                };
            };
            validators$1.spelling = function spelling(correctSpelling) {
                return (value, opt)=>{
                    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
                    return true;
                };
            };
            function assertOptions(options, schema, allowUnknown) {
                if (typeof options !== "object") {
                    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
                }
                const keys = Object.keys(options);
                let i = keys.length;
                while(i-- > 0){
                    const opt = keys[i];
                    const validator2 = schema[opt];
                    if (validator2) {
                        const value = options[opt];
                        const result = value === void 0 || validator2(value, opt, options);
                        if (result !== true) {
                            throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
                        }
                        continue;
                    }
                    if (allowUnknown !== true) {
                        throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
                    }
                }
            }
            const validator = {
                assertOptions,
                validators: validators$1
            };
            const validators = validator.validators;
            let Axios$1 = class Axios {
                constructor(instanceConfig){
                    this.defaults = instanceConfig || {};
                    this.interceptors = {
                        request: new InterceptorManager(),
                        response: new InterceptorManager()
                    };
                }
                async request(configOrUrl, config2) {
                    try {
                        return await this._request(configOrUrl, config2);
                    } catch (err) {
                        if (err instanceof Error) {
                            let dummy = {};
                            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
                            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                            try {
                                if (!err.stack) {
                                    err.stack = stack2;
                                } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
                                    err.stack += "\n" + stack2;
                                }
                            } catch (e) {}
                        }
                        throw err;
                    }
                }
                _request(configOrUrl, config2) {
                    if (typeof configOrUrl === "string") {
                        config2 = config2 || {};
                        config2.url = configOrUrl;
                    } else {
                        config2 = configOrUrl || {};
                    }
                    config2 = mergeConfig$1(this.defaults, config2);
                    const { transitional, paramsSerializer, headers } = config2;
                    if (transitional !== void 0) {
                        validator.assertOptions(transitional, {
                            silentJSONParsing: validators.transitional(validators.boolean),
                            forcedJSONParsing: validators.transitional(validators.boolean),
                            clarifyTimeoutError: validators.transitional(validators.boolean)
                        }, false);
                    }
                    if (paramsSerializer != null) {
                        if (utils$1.isFunction(paramsSerializer)) {
                            config2.paramsSerializer = {
                                serialize: paramsSerializer
                            };
                        } else {
                            validator.assertOptions(paramsSerializer, {
                                encode: validators.function,
                                serialize: validators.function
                            }, true);
                        }
                    }
                    if (config2.allowAbsoluteUrls !== void 0) ;
                    else if (this.defaults.allowAbsoluteUrls !== void 0) {
                        config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
                    } else {
                        config2.allowAbsoluteUrls = true;
                    }
                    validator.assertOptions(config2, {
                        baseUrl: validators.spelling("baseURL"),
                        withXsrfToken: validators.spelling("withXSRFToken")
                    }, true);
                    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
                    let contextHeaders = headers && utils$1.merge(headers.common, headers[config2.method]);
                    headers && utils$1.forEach([
                        "delete",
                        "get",
                        "head",
                        "post",
                        "put",
                        "patch",
                        "common"
                    ], (method)=>{
                        delete headers[method];
                    });
                    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
                    const requestInterceptorChain = [];
                    let synchronousRequestInterceptors = true;
                    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
                            return;
                        }
                        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
                        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
                    });
                    const responseInterceptorChain = [];
                    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                    });
                    let promise;
                    let i = 0;
                    let len;
                    if (!synchronousRequestInterceptors) {
                        const chain = [
                            dispatchRequest.bind(this),
                            void 0
                        ];
                        chain.unshift(...requestInterceptorChain);
                        chain.push(...responseInterceptorChain);
                        len = chain.length;
                        promise = Promise.resolve(config2);
                        while(i < len){
                            promise = promise.then(chain[i++], chain[i++]);
                        }
                        return promise;
                    }
                    len = requestInterceptorChain.length;
                    let newConfig = config2;
                    while(i < len){
                        const onFulfilled = requestInterceptorChain[i++];
                        const onRejected = requestInterceptorChain[i++];
                        try {
                            newConfig = onFulfilled(newConfig);
                        } catch (error) {
                            onRejected.call(this, error);
                            break;
                        }
                    }
                    try {
                        promise = dispatchRequest.call(this, newConfig);
                    } catch (error) {
                        return Promise.reject(error);
                    }
                    i = 0;
                    len = responseInterceptorChain.length;
                    while(i < len){
                        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
                    }
                    return promise;
                }
                getUri(config2) {
                    config2 = mergeConfig$1(this.defaults, config2);
                    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
                    return buildURL(fullPath, config2.params, config2.paramsSerializer);
                }
            };
            utils$1.forEach([
                "delete",
                "get",
                "head",
                "options"
            ], function forEachMethodNoData(method) {
                Axios$1.prototype[method] = function(url, config2) {
                    return this.request(mergeConfig$1(config2 || {}, {
                        method,
                        url,
                        data: (config2 || {}).data
                    }));
                };
            });
            utils$1.forEach([
                "post",
                "put",
                "patch"
            ], function forEachMethodWithData(method) {
                function generateHTTPMethod(isForm) {
                    return function httpMethod(url, data, config2) {
                        return this.request(mergeConfig$1(config2 || {}, {
                            method,
                            headers: isForm ? {
                                "Content-Type": "multipart/form-data"
                            } : {},
                            url,
                            data
                        }));
                    };
                }
                Axios$1.prototype[method] = generateHTTPMethod();
                Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
            });
            let CancelToken$1 = class CancelToken2 {
                constructor(executor){
                    if (typeof executor !== "function") {
                        throw new TypeError("executor must be a function.");
                    }
                    let resolvePromise;
                    this.promise = new Promise(function promiseExecutor(resolve2) {
                        resolvePromise = resolve2;
                    });
                    const token = this;
                    this.promise.then((cancel)=>{
                        if (!token._listeners) return;
                        let i = token._listeners.length;
                        while(i-- > 0){
                            token._listeners[i](cancel);
                        }
                        token._listeners = null;
                    });
                    this.promise.then = (onfulfilled)=>{
                        let _resolve;
                        const promise = new Promise((resolve2)=>{
                            token.subscribe(resolve2);
                            _resolve = resolve2;
                        }).then(onfulfilled);
                        promise.cancel = function reject() {
                            token.unsubscribe(_resolve);
                        };
                        return promise;
                    };
                    executor(function cancel(message, config2, request) {
                        if (token.reason) {
                            return;
                        }
                        token.reason = new CanceledError$1(message, config2, request);
                        resolvePromise(token.reason);
                    });
                }
                throwIfRequested() {
                    if (this.reason) {
                        throw this.reason;
                    }
                }
                subscribe(listener2) {
                    if (this.reason) {
                        listener2(this.reason);
                        return;
                    }
                    if (this._listeners) {
                        this._listeners.push(listener2);
                    } else {
                        this._listeners = [
                            listener2
                        ];
                    }
                }
                unsubscribe(listener2) {
                    if (!this._listeners) {
                        return;
                    }
                    const index = this._listeners.indexOf(listener2);
                    if (index !== -1) {
                        this._listeners.splice(index, 1);
                    }
                }
                toAbortSignal() {
                    const controller = new AbortController();
                    const abort = (err)=>{
                        controller.abort(err);
                    };
                    this.subscribe(abort);
                    controller.signal.unsubscribe = ()=>this.unsubscribe(abort);
                    return controller.signal;
                }
                static source() {
                    let cancel;
                    const token = new CancelToken2(function executor(c) {
                        cancel = c;
                    });
                    return {
                        token,
                        cancel
                    };
                }
            };
            function spread$1(callback) {
                return function wrap(arr) {
                    return callback.apply(null, arr);
                };
            }
            function isAxiosError$1(payload) {
                return utils$1.isObject(payload) && payload.isAxiosError === true;
            }
            const HttpStatusCode$1 = {
                Continue: 100,
                SwitchingProtocols: 101,
                Processing: 102,
                EarlyHints: 103,
                Ok: 200,
                Created: 201,
                Accepted: 202,
                NonAuthoritativeInformation: 203,
                NoContent: 204,
                ResetContent: 205,
                PartialContent: 206,
                MultiStatus: 207,
                AlreadyReported: 208,
                ImUsed: 226,
                MultipleChoices: 300,
                MovedPermanently: 301,
                Found: 302,
                SeeOther: 303,
                NotModified: 304,
                UseProxy: 305,
                Unused: 306,
                TemporaryRedirect: 307,
                PermanentRedirect: 308,
                BadRequest: 400,
                Unauthorized: 401,
                PaymentRequired: 402,
                Forbidden: 403,
                NotFound: 404,
                MethodNotAllowed: 405,
                NotAcceptable: 406,
                ProxyAuthenticationRequired: 407,
                RequestTimeout: 408,
                Conflict: 409,
                Gone: 410,
                LengthRequired: 411,
                PreconditionFailed: 412,
                PayloadTooLarge: 413,
                UriTooLong: 414,
                UnsupportedMediaType: 415,
                RangeNotSatisfiable: 416,
                ExpectationFailed: 417,
                ImATeapot: 418,
                MisdirectedRequest: 421,
                UnprocessableEntity: 422,
                Locked: 423,
                FailedDependency: 424,
                TooEarly: 425,
                UpgradeRequired: 426,
                PreconditionRequired: 428,
                TooManyRequests: 429,
                RequestHeaderFieldsTooLarge: 431,
                UnavailableForLegalReasons: 451,
                InternalServerError: 500,
                NotImplemented: 501,
                BadGateway: 502,
                ServiceUnavailable: 503,
                GatewayTimeout: 504,
                HttpVersionNotSupported: 505,
                VariantAlsoNegotiates: 506,
                InsufficientStorage: 507,
                LoopDetected: 508,
                NotExtended: 510,
                NetworkAuthenticationRequired: 511
            };
            Object.entries(HttpStatusCode$1).forEach(([key, value])=>{
                HttpStatusCode$1[value] = key;
            });
            function createInstance(defaultConfig) {
                const context = new Axios$1(defaultConfig);
                const instance = bind(Axios$1.prototype.request, context);
                utils$1.extend(instance, Axios$1.prototype, context, {
                    allOwnKeys: true
                });
                utils$1.extend(instance, context, null, {
                    allOwnKeys: true
                });
                instance.create = function create(instanceConfig) {
                    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
                };
                return instance;
            }
            const axios = createInstance(defaults);
            axios.Axios = Axios$1;
            axios.CanceledError = CanceledError$1;
            axios.CancelToken = CancelToken$1;
            axios.isCancel = isCancel$1;
            axios.VERSION = VERSION$1;
            axios.toFormData = toFormData$1;
            axios.AxiosError = AxiosError$1;
            axios.Cancel = axios.CanceledError;
            axios.all = function all2(promises) {
                return Promise.all(promises);
            };
            axios.spread = spread$1;
            axios.isAxiosError = isAxiosError$1;
            axios.mergeConfig = mergeConfig$1;
            axios.AxiosHeaders = AxiosHeaders$1;
            axios.formToJSON = (thing)=>formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
            axios.getAdapter = adapters.getAdapter;
            axios.HttpStatusCode = HttpStatusCode$1;
            axios.default = axios;
            const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = axios;
            const $http = exports("$", axios.create({
                baseURL: "_debugger/",
                timeout: 5e3
            }));
            $http.interceptors.request.use(async (config2)=>{
                config2.params = config2.params || {};
                config2.params.id = currentId.value;
                return config2;
            });
            const routes = [
                {
                    name: "dashboard",
                    path: "/",
                    component: ()=>__vitePreload(()=>module.import("./Dashboard-CTQktwXJ.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "system",
                    path: "/system/:id?",
                    component: ()=>__vitePreload(()=>module.import("./System-mCjgQaeT.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "request",
                    path: "/request/:id?",
                    component: ()=>__vitePreload(()=>module.import("./Request-CBYn3OvW.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "routing",
                    path: "/routing/:id?",
                    component: ()=>__vitePreload(()=>module.import("./Routing-DcsHT2yG.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "timeline",
                    path: "/timeline/:id?",
                    component: ()=>__vitePreload(()=>module.import("./Timeline-C7D5bAor.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "events",
                    path: "/events/:id?",
                    component: ()=>__vitePreload(()=>module.import("./Events-Bkf9z-y7.js"), false ? __VITE_PRELOAD__ : void 0)
                },
                {
                    name: "db",
                    path: "/db/:id?",
                    component: ()=>__vitePreload(()=>module.import("./Database-GcFkATI6.js"), false ? __VITE_PRELOAD__ : void 0)
                }
            ];
            const router = exports("j", createRouter({
                history: createWebHashHistory(),
                routes
            }));
            router.beforeEach(async (to, from)=>{
                if (to.path !== "/" && !to.params.id) {
                    if (currentId.value) {
                        return to.path + "/" + currentId.value;
                    } else {
                        return "/";
                    }
                }
                if (to.params.id) {
                    if (currentId.value !== to.params.id) {
                        currentId.value = to.params.id;
                        const params = new URLSearchParams({
                            "path[url]": "http::systemUri.full",
                            "path[status]": "http::response.status"
                        });
                        const res = await $http.get("ajax/data?" + params.toString());
                        currentData.value = res.data.data;
                    }
                }
            });
            __vitePreload(()=>module.import("./debugger-CP4dOO6Z.js"), false ? __VITE_PRELOAD__ : void 0);
            const app = createApp(App).use(router).component("fa-icon", FontAwesomeIcon);
            app.mount("app");
        })
    };
}));
